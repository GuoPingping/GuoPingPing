<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>NodeJs之zlib</title>
      <link href="/articles/2020-02-07-node-zlib.html"/>
      <url>/articles/2020-02-07-node-zlib.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之worker_threads</title>
      <link href="/articles/2020-02-07-node-worker-threads.html"/>
      <url>/articles/2020-02-07-node-worker-threads.html</url>
      
        <content type="html"><![CDATA[<h2 id="worker-threads"><a href="#worker-threads" class="headerlink" title="worker_threads"></a>worker_threads</h2><p>工作线程。<br>worker_threads模块允许使用并行的执行JavaScript的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const worker &#x3D; require(&#39;worker_threads&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>工作线程对于执行CPU密集型的JavaScript操作非常有用。<br>它们在I/O密集型的工作中用途不大。<br>Nodejs的内置的异步I/O操作比工作线程效率更高。</p><p>与child_process或cluster不同，worker_threads可以共享内存，它们通过传输ArrayBuffer实例或共享SharedArrayBuffer实例来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  Worker, isMainThread, parentPort, workerData</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  module.exports &#x3D; function parseJSAsync(script) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      const worker &#x3D; new Worker(__filename, &#123;</span><br><span class="line">        workerData: script</span><br><span class="line">      &#125;);</span><br><span class="line">      worker.on(&#39;message&#39;, resolve);</span><br><span class="line">      worker.on(&#39;error&#39;, reject);</span><br><span class="line">      worker.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">        if (code !&#x3D;&#x3D; 0)</span><br><span class="line">          reject(new Error(&#96;工作线程使用退出码 $&#123;code&#125; 停止&#96;));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const &#123; parse &#125; &#x3D; require(&#39;一些 js 解析库&#39;);</span><br><span class="line">  const script &#x3D; workerData;</span><br><span class="line">  parentPort.postMessage(parse(script));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例为每个parse()调用衍生一个工作进程。在实际的实践中，应使用工作线程池代替这些任务。<br>否则，创建工作线程的开销可能会超出其收益。</p><p>当实现工作线程池时，可使用AsyncResource API来通知诊断的工具有关任务极其结果之间的相关性。</p><h4 id="worker-isMainThread"><a href="#worker-isMainThread" class="headerlink" title="worker.isMainThread"></a>worker.isMainThread</h4><p>如果代码不在Worker线程内运行，则为True。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread &#125; &#x3D; require(&#39;worker_threads)</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这会在工作线程实例中重新加载当前文件。</span><br><span class="line">    new Worker(__filename)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#39;在工作线程中&#39;)</span><br><span class="line">    console.log(isMainThread)  &#x2F;&#x2F; 打印false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="worker-moveMessagePortToContext-port-contextifiedSandbox"><a href="#worker-moveMessagePortToContext-port-contextifiedSandbox" class="headerlink" title="worker.moveMessagePortToContext(port, contextifiedSandbox)"></a>worker.moveMessagePortToContext(port, contextifiedSandbox)</h4><h4 id="worker-parentPort"><a href="#worker-parentPort" class="headerlink" title="worker.parentPort"></a>worker.parentPort</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  worker.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(message);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">  &#125;);</span><br><span class="line">  worker.postMessage(&#39;Hello, world!&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; When a message from the parent thread is received, send it back:</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    parentPort.postMessage(message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="worker-receiveMessageOnPort-port"><a href="#worker-receiveMessageOnPort-port" class="headerlink" title="worker.receiveMessageOnPort(port)"></a>worker.receiveMessageOnPort(port)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel, receiveMessageOnPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.postMessage(&#123; hello: &#39;world&#39; &#125;);</span><br><span class="line"></span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; message: &#123; hello: &#39;world&#39; &#125; &#125;</span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: undefined</span><br></pre></td></tr></table></figure><h4 id="worker-SHARE-ENV"><a href="#worker-SHARE-ENV" class="headerlink" title="worker.SHARE_ENV"></a>worker.SHARE_ENV</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, SHARE_ENV &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">new Worker(&#39;process.env.SET_IN_WORKER &#x3D; &quot;foo&quot;&#39;, &#123; eval: true, env: SHARE_ENV &#125;)</span><br><span class="line">  .on(&#39;exit&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(process.env.SET_IN_WORKER);  &#x2F;&#x2F; Prints &#39;foo&#39;.</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="worker-workerData"><a href="#worker-workerData" class="headerlink" title="worker.workerData"></a>worker.workerData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, workerData &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename, &#123; workerData: &#39;Hello, world!&#39; &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(workerData);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MessageChannel类"><a href="#MessageChannel类" class="headerlink" title="MessageChannel类"></a>MessageChannel类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(&#39;received&#39;, message));</span><br><span class="line">port2.postMessage(&#123; foo: &#39;bar&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; Prints: received &#123; foo: &#39;bar&#39; &#125; from the &#96;port1.on(&#39;message&#39;)&#96; listener</span><br></pre></td></tr></table></figure><h4 id="MessagePort类"><a href="#MessagePort类" class="headerlink" title="MessagePort类"></a>MessagePort类</h4><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F;   foobar</span><br><span class="line">&#x2F;&#x2F;   closed!</span><br><span class="line">port2.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line">port2.on(&#39;close&#39;, () &#x3D;&gt; console.log(&#39;closed!&#39;));</span><br><span class="line"></span><br><span class="line">port1.postMessage(&#39;foobar&#39;);</span><br><span class="line">port1.close();</span><br></pre></td></tr></table></figure><h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><h5 id="port-close"><a href="#port-close" class="headerlink" title="port.close()"></a>port.close()</h5><h5 id="port-postMessage-value-transferList"><a href="#port-postMessage-value-transferList" class="headerlink" title="port.postMessage(value[, transferList])"></a>port.postMessage(value[, transferList])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line"></span><br><span class="line">const circularData &#x3D; &#123;&#125;;</span><br><span class="line">circularData.foo &#x3D; circularData;</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; foo: [Circular] &#125;</span><br><span class="line">port2.postMessage(circularData);</span><br></pre></td></tr></table></figure><h5 id="port-ref"><a href="#port-ref" class="headerlink" title="port.ref()"></a>port.ref()</h5><h5 id="port-start"><a href="#port-start" class="headerlink" title="port.start()"></a>port.start()</h5><h5 id="port-unref"><a href="#port-unref" class="headerlink" title="port.unref()"></a>port.unref()</h5><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker类代表一个独立的JavaScript执行线程。大多数Nodejs API都在其中可用。</p><p>可以在其它Worker实例中创建Worker实例。</p><p>与Web工作线程和cluster模块一样，可以通过线程间的消息传递来实现双向通信。<br>在内部，一个Worker具有一对内置的MessagePort，在创建该Worker时他们已经相互关联。<br>虽然父端的MessagePort对象没有直接公开，但其功能是通过父线程的Worker对象上的worker.postMessage()和worker.on(‘message’)事件公开的。</p><p>要创建自定义的消息传递通道，用户可以在任一线程上创建一个MessageChannel对象，并将该Messagechannel上的MessagePort中的一个通过预先存在的通道传给另一个线程，例如全局通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker, MessageChannel, MessagePort, isMainThread, parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  const subChannel &#x3D; new MessageChannel();</span><br><span class="line">  worker.postMessage(&#123; hereIsYourPort: subChannel.port1 &#125;, [subChannel.port1]);</span><br><span class="line">  subChannel.port2.on(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到:&#39;, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    assert(value.hereIsYourPort instanceof MessagePort);</span><br><span class="line">    value.hereIsYourPort.postMessage(&#39;工作线程正在发送此消息&#39;);</span><br><span class="line">    value.hereIsYourPort.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="new-Worker-filename-options"><a href="#new-Worker-filename-options" class="headerlink" title="new Worker(filename[, options])"></a>new Worker(filename[, options])</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><h5 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h5><h5 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h5><h5 id="worker-postMessage-value-transferList"><a href="#worker-postMessage-value-transferList" class="headerlink" title="worker.postMessage(value[, transferList])"></a>worker.postMessage(value[, transferList])</h5><h5 id="worker-ref"><a href="#worker-ref" class="headerlink" title="worker.ref()"></a>worker.ref()</h5><h5 id="worker-stderr"><a href="#worker-stderr" class="headerlink" title="worker.stderr"></a>worker.stderr</h5><h5 id="worker-stdin"><a href="#worker-stdin" class="headerlink" title="worker.stdin"></a>worker.stdin</h5><h5 id="worker-stdout"><a href="#worker-stdout" class="headerlink" title="worker.stdout"></a>worker.stdout</h5><h5 id="worker-terminate"><a href="#worker-terminate" class="headerlink" title="worker.terminate()"></a>worker.terminate()</h5><h5 id="worker-threadld"><a href="#worker-threadld" class="headerlink" title="worker.threadld"></a>worker.threadld</h5><h5 id="worker-unref"><a href="#worker-unref" class="headerlink" title="worker.unref()"></a>worker.unref()</h5>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之vm</title>
      <link href="/articles/2020-02-07-node-vm.html"/>
      <url>/articles/2020-02-07-node-vm.html</url>
      
        <content type="html"><![CDATA[<h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>虚拟机。</p><p>vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。<br>vm模块不是一个安全的虚拟机。<br>不要用它来运行不受信任的代码。</p><p>JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。</p><p>一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。</p><p>可以通过上下文隔离化一个沙箱对象来提供上下文。<br>沙盒代码将沙盒中的任何属性视为全局对象。<br>由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; x: 2 &#125;;</span><br><span class="line">vm.createContext(sandbox); &#x2F;&#x2F; 上下文隔离化一个沙盒。</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#39;x +&#x3D; 40; var y &#x3D; 17;&#39;;</span><br><span class="line">&#x2F;&#x2F; &#96;x&#96; and &#96;y&#96; 是沙盒环境中的全局变量。</span><br><span class="line">&#x2F;&#x2F; 最初，x 的值为 2，因为这是 sandbox.x 的值。</span><br><span class="line">vm.runInContext(code, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(sandbox.x); &#x2F;&#x2F; 42</span><br><span class="line">console.log(sandbox.y); &#x2F;&#x2F; 17</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; 1; y 没有定义。</span><br></pre></td></tr></table></figure><h4 id="vm-Script类"><a href="#vm-Script类" class="headerlink" title="vm.Script类"></a>vm.Script类</h4><p>vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或上下文）中被运行。</p><h5 id="new-vm-Script-code-options"><a href="#new-vm-Script-code-options" class="headerlink" title="new vm.Script(code[, options])"></a>new vm.Script(code[, options])</h5><p>如果options是字符串，则它指定文件名。</p><p>创建一个新的vm.Script对象只编译code但不会执行它。<br>编译过的vm.Script此后可以被多次执行。<br>code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。</p><h5 id="script-createCachedData"><a href="#script-createCachedData" class="headerlink" title="script.createCachedData()"></a>script.createCachedData()</h5><p>创建一个可以被Script构造函数中cachedData选项使用的代码缓存，返回Buffer。<br>可以在任何时候不限次数的调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const script &#x3D; new vm.Script(&#96;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x &#x3D; add(1, 2);</span><br><span class="line">&#96;);</span><br><span class="line"></span><br><span class="line">const cacheWithoutX &#x3D; script.createCachedData();</span><br><span class="line"></span><br><span class="line">script.runInThisContext();</span><br><span class="line"></span><br><span class="line">const cacheWithX &#x3D; script.createCachedData();</span><br></pre></td></tr></table></figure><h5 id="script-runInContext-contextifiedSandbox-options"><a href="#script-runInContext-contextifiedSandbox-options" class="headerlink" title="script.runInContext(contextifiedSandbox[, options])"></a>script.runInContext(contextifiedSandbox[, options])</h5><p>在指定的contextifiedSandbox中执行vm.Script对象中被编译后的代码并返回结果。<br>被执行的代码无法获取本地作用域。</p><h5 id="script-runInNewContext-sandbox-options"><a href="#script-runInNewContext-sandbox-options" class="headerlink" title="script.runInNewContext([sandbox[, options]])"></a>script.runInNewContext([sandbox[, options]])</h5><p>首先给指定的sandbox提供一个隔离的上下文，再在此上下文执行vm.Script中被编译的代码，最后返回结果。运行中的代码无法获取本地作用域。</p><h5 id="script-runInThisContext-options"><a href="#script-runInThisContext-options" class="headerlink" title="script.runInThisContext([options])"></a>script.runInThisContext([options])</h5><p>在指定的global对象的上下文中执行vm.Script对象里被编译的代码并返回结果。被执行的代码无法获取本地作用域，但能获取global对象。</p><h4 id="vm-SourceTextModule类"><a href="#vm-SourceTextModule类" class="headerlink" title="vm.SourceTextModule类"></a>vm.SourceTextModule类</h4><h5 id="new-vm-SourceTextModule-code-options"><a href="#new-vm-SourceTextModule-code-options" class="headerlink" title="new vm.SourceTextModule(code[, options])"></a>new vm.SourceTextModule(code[, options])</h5><h5 id="module-dependencySpecifiers"><a href="#module-dependencySpecifiers" class="headerlink" title="module.dependencySpecifiers"></a>module.dependencySpecifiers</h5><h5 id="module-error"><a href="#module-error" class="headerlink" title="module.error"></a>module.error</h5><h5 id="module-evaluate-options"><a href="#module-evaluate-options" class="headerlink" title="module.evaluate([options])"></a>module.evaluate([options])</h5><h5 id="module-link-linker"><a href="#module-link-linker" class="headerlink" title="module.link(linker)"></a>module.link(linker)</h5><h5 id="module-namespace"><a href="#module-namespace" class="headerlink" title="module.namespace"></a>module.namespace</h5><h5 id="module-status"><a href="#module-status" class="headerlink" title="module.status"></a>module.status</h5><h5 id="module-identifier"><a href="#module-identifier" class="headerlink" title="module.identifier"></a>module.identifier</h5><h4 id="vm-compileFunction-code-params-options"><a href="#vm-compileFunction-code-params-options" class="headerlink" title="vm.compileFunction(code[, params[, options]])"></a>vm.compileFunction(code[, params[, options]])</h4><p>将给定的代码编译到提供的上下文/沙箱中（如果没有提供上下文，则使用当前上下文），并返回包装了给定params的函数。</p><h4 id="vm-createContext-sandbox-options"><a href="#vm-createContext-sandbox-options" class="headerlink" title="vm.createContext([sandbox[, options]])"></a>vm.createContext([sandbox[, options]])</h4><p>给定一个sandbox对象，vm.createContext()会设置此沙盒，从而让它具备在vm.runInContext()或者script.runInContext()中被使用的能力。对于此二方法中所调用的脚本，他们的全局对象不仅拥有我们提供的sandbox对象的所有属性，同时还有任何全局对象所拥有的属性。对于这些脚本之外的所有代码，他们的全局变量将保持不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">global.globalVar &#x3D; 3;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(sandbox)); &#x2F;&#x2F; &#123; globalVar: 2 &#125;</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(globalVar)); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>如果未提供sanbox或传入undefined，那么会返回一个全新的空的上下文隔离化后的sandbox对象。</p><p>vm.createContext()主要是用于创建一个能运行的多个脚本的沙盒。</p><h4 id="vm-isContext-sandbox"><a href="#vm-isContext-sandbox" class="headerlink" title="vm.isContext(sandbox)"></a>vm.isContext(sandbox)</h4><p>当给定的sanbox对象已经被vm.createContext()上下文隔离化，则返回true。</p><h4 id="vm-runInContext-code-contextifiedSandbox-options"><a href="#vm-runInContext-code-contextifiedSandbox-options" class="headerlink" title="vm.runInContext(code, contextifiedSandbox[, options])"></a>vm.runInContext(code, contextifiedSandbox[, options])</h4><p>vm.runInContext()方法会编译code，然后在指定的contextifiedSandbox的上下文里执行它并返回其结果。被执行的代码无法获取本地作用域。contextifiedSandbox必须是事先被vm.createContext()方法上下文隔离化过得对象。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line">&#125;</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; globalVar: 1024 &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInNewContext-code-sanbox-options"><a href="#vm-runInNewContext-code-sanbox-options" class="headerlink" title="vm.runInNewContext(code[, sanbox[, options]])"></a>vm.runInNewContext(code[, sanbox[, options]])</h4><p>vm.runInNewContext()首先给指定的sanbox（若为undefined，则会新建一个sandbox）提供一个隔离的上下文，再在此上下文中执行编译的code，最后返回结果。<br>运行中的代码无法获取本地作用域。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123;</span><br><span class="line">  animal: &#39;cat&#39;,</span><br><span class="line">  count: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.runInNewContext(&#39;count +&#x3D; 1; name &#x3D; &quot;kitty&quot;&#39;, sandbox);</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInThisContext-code-options"><a href="#vm-runInThisContext-code-options" class="headerlink" title="vm.runInThisContext(code[, options])"></a>vm.runInThisContext(code[, options])</h4><p>vm.runInThisContext()在当前的global对象的上下文中编译并执行code，最后返回结果。<br>运行中的代码无法获取本地作用域，但可以获取当前的global对象。</p><p>如果options是字符串，则它指定文件名。</p><h4 id="示例：在VM中运行HTTP-Server"><a href="#示例：在VM中运行HTTP-Server" class="headerlink" title="示例：在VM中运行HTTP Server"></a>示例：在VM中运行HTTP Server</h4><p>在私用script.runInThisContext()或者vm.runInThisContext()时，目标代码是在当前的V8quanju对象的上下文中执行的。被传入此虚拟机上下文的目标代码会有自己独立的作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#96;</span><br><span class="line">((require) &#x3D;&gt; &#123;</span><br><span class="line">  const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">  http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">    response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; &#125;);</span><br><span class="line">    response.end(&#39;你好世界\\n&#39;);</span><br><span class="line">  &#125;).listen(8124);</span><br><span class="line"></span><br><span class="line">  console.log(&#39;服务器运行在 http:&#x2F;&#x2F;127.0.0.1:8124&#x2F;&#39;);</span><br><span class="line">&#125;)&#96;;</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(code)(require);</span><br></pre></td></tr></table></figure><h4 id="上下文隔离化一个对象意味着什么？"><a href="#上下文隔离化一个对象意味着什么？" class="headerlink" title="上下文隔离化一个对象意味着什么？"></a>上下文隔离化一个对象意味着什么？</h4><p>所有用Nodejs所运行的JavaScript代码都是在一个上下文的作用域中被执行的。根据V8嵌入式指南：</p><blockquote><p>在V8中，一个上下文是一个执行环境，它允许分离的，无关的JavaScript应用在一个V8的单例中被运行。<br>必须明确的指定用于运行所有JavaScript代码的上下文。</p></blockquote><p>当调用vm.createContext()时，传入的sanbox对象在底层会和一个新的V8上下文实例联系上。<br>这个V8上下文在一个隔离的全局环境中，使用vm模块的方法运行code。<br>创建V8上下文和使之联系上sanbox的过程在此文档中被称作为“上下文隔离化”sandbox。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之V8</title>
      <link href="/articles/2020-02-07-node-V8.html"/>
      <url>/articles/2020-02-07-node-V8.html</url>
      
        <content type="html"><![CDATA[<h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>V8引擎。</p><p>v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const v8 &#x3D; require(&#39;v8&#39;)</span><br></pre></td></tr></table></figure><p>API和实现随时可能发生变化。</p><a id="more"></a><h4 id="v8-cachedDataVersionTag"><a href="#v8-cachedDataVersionTag" class="headerlink" title="v8.cachedDataVersionTag()"></a>v8.cachedDataVersionTag()</h4><p>返回一个整数，表示从V8版本、命令行标志、以及检测到的CPU特性派生的版本标记。<br>这对于判断vm.Script的cachedData buffer是否与此V8实例兼容非常有用。</p><h4 id="v8-getHeapSpaceStatistics"><a href="#v8-getHeapSpaceStatistics" class="headerlink" title="v8.getHeapSpaceStatistics()"></a>v8.getHeapSpaceStatistics()</h4><p>返回有关的V8堆空间的统计信息，即组成V8堆的片段。<br>由于统计信息是通过V8的GetHeapSpaceStatistics函数提供的，因此可以保证堆空间的排序以及堆控件的可用性，并且可以从一个V8版本更改为下一个版本。</p><h4 id="v8-getHeapSnapshot"><a href="#v8-getHeapSnapshot" class="headerlink" title="v8.getHeapSnapshot()"></a>v8.getHeapSnapshot()</h4><p>生成当前V8堆的快照，并返回可读流，该可读流用于读取JSON序列化表示。<br>此JSON流格式旨在与Chrome DevTools等工具一起使用。<br>JSON模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const stream &#x3D; v8.getHeapSnapshot();</span><br><span class="line">stream.pipe(process.stdout);</span><br></pre></td></tr></table></figure><h4 id="v8-getHeapStatistics"><a href="#v8-getHeapStatistics" class="headerlink" title="v8.getHeapStatistics()"></a>v8.getHeapStatistics()</h4><h4 id="v8-getHeapCodeStatistics"><a href="#v8-getHeapCodeStatistics" class="headerlink" title="v8.getHeapCodeStatistics()"></a>v8.getHeapCodeStatistics()</h4><p>返回一下属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code_and_metadata_size: 212208,</span><br><span class="line">  bytecode_and_metadata_size: 161368,</span><br><span class="line">  external_script_source_size: 1410794</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v8-setFlagsFromString-flags"><a href="#v8-setFlagsFromString-flags" class="headerlink" title="v8.setFlagsFromString(flags)"></a>v8.setFlagsFromString(flags)</h4><p>该方法可以用于以编程方式设置V8de命令行标志。<br>虚拟机启动后更改设置可能会导致不可预测的行为，包括崩溃和数据丢失，或者它可能根本就什么都不做。</p><p>可以通过运行node –v8-options来检查可用于nodejs版本的V8选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 GC 事件打印到 stdout 一分钟。</span><br><span class="line">const v8 &#x3D; require(&#39;v8&#39;);</span><br><span class="line">v8.setFlagsFromString(&#39;--trace_gc&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; v8.setFlagsFromString(&#39;--notrace_gc&#39;); &#125;, 60e3);</span><br></pre></td></tr></table></figure><h4 id="v8-writeHeapSnapshot-filename"><a href="#v8-writeHeapSnapshot-filename" class="headerlink" title="v8.writeHeapSnapshot([filename])"></a>v8.writeHeapSnapshot([filename])</h4><p>生成当前v8堆的快照并将其写入Json文件。<br>此文件旨在与Chrome DevTools等工具一起使用。<br>Json模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><p>堆快照特定于单个V8隔离。<br>使用工作线程时，从主线程生成的堆快照将不包含有关工作线程的任何信息，反之亦然。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const &#123; writeHeapSnapshot &#125; &#x3D; require(&#39;v8&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker,</span><br><span class="line">  isMainThread,</span><br><span class="line">  parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line"></span><br><span class="line">  worker.once(&#39;message&#39;, (filename) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作线程的堆转储: $&#123;filename&#125;&#96;);</span><br><span class="line">    &#x2F;&#x2F; 获取主线程的堆转储。</span><br><span class="line">    console.log(&#96;主线程的堆转储: $&#123;writeHeapSnapshot()&#125;&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知工作线程创建一个堆转储。</span><br><span class="line">  worker.postMessage(&#39;heapdump&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    if (message &#x3D;&#x3D;&#x3D; &#39;heapdump&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 为工作线程生成一个堆转储，并返回文件名到父线程。</span><br><span class="line">      parentPort.postMessage(writeHeapSnapshot());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化的API"><a href="#序列化的API" class="headerlink" title="序列化的API"></a>序列化的API</h4><h5 id="v8-serialize-value"><a href="#v8-serialize-value" class="headerlink" title="v8.serialize(value)"></a>v8.serialize(value)</h5><h5 id="v8-deserialize-buffer"><a href="#v8-deserialize-buffer" class="headerlink" title="v8.deserialize(buffer)"></a>v8.deserialize(buffer)</h5><h5 id="v8-Serializer类"><a href="#v8-Serializer类" class="headerlink" title="v8.Serializer类"></a>v8.Serializer类</h5><h6 id="new-Serializer"><a href="#new-Serializer" class="headerlink" title="new Serializer()"></a>new Serializer()</h6><h6 id="serializer-writeHeader"><a href="#serializer-writeHeader" class="headerlink" title="serializer.writeHeader()"></a>serializer.writeHeader()</h6><h6 id="serializer-releaseBuffer"><a href="#serializer-releaseBuffer" class="headerlink" title="serializer.releaseBuffer()"></a>serializer.releaseBuffer()</h6><h6 id="serializer-transferArrayBuffer-id-arrayBuffer"><a href="#serializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="serializer.transferArrayBuffer(id, arrayBuffer)"></a>serializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="serializer-writeUint32-value"><a href="#serializer-writeUint32-value" class="headerlink" title="serializer.writeUint32(value)"></a>serializer.writeUint32(value)</h6><h6 id="serializer-writeUint64-hi-Io"><a href="#serializer-writeUint64-hi-Io" class="headerlink" title="serializer.writeUint64(hi, Io)"></a>serializer.writeUint64(hi, Io)</h6><h6 id="serializer-writeDouble-value"><a href="#serializer-writeDouble-value" class="headerlink" title="serializer.writeDouble(value)"></a>serializer.writeDouble(value)</h6><h6 id="serializer-writeRawBytes-buffer"><a href="#serializer-writeRawBytes-buffer" class="headerlink" title="serializer.writeRawBytes(buffer)"></a>serializer.writeRawBytes(buffer)</h6><h6 id="serializer-writeHostObject-object"><a href="#serializer-writeHostObject-object" class="headerlink" title="serializer._writeHostObject(object)"></a>serializer._writeHostObject(object)</h6><h6 id="serializer-getDataCloneError-message"><a href="#serializer-getDataCloneError-message" class="headerlink" title="serializer._getDataCloneError(message)"></a>serializer._getDataCloneError(message)</h6><h6 id="serializer-getSharedArrayBufferId-sharedArrayBuffer"><a href="#serializer-getSharedArrayBufferId-sharedArrayBuffer" class="headerlink" title="serializer._getSharedArrayBufferId(sharedArrayBuffer)"></a>serializer._getSharedArrayBufferId(sharedArrayBuffer)</h6><h6 id="serializer-setTreatArrayBufferViewsAsHostObjects-flag"><a href="#serializer-setTreatArrayBufferViewsAsHostObjects-flag" class="headerlink" title="serializer._setTreatArrayBufferViewsAsHostObjects(flag)"></a>serializer._setTreatArrayBufferViewsAsHostObjects(flag)</h6><h5 id="v8-Deserializer类"><a href="#v8-Deserializer类" class="headerlink" title="v8.Deserializer类"></a>v8.Deserializer类</h5><h6 id="new-Deserializer-buffer"><a href="#new-Deserializer-buffer" class="headerlink" title="new Deserializer(buffer)"></a>new Deserializer(buffer)</h6><h6 id="deserializer-readHeader"><a href="#deserializer-readHeader" class="headerlink" title="deserializer.readHeader()"></a>deserializer.readHeader()</h6><h6 id="deserializer-readValue"><a href="#deserializer-readValue" class="headerlink" title="deserializer.readValue()"></a>deserializer.readValue()</h6><h6 id="deserializer-transferArrayBuffer-id-arrayBuffer"><a href="#deserializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="deserializer.transferArrayBuffer(id, arrayBuffer)"></a>deserializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="deserializer-getWriteFormatVersion"><a href="#deserializer-getWriteFormatVersion" class="headerlink" title="deserializer.getWriteFormatVersion()"></a>deserializer.getWriteFormatVersion()</h6><h6 id="deserializer-readUint32"><a href="#deserializer-readUint32" class="headerlink" title="deserializer.readUint32()"></a>deserializer.readUint32()</h6><h6 id="deserializer-readUint64"><a href="#deserializer-readUint64" class="headerlink" title="deserializer.readUint64()"></a>deserializer.readUint64()</h6><h6 id="deserializer-readDouble"><a href="#deserializer-readDouble" class="headerlink" title="deserializer.readDouble()"></a>deserializer.readDouble()</h6><h6 id="deserializer-readRawBytes-length"><a href="#deserializer-readRawBytes-length" class="headerlink" title="deserializer.readRawBytes(length)"></a>deserializer.readRawBytes(length)</h6><h6 id="deserializer-readHostObject"><a href="#deserializer-readHostObject" class="headerlink" title="deserializer._readHostObject()"></a>deserializer._readHostObject()</h6><h5 id="v8-DefaultSerializer类"><a href="#v8-DefaultSerializer类" class="headerlink" title="v8.DefaultSerializer类"></a>v8.DefaultSerializer类</h5><h5 id="v8-DefaultDeserializer类"><a href="#v8-DefaultDeserializer类" class="headerlink" title="v8.DefaultDeserializer类"></a>v8.DefaultDeserializer类</h5>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之util</title>
      <link href="/articles/2020-02-07-node-util.html"/>
      <url>/articles/2020-02-07-node-util.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之url</title>
      <link href="/articles/2020-02-07-node-url.html"/>
      <url>/articles/2020-02-07-node-url.html</url>
      
        <content type="html"><![CDATA[<h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>url模块用于处理与解析URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url &#x3D; require(&#39;url&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="URL字符串与URL对象"><a href="#URL字符串与URL对象" class="headerlink" title="URL字符串与URL对象"></a>URL字符串与URL对象</h4><p>URL字符串是结构化的字符串，包含多个含义不同的组成部分。<br>解析字符串后返回的URL对象，每个属性对应字符串各个组成部分。</p><p>url模块提供了两套API来处理URL：一个是旧版本遗留的API，一个是实现了WHATWG标准的新API。</p><p>下图中上方是遗留的url.parse()，下方是WHATWG的url对象的属性<br><img src="localhost:4000/images/url.jpg" alt="Image text"></p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之tty</title>
      <link href="/articles/2020-02-07-node-tty.html"/>
      <url>/articles/2020-02-07-node-tty.html</url>
      
        <content type="html"><![CDATA[<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h2><p>终端。</p><p>tty模块提供tty.ReadStream和tty.WriteStream类。<br>大多数情况下，没有必要或可能直接使用此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const tty &#x3D; require(&#39;tty&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>当Nodejs检测到它附加了文本终端TTY时，默认，process.stdin将被初始化为tty.ReadStream的一个示例，process.stdout和process.stderr将被初始化为tty.WriteStream的实例。<br>判断Nodejs是否在TTY上下文中运行的首选方法是检查process.stdout.isTTY属性的值是否为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;</span><br><span class="line">true</span><br><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="tty-ReadStream类"><a href="#tty-ReadStream类" class="headerlink" title="tty.ReadStream类"></a>tty.ReadStream类</h4><p>代表TTY的可读端。<br>正常情况中，processs.stdin将会使Nodejs进程中唯一的tty.ReadStream实例，并且没有理由创建其他的实例。</p><h5 id="readStream-isRaw"><a href="#readStream-isRaw" class="headerlink" title="readStream.isRaw"></a>readStream.isRaw</h5><p>布尔值，如果TTY当前配置为作为原始设备运行，则为true，默认false</p><h5 id="readStream-isTTY"><a href="#readStream-isTTY" class="headerlink" title="readStream.isTTY"></a>readStream.isTTY</h5><p>布尔值，对于tty.readStream实例始终为true。</p><h5 id="readStream-setRawMode-mode"><a href="#readStream-setRawMode-mode" class="headerlink" title="readStream.setRawMode(mode)"></a>readStream.setRawMode(mode)</h5><p>允许配置tty.ReadStream，使其作为原始设备运行。</p><h4 id="tty-WriteStream类"><a href="#tty-WriteStream类" class="headerlink" title="tty.WriteStream类"></a>tty.WriteStream类</h4><p>代表TTY的可写端。<br>在正常情况中，process.stdout和process.stdder将会是为nodejs进程创建的唯一的tty.WriteStream实例，并且没有理由创建其他的实例。</p><h5 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h5><p>只要writeStream.colums或writeStream.rows属性发生更改，就会触发resize事件。<br>调用时，没有参数传递给监听器回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.on(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;屏幕大小已经改变&#39;);</span><br><span class="line">  console.log(&#96;$&#123;process.stdout.columns&#125;x$&#123;process.stdout.rows&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="writeStream-clearLine-dir-callback"><a href="#writeStream-clearLine-dir-callback" class="headerlink" title="writeStream.clearLine(dir[,callback])"></a>writeStream.clearLine(dir[,callback])</h5><p>在dir标识的方向上清除此WriteStream的当前行。</p><h5 id="writeStream-clearScreenDown-callback"><a href="#writeStream-clearScreenDown-callback" class="headerlink" title="writeStream.clearScreenDown([callback])"></a>writeStream.clearScreenDown([callback])</h5><p>从当前光标向下清除此WriteStream。</p><h5 id="writeStream-columns"><a href="#writeStream-columns" class="headerlink" title="writeStream.columns"></a>writeStream.columns</h5><p>一个数字，指定TTY当前具有的列数。每当触发resize事件时，此属性都会更新。</p><h5 id="writeStream-cursorTo-x-y-callback"><a href="#writeStream-cursorTo-x-y-callback" class="headerlink" title="writeStream.cursorTo(x[,y][,callback])"></a>writeStream.cursorTo(x[,y][,callback])</h5><p>将writeStream的光标移动到指定的位置。</p><h5 id="writeStream-getColorDepth-env"><a href="#writeStream-getColorDepth-env" class="headerlink" title="writeStream.getColorDepth([env])"></a>writeStream.getColorDepth([env])</h5><p>使用此函数可检测终端支持的颜色。</p><h5 id="writeStream-getWindowSize"><a href="#writeStream-getWindowSize" class="headerlink" title="writeStream.getWindowSize()"></a>writeStream.getWindowSize()</h5><p>返回此writeStream对应的TTY的大小。</p><h5 id="writeStream-hasColors-count-env"><a href="#writeStream-hasColors-count-env" class="headerlink" title="writeStream.hasColors([count][,env])"></a>writeStream.hasColors([count][,env])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.hasColors();</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 16 种颜色。</span><br><span class="line">process.stdout.hasColors(256);</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 256 种颜色。</span><br><span class="line">process.stdout.hasColors(&#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 true。</span><br><span class="line">process.stdout.hasColors(2 ** 24, &#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 false (环境设置假设支持 2 ** 8 种颜色)。</span><br></pre></td></tr></table></figure><h5 id="writeStream-isTTY"><a href="#writeStream-isTTY" class="headerlink" title="writeStream.isTTY"></a>writeStream.isTTY</h5><p>布尔值，始终未true。</p><h5 id="writeStream-moveCursor-dx-dy-callback"><a href="#writeStream-moveCursor-dx-dy-callback" class="headerlink" title="writeStream.moveCursor(dx, dy[, callback])"></a>writeStream.moveCursor(dx, dy[, callback])</h5><p>将writeStream的光标相当于其当前位置移动。</p><h5 id="writeStream-rows"><a href="#writeStream-rows" class="headerlink" title="writeStream.rows"></a>writeStream.rows</h5><p>一个数字，指定TTY当前具有的行数。<br>每当触发resize事件时，此属性都会更新。</p><h4 id="tty-isatty-fd"><a href="#tty-isatty-fd" class="headerlink" title="tty.isatty(fd)"></a>tty.isatty(fd)</h4><p>如果给定的fd与TTY相关联，则tty.isatty(fd)返回true，否则返回false，包括fd不是非负整数时。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之trace_events</title>
      <link href="/articles/2020-02-07-node-trace-events.html"/>
      <url>/articles/2020-02-07-node-trace-events.html</url>
      
        <content type="html"><![CDATA[<h2 id="trace-events"><a href="#trace-events" class="headerlink" title="trace_events"></a>trace_events</h2><p>跟踪事件。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const trace_events &#x3D; require(&#39;trace_events&#39;);</span><br><span class="line">const t1 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node&#39;, &#39;v8&#39;] &#125;);</span><br><span class="line">const t2 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node.perf&#39;, &#39;node&#39;] &#125;);</span><br><span class="line">t1.enable();</span><br><span class="line">t2.enable();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,node.perf,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br><span class="line"></span><br><span class="line">t2.disable(); &#x2F;&#x2F; Will only disable emission of the &#39;node.perf&#39; category</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node-tls</title>
      <link href="/articles/2020-02-07-node-tls.html"/>
      <url>/articles/2020-02-07-node-tls.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之timer</title>
      <link href="/articles/2020-02-06-node-timer.html"/>
      <url>/articles/2020-02-06-node-timer.html</url>
      
        <content type="html"><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>定时器。</p><p>timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。<br>因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。</p><p>Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。</p><a id="more"></a><h4 id="Immediate类"><a href="#Immediate类" class="headerlink" title="Immediate类"></a>Immediate类</h4><p>此对象在内部创建，并从setImmediate()返回。可以传给clearImmediate()以取消计划的操作。</p><p>默认，当预定immediate时，只要immediate激活，Nodejs事件循环将继续运行。<br>setImmediate()返回的Immediate对象导出immediate.ref()和immediate.unref()函数，这些函数可用于控制此默认行为。</p><h5 id="immediate-hasRef"><a href="#immediate-hasRef" class="headerlink" title="immediate.hasRef()"></a>immediate.hasRef()</h5><p>如果未true，则Immediate对象将会使Nodejs事件循环保持活动状态。</p><h5 id="immediate-ref"><a href="#immediate-ref" class="headerlink" title="immediate.ref()"></a>immediate.ref()</h5><p>调用时，只要immediate处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用immediate.ref()将无效。</p><p>默认，所有Immediate对象都是ref的，通常不需要调用Immediate.ref()，除非之前调用了Immediate.unref()</p><h5 id="immediate-unref"><a href="#immediate-unref" class="headerlink" title="immediate.unref()"></a>immediate.unref()</h5><p>调用时，活动的Immediate对象不需要Nodejs事件循环保持活动状态。如果没有其他活动保持事件循环运行，<br>则进程可以在调用Immediate对象的回调之前推出。多次调用Immediate.unref()将无效。</p><h4 id="Timeout类"><a href="#Timeout类" class="headerlink" title="Timeout类"></a>Timeout类</h4><p>此对象在内部创建，并从setTimeout()和setInterval()返回。<br>它可以传给clearTimeout()或clearInterval()以取消计划的操作。</p><p>默认情况，当使用setTimeout()或setInterval()预定定时器时，只要定时器处于活动状态，<br>Nodejs事件循环将继续运行。这些函数返回的每个Timeout对象都会导出timeout.ref()和timeout.unref()函数，<br>这些函数可用于控制此默认行为。</p><h5 id="timeout-hasRef"><a href="#timeout-hasRef" class="headerlink" title="timeout.hasRef()"></a>timeout.hasRef()</h5><p>如果为true，则timeout对象将会使Nodejs事件循环保持活动状态。</p><h5 id="timeout-ref"><a href="#timeout-ref" class="headerlink" title="timeout.ref()"></a>timeout.ref()</h5><p>调用时，只要timeout处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用timeout.ref()将无效。</p><p>默认，所有Timeout对象都是ref的，通常不需要调用timeout.ref()，除非之前调用了timeout.unref()</p><h5 id="timeout-refresh"><a href="#timeout-refresh" class="headerlink" title="timeout.refresh()"></a>timeout.refresh()</h5><p>将定时器的开始时间设置为当前时间，并重新安排定时器以在之前指定的持续时间内调用其回调，<br>并将其调整为当前时间，这对于在不分配新JavaScript对象的情况下刷新定时器非常有用。</p><h5 id="timeout-unref"><a href="#timeout-unref" class="headerlink" title="timeout.unref()"></a>timeout.unref()</h5><p>调用时，活动的Timeout对象不需要Nodejs事件循环保持活动状态。<br>如果没有其他活动保持事件循环运行，则进程可以在调用Timeout对象的回调之前退出。<br>多次调用timeout.unref()将无效。</p><p>调用timeout.unref()会创建一个内部定时器，它将唤醒Nodejs事件循环。<br>创建太多这些定时器可能会对Nodejs应用程序的性能产生负面影响。</p><h4 id="预定定时器"><a href="#预定定时器" class="headerlink" title="预定定时器"></a>预定定时器</h4><h5 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h5><p>预定在I/O事件的回调之后立即执行的callback。</p><p>当多次调用setImmediate()时，callback函数将按照创建它们的顺序排队等待执行。<br>每次事件循环迭代都会处理整个回调队列。<br>如果立即定时器是从正在执行的回调排入队列，则直到下一次事件循环迭代才会触发。</p><p>如果callback不是函数，则抛出TypeError</p><h5 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h5><p>预定每隔delay毫秒重复执行callback。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h5 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h5><p>预定在delay毫秒之后执行一次性的callback。</p><p>可能不会精确的在delay毫秒时调用callback。<br>Nodejs不保证回调被触发的确切时间，也不保证他们的顺序。<br>回调会在尽可能接近指定的时间调用。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h4 id="取消定时器"><a href="#取消定时器" class="headerlink" title="取消定时器"></a>取消定时器</h4><p>setImmediate()/setInterval()/setTimeout()方法各自返回表示预定的定时器的对象。<br>它们可用于取消定时器并防止其触发。</p><p>无法取消使用setImmediate()/setTimeout()的Promise化的变体创建的定时器。</p><h5 id="clearImmediate-immediate"><a href="#clearImmediate-immediate" class="headerlink" title="clearImmediate(immediate)"></a>clearImmediate(immediate)</h5><p>取消由setImmediate()创建的Immediate对象。</p><h5 id="clearInterval-timeout"><a href="#clearInterval-timeout" class="headerlink" title="clearInterval(timeout)"></a>clearInterval(timeout)</h5><p>取消由setInterval()创建的Timeout对象。</p><h5 id="clearTimeout-timeout"><a href="#clearTimeout-timeout" class="headerlink" title="clearTimeout(timeout)"></a>clearTimeout(timeout)</h5><p>取消由setTimeout()创建的Timeout对象。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之string_decoder</title>
      <link href="/articles/2020-02-06-node-string-decoder.html"/>
      <url>/articles/2020-02-06-node-string-decoder.html</url>
      
        <content type="html"><![CDATA[<h2 id="string-decoder"><a href="#string-decoder" class="headerlink" title="string_decoder"></a>string_decoder</h2><p>字符串解码器。</p><p>提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);</span><br><span class="line">const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);</span><br><span class="line"></span><br><span class="line">const cent &#x3D; Buffer.from([0xC2, 0xA2]);</span><br><span class="line">console.log(decoder.write(cent));</span><br><span class="line"></span><br><span class="line">const euro &#x3D; Buffer.from([0xE2, 0x82, 0xAC]);</span><br><span class="line">console.log(decoder.write(euro));</span><br></pre></td></tr></table></figure><p>将Buffer实例写入StringDecoder实例时，将使用内部缓冲区来确保已解码的字符串不包含任何不完整的多字节字符。它们保存在缓冲区中，直到下一次调用stringDecoder.write()或调用stringDecoder.end()为止。</p><h4 id="StringDecoder类"><a href="#StringDecoder类" class="headerlink" title="StringDecoder类"></a>StringDecoder类</h4><h5 id="new-StringDecoder-encoding"><a href="#new-StringDecoder-encoding" class="headerlink" title="new StringDecoder([encoding])"></a>new StringDecoder([encoding])</h5><p>创建一个新的StringDecoder实例。</p><h5 id="stringDecoder-end-buffer"><a href="#stringDecoder-end-buffer" class="headerlink" title="stringDecoder.end([buffer])"></a>stringDecoder.end([buffer])</h5><p>以字符串形式返回存储在内部缓冲区中的任何剩余输入。 表示不完整的 UTF-8 和 UTF-16 字符的字节将替换为适合字符编码的替换字符。</p><p>如果提供了 buffer 参数，则在返回剩余的输入之前再最后一次调用 stringDecoder.write()</p><h5 id="stringDecoder-write-buffer"><a href="#stringDecoder-write-buffer" class="headerlink" title="stringDecoder.write(buffer)"></a>stringDecoder.write(buffer)</h5><p>返回一个已解码的字符串，确保在返回的字符串不包含 Buffer、 TypedArray 或 DataView 末尾的任何不完整的多字节字符，并将其存储在内部缓冲区中，以便下次调用 stringDecoder.write() 或 stringDecoder.end()。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之stream</title>
      <link href="/articles/2020-02-06-node-stream.html"/>
      <url>/articles/2020-02-06-node-stream.html</url>
      
        <content type="html"><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之repl</title>
      <link href="/articles/2020-02-06-node-repl.html"/>
      <url>/articles/2020-02-06-node-repl.html</url>
      
        <content type="html"><![CDATA[<h2 id="repl"><a href="#repl" class="headerlink" title="repl"></a>repl</h2><p>交互式解释器</p><p>repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="设计与特性"><a href="#设计与特性" class="headerlink" title="设计与特性"></a>设计与特性</h4><p>repl模块导出了repl.REPLServer类。当repl.REPLServer实例运行时，它接收用户输入的每一行，根据用户定义的解释函数解释这些输入，然后输出结果。<br>repl.REPLServer实例支持输入的自动补全、精简Emacs风格的行编辑、多行输入、ANSI风格的输出、当前REPL会话状态的保存于恢复、错误校正、以及可定制的解释函数。</p><h4 id="命令与特殊键"><a href="#命令与特殊键" class="headerlink" title="命令与特殊键"></a>命令与特殊键</h4><ul><li>.break - 在输入一个多行表达式的过程中，输入 .break 命令（或按下 <ctrl>-C 组合键）将终止表达式的继续输入。</li><li>.clear - 重置 REPL 的 context 为一个空对象，并清除当前正输入的所有多行表达式。</li><li>.exit - 关闭输入输出流，退出 REPL。</li><li>.help - 显示特定命令的帮助列表。</li><li>.save - 保存当前 REPL 会话到一个文件： &gt; .save ./file/to/save.js</li><li>.load - 读取一个文件到当前 REPL 会话。 &gt; .load ./file/to/load.js</li><li>.editor 进入编辑模式（<ctrl>-D 完成， <ctrl>-C 取消）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; .editor</span><br><span class="line">&#x2F;&#x2F; 进入编辑模式（^D 完成，^C 取消）</span><br><span class="line">function welcome(name) &#123;</span><br><span class="line">  return &#96;你好 $&#123;name&#125;！&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">welcome(&#39;Node.js 用户&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ^D</span><br><span class="line">&#39;你好 Node.js 用户！&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="默认的解释器"><a href="#默认的解释器" class="headerlink" title="默认的解释器"></a>默认的解释器</h4><p>默认情况下，所有repl.REPLServer实例使用了一个解释函数，它可以解释JavaScript表达式、提供对Nodejs内置模块的访问。当repl.REPLServer实例被创建时可以传入一个替换的解释函数，覆盖其默认的功能。</p><h5 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1 + 1</span><br><span class="line">2</span><br><span class="line">&gt; const m &#x3D; 2</span><br><span class="line">undefined</span><br><span class="line">&gt; m + 1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="全局作用域与局部作用域"><a href="#全局作用域与局部作用域" class="headerlink" title="全局作用域与局部作用域"></a>全局作用域与局部作用域</h5><p>默认的解释器提供了获取存在于全局作用域中的任何变量的途径。 可以通过给每个 REPLServer 绑定的 context 对象指定变量，来显式地把变量暴露给 REPL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">repl.start(&#39;&gt; &#39;).context.m &#x3D; msg;</span><br></pre></td></tr></table></figure><p>context 对象的属性表现为 REPL 中的局部变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node repl_test.js</span><br><span class="line">&gt; m</span><br><span class="line">&#39;message&#39;</span><br></pre></td></tr></table></figure><p>默认情况下 context 的属性不是只读的。 要指定只读的全局变量， context 的属性必须使用 Object.defineProperty() 来定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">const r &#x3D; repl.start(&#39;&gt; &#39;);</span><br><span class="line">Object.defineProperty(r.context, &#39;m&#39;, &#123;</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  value: msg</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="访问Nodejs核心模块"><a href="#访问Nodejs核心模块" class="headerlink" title="访问Nodejs核心模块"></a>访问Nodejs核心模块</h5><p>默认的解释器会自动加载被调用的 Node.js 核心模块到 REPL 环境中。 例如，除非被声明为一个全局变量或一个有限范围的变量，否则输入 fs 会被解释为 global.fs = require(‘fs’)。</p><figure class="highlight plain"><figcaption><span>fs.createReadStream('./some/file');```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 全局的未捕获异常</span><br><span class="line">REPL 使用 domain 模块来捕获该 REPL 会话的所有未捕获的异常。</span><br><span class="line"></span><br><span class="line">在 REPL 中对 domain 模块的这种使用具有以下的副作用：</span><br><span class="line"></span><br><span class="line">* 未捕获的异常仅在独立的 REPL 中触发 &#39;uncaughtException&#39; 事件。 在另一个 Node.js 程序的 REPL 中添加此事件的监听器会抛出 ERR_INVALID_REPL_INPUT。</span><br><span class="line"></span><br><span class="line">* 尝试使用 process.setUncaughtExceptionCaptureCallback() 会抛出 ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE 错误。</span><br><span class="line"></span><br><span class="line">作为独立程序：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));</p><p>throw new Error(‘foobar’);<br>// 未捕获的异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当在另一个应用程序中使用时：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));<br>// TypeError [ERR_INVALID_REPL_INPUT]: Listeners for <code>uncaughtException</code><br>// cannot be used in the REPL</p><p>throw new Error(‘foobar’);<br>// 抛出:<br>// Error: foobar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _ 变量的赋值</span><br><span class="line"></span><br><span class="line">默认的解释器会把最近一次解释的表达式的结果赋值给变量 _ （下划线）。 显式地设置 _ 为某个值能禁用该特性。</span><br></pre></td></tr></table></figure><blockquote><p>[ ‘a’, ‘b’, ‘c’ ]<br>[ ‘a’, ‘b’, ‘c’ ]<br>_.length<br>3<br>_ += 1<br>Expression assignment to _ now disabled.<br>4<br>1 + 1<br>2<br>_<br>4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同样， _error 将指向最后一次看到的错误（如果有的话）。 将 _error 显式设置为值将禁用此行为</span><br></pre></td></tr></table></figure><blockquote><p>throw new Error(‘foo’);<br>Error: foo<br>_error.message<br>‘foo’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### await关键词</span><br><span class="line">使用 --experimental-repl-await 命令行选项，将启用对 await 关键字的实验性支持。</span><br></pre></td></tr></table></figure><blockquote><p>await Promise.resolve(123)<br>123<br>await Promise.reject(new Error(‘REPL await’))<br>Error: REPL await<br>    at repl:1:45<br>const timeout = util.promisify(setTimeout);<br>undefined<br>const old = Date.now(); await timeout(1000); console.log(Date.now() - old);<br>1002<br>undefined</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义的解释函数</span><br><span class="line">当创建一个新的 repl.REPLServer 时，可以提供一个自定义的解释函数。 这可以用于实现完全定制化的 REPL 应用。</span><br><span class="line"></span><br><span class="line">以下是 REPL 的一个假设的示例，执行从一种语言到另一种语言的文本转换：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);<br>const { Translator } = require(‘translator’);</p><p>const myTranslator = new Translator(‘en’, ‘fr’);</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, myTranslator.translate(cmd));<br>}</p><p>repl.start({ prompt: ‘&gt; ‘, eval: myEval });</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 可恢复的错误</span><br><span class="line">当用户正在 REPL 中输入时，按下 &lt;enter&gt; 键会把当前行的输入发送到 eval 函数。 为了支持多行输入， eval 函数可以返回一个 repl.Recoverable 实例给提供的回调函数：</span><br></pre></td></tr></table></figure><p>function myEval(cmd, context, filename, callback) {<br>  let result;<br>  try {<br>    result = vm.runInThisContext(cmd);<br>  } catch (e) {<br>    if (isRecoverableError(e)) {<br>      return callback(new repl.Recoverable(e));<br>    }<br>  }<br>  callback(null, result);<br>}</p><p>function isRecoverableError(error) {<br>  if (error.name === ‘SyntaxError’) {<br>    return /^(Unexpected end of input|Unexpected token)/.test(error.message);<br>  }<br>  return false;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义REPL输出</span><br><span class="line">默认情况下，在把输出写入到提供的可写流（默认为 process.stdout）之前，repl.REPLServer 实例会使用 util.inspect() 方法对输出进行格式化。 showProxy 检查选项会默认设置为 true， colors 选项会设置为 true，具体取决于 REPL 的 useColors 选项。</span><br><span class="line"></span><br><span class="line">可以在构造时指定 useColors 布尔值选项，以指示默认的编写器使用 ANSI 样式代码来着色来自 util.inspect() 方法的输出。</span><br><span class="line"></span><br><span class="line">如果 REPL 作为独立程序运行，则还可以使用 inspect.replDefaults 属性从 REPL 内部更改 REPL 的检查默认值util.inspect()，该属性是 util.inspect() 中的 defaultOptions 的镜像。</span><br></pre></td></tr></table></figure><blockquote><p>util.inspect.replDefaults.compact = false;<br>false<br>[1]<br>[<br>  1<br>]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在构造时，通过在 writer 选项传入一个新的函数，可以完全地自定义一个 repl.REPLServer 实例的输出。 例子，把输入的任何文本转换为大写：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>const r = repl.start({ prompt: ‘&gt; ‘, eval: myEval, writer: myWriter });</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, cmd);<br>}</p><p>function myWriter(output) {<br>  return output.toUpperCase();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### REPLServer类</span><br><span class="line">repl.REPLServer 的实例是使用 repl.start() 方法创建的，不能直接地使用 JavaScript 的 new 关键字创建。</span><br><span class="line"></span><br><span class="line">##### exit事件</span><br><span class="line">当接收到 .exit 命令、或按下两次 &lt;ctrl&gt;-C 发出 SIGINT 信号、或按下 &lt;ctrl&gt;-D 发出 &#39;end&#39; 信号而使 REPL 被退出时，触发 &#39;exit&#39; 事件。 监听器的回调函数被调用时不带任何参数。</span><br></pre></td></tr></table></figure><p>replServer.on(‘exit’, () =&gt; {<br>  console.log(‘从 REPL 接收到 “exit” 事件！’);<br>  process.exit();<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### reset事件</span><br><span class="line">当 REPL 的上下文被重置时，触发 &#39;reset&#39; 事件。 每当接收到 .clear 命令时会触发该事件，除非 REPL 正在使用默认的解释器并且 repl.REPLServer 实例被创建时 useGlobal 选项被设为 true。 监听器的回调函数被调用时会带上 context 对象作为惟一的参数。</span><br><span class="line"></span><br><span class="line">这主要被用于重新初始化 REPL 上下文，使之达到某些预定义的状态，如下面的例子：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>function initializeContext(context) {<br>  context.m = ‘test’;<br>}</p><p>const r = repl.start({ prompt: ‘&gt; ‘ });<br>initializeContext(r.context);</p><p>r.on(‘reset’, initializeContext);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当代码被执行时，全局的 &#39;m&#39; 变量可以被修改，但随后的 .clear 命令会把它重置回初始值：</span><br></pre></td></tr></table></figure><p>$ ./node example.js</p><blockquote><p>m<br>‘test’<br>m = 1<br>1<br>m<br>1<br>.clear<br>Clearing context…<br>m<br>‘test’</p></blockquote><p>```</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之readline</title>
      <link href="/articles/2020-02-06-node-readline.html"/>
      <url>/articles/2020-02-06-node-readline.html</url>
      
        <content type="html"><![CDATA[<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>逐行读取。<br>提供了一个接口，用于一次一行的读取可读流中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;);</span><br><span class="line"></span><br><span class="line">const rl &#x3D; readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.question(&#39;你如何看待 Node.js 中文网？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO：将答案记录在数据库中。</span><br><span class="line">  console.log(&#96;感谢您的宝贵意见：$&#123;answer&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  rl.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦调用此代码，Nodejs应用程序将不会终止，直到readline.Interface关闭，<br>因为接口在Input流上等待接收数据。</p><h4 id="Interface类"><a href="#Interface类" class="headerlink" title="Interface类"></a>Interface类</h4><p>readline.Interface类的实例是使用readline.createInterface()方法构造的。<br>每个实例都关联一个input可读流和一个output可写流。<br>output流用于为到达的用户输入打印提示，并从input流读取。</p><h4 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h4><p>当发生以下任一情况时会触发close事件：</p><ul><li>调用rl.close()方法，且readline.Interface实例放弃对input流和output流的控制；</li><li>input流接收到其end事件；</li><li>input流接收到<ctrl>-D以发信号传输结束；</li><li>input流接收到<ctrl>-C以发信号SIGINT，并且readline.Interface实例上没有注册SIGINT事件监听器。<br>调用监听器函数不传入任何参数。</li></ul><p>一旦触发close事件，则readline.Interface实例就完成了。</p><h5 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h5><p>每当input流接收到行尾输入（\n, \r, \r\n）时会触发line事件。</p><h5 id="pause事件"><a href="#pause事件" class="headerlink" title="pause事件"></a>pause事件</h5><p>当发生以下任一情况时会触发pause事件：</p><ul><li>input流被暂停</li><li>input流未暂停，且接收到SIGCONT事件</li></ul><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;pause&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 暂停&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="resume事件"><a href="#resume事件" class="headerlink" title="resume事件"></a>resume事件</h5><p>每当input流恢复时，就会触发resume事件。<br>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;resume&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 恢复&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGCONT事件"><a href="#SIGCONT事件" class="headerlink" title="SIGCONT事件"></a>SIGCONT事件</h5><p>当先前使用<ctrl>-Z移入后台的Nodejs进程使用fg返回到前台时，就会触发SIGCONT事件。<br>如果input流在SIGTSTP请求之前被暂停，则不会触发此事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGCONT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;prompt&#96; 将自动恢复流。</span><br><span class="line">  rl.prompt();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGCONT事件。</p><h5 id="SIGINT事件"><a href="#SIGINT事件" class="headerlink" title="SIGINT事件"></a>SIGINT事件</h5><p>每当input流接收到<ctrl>-C输入时，就会触发SIGINT事件。<br>如果当input流接收到SIGINT时没有注册SIGINT事件监听器，则会触发pause事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  rl.question(&#39;确定要退出吗？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">    if (answer.match(&#x2F;^y(es)?$&#x2F;i)) rl.pause();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGTSTP事件"><a href="#SIGTSTP事件" class="headerlink" title="SIGTSTP事件"></a>SIGTSTP事件</h5><p>每当input流接收到<ctrl>-Z输入时，就会触发SIGTSTP事件。<br>如果当input流接收SIGTSTP时没有注册SIGTSTP事件监听器，则Nodejs进程将被发送到后台。</p><p>当使用fg(1p)恢复程序时，将触发pause和SIGCONT事件，这可用于恢复input流。</p><p>如果在将进程发送到后台之前暂停input，则不会触发pause和SIGCONT事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGTSTP&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这将覆盖 SIGTSTP 并阻止程序进入后台。</span><br><span class="line">  console.log(&#39;捕获 SIGTSTP&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGTSTP事件。</p><h5 id="rl-close"><a href="#rl-close" class="headerlink" title="rl.close()"></a>rl.close()</h5><p>会关闭readline.Interface实例，并放弃对input和output流的控制。<br>当调用时，将触发close事件。</p><p>调用rl.close()不会立即停止readline.Interface实例触发的其他事件。</p><h5 id="rl-pause"><a href="#rl-pause" class="headerlink" title="rl.pause()"></a>rl.pause()</h5><p>会暂停input流，允许稍后在必要时恢复它。<br>调用rl.pause()不会立刻暂停readline.Interfac实例触发的其他事件。</p><h5 id="rl-prompt-preserveCursor"><a href="#rl-prompt-preserveCursor" class="headerlink" title="rl.prompt([preserveCursor])"></a>rl.prompt([preserveCursor])</h5><p>将readline.Interface实例配置的提示写入putput中的新一行，以便为用户提供一个可供输入位置。</p><p>当调用时，如果input流已暂停，则rl.prompt()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入提示。</p><h5 id="rl-question-query-callback"><a href="#rl-question-query-callback" class="headerlink" title="rl.question(query, callback)"></a>rl.question(query, callback)</h5><p>通过将query写入output来显示它，并等待用户在input上提供输入，然后调用callback函数将提供的输入作为第一个参数传入。</p><p>当调用时，如果input流已暂停，则rl.question()将恢复input流。</p><p>如果readline.Interface创建时output将被设置为null或undefined，则不会写入query。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.question(&#39;你最喜欢的食物是什么？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;你最喜欢的食物是 $&#123;answer&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="rl-resume"><a href="#rl-resume" class="headerlink" title="rl.resume()"></a>rl.resume()</h5><p>如果input流已暂停，则rl.resume方法将恢复它。</p><h5 id="rl-setPrompt-prompt"><a href="#rl-setPrompt-prompt" class="headerlink" title="rl.setPrompt(prompt)"></a>rl.setPrompt(prompt)</h5><p>设置每当调用rl.prompt()时将写入output的提示。</p><h5 id="rl-write-data-key"><a href="#rl-write-data-key" class="headerlink" title="rl.write(data[, key])"></a>rl.write(data[, key])</h5><p>将data或key标识的按键序列写入output。<br>仅当output是TTY文本终端时才支持key参数。<br>如果指定了key，则忽略data。<br>当调用时，如果input流已暂停，则rl.write()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入data和key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.write(&#39;删除这个！&#39;);</span><br><span class="line">&#x2F;&#x2F; 模拟 Ctrl+u 删除先前写入的行。</span><br><span class="line">rl.write(null, &#123; ctrl: true, name: &#39;u&#39; &#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之querystring</title>
      <link href="/articles/2020-02-06-node-querystring.html"/>
      <url>/articles/2020-02-06-node-querystring.html</url>
      
        <content type="html"><![CDATA[<h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><p>查询字符串。<br>querystring模块提供用于解析和格式化URL查询字符串的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const querystring &#x3D; require(&#39;querystring&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="querystring-decode"><a href="#querystring-decode" class="headerlink" title="querystring.decode()"></a>querystring.decode()</h4><p>是querystring.parse()的别名。</p><h4 id="querystring-encode"><a href="#querystring-encode" class="headerlink" title="querystring.encode()"></a>querystring.encode()</h4><p>是querystring.stringify()的别名。</p><h4 id="querystring-escape-str"><a href="#querystring-escape-str" class="headerlink" title="querystring.escape(str)"></a>querystring.escape(str)</h4><p>以对URL查询字符串的特定要求进行了优化的方式对给定的str执行URL百分比编码。</p><h4 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[,sep[,eq[, options]]])"></a>querystring.parse(str[,sep[,eq[, options]]])</h4><p>将URL查询字符串str解析为键值对的集合。</p><h4 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[,sep[,eq[, options]]])"></a>querystring.stringify(obj[,sep[,eq[, options]]])</h4><p>通过迭代对象的自身属性从给定的obj生成URL查询字符串。</p><h4 id="querystring-unescape-str"><a href="#querystring-unescape-str" class="headerlink" title="querystring.unescape(str)"></a>querystring.unescape(str)</h4><p>在给定的str上执行URL百分比编码字符的解码。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之process</title>
      <link href="/articles/2020-02-06-node-process.html"/>
      <url>/articles/2020-02-06-node-process.html</url>
      
        <content type="html"><![CDATA[<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>进程。<br>process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。<br>作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const process &#x3D; require(&#39;process&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h4><p>process对象是EventEmitter的实例。</p><h5 id="beforeExit事件"><a href="#beforeExit事件" class="headerlink" title="beforeExit事件"></a>beforeExit事件</h5><p>当Nodejs清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。<br>通常，Nodejs进程将在没有调度工作时退出，但在beforeExit事件上注册的监听器可以进行异步调用，从而导致Nodejs进程继续。</p><p>调用监听器回调函数时会将process.exitCode的值作为唯一参数传入。</p><p>对于导致显示终止的条件，不会触发beforeExit事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;beforeExit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 beforeExit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 exit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;此消息最新显示&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印:</span><br><span class="line">&#x2F;&#x2F; 此消息最新显示</span><br><span class="line">&#x2F;&#x2F; 进程 beforeExit 事件的代码: 0</span><br><span class="line">&#x2F;&#x2F; 进程 exit 事件的代码: 0</span><br></pre></td></tr></table></figure><h5 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h5><p>如果使用IPC通道衍生Nodejs进程，则在IPC通道关闭时将触发disconnect事件。</p><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><p>当Nodejs进程因以下原因之一即将退出时，则会触发exit事件：</p><ul><li>显示调用process.exit()方法</li><li>Nodejs事件循环不再需要执行任何其他工作<br>此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，nodejs进程将终止。</li></ul><p>用process.exitCode属性指定的退出码或传给process.exit()方法的exitCode参数调用监听器回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;退出码: $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>监听器函数必须只执行同步操作。<br>在调用exit事件监听器之后，Nodejs进程将立即退出，从而导致在事件循环中仍排队的任何其他工作被放弃。</p><h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><p>如果使用IPC通道衍生Nodejs进程，则只要子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件。</p><p>消息会进行序列化和解析。生成的消息可能与最初发送的消息不同。</p><h5 id="multipleResolves事件"><a href="#multipleResolves事件" class="headerlink" title="multipleResolves事件"></a>multipleResolves事件</h5><p>只要Promise有以下情况，将会触发multipleResolves事件：</p><ul><li>解决不止一次</li><li>拒绝不止一次</li><li>解决后拒绝</li><li>拒绝后解决</li></ul><h5 id="rejectionHandled事件"><a href="#rejectionHandled事件" class="headerlink" title="rejectionHandled事件"></a>rejectionHandled事件</h5><p>每当Promise被拒绝且错误处理函数附加到它晚于一个Nodejs事件循环时，就会触发rejectHandled事件。</p><p>Promise对象之前已经在unhandledRejection事件中触发，但在处理过程中获得了拒绝处理函数。</p><p>Promise链中没有顶层的概念，总是可以处理拒绝。本质上自身是异步的，可以在未来的某个时间点处理Promise拒绝，可能比触发unhandledRejection事件所需的事件循环更晚。</p><p>在同步代码中，当未处理的异常列表增长时，会触发uncaughtexption事件。<br>在异步代码中，当未处理的异常列表增长时，会触发unhandledRejection事件，并且当未处理的拒绝列表缩小时会触发rejectionHandled事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const unhandledRejections &#x3D; new Map();</span><br><span class="line">process.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.set(promise, reason);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&#39;rejectionHandled&#39;, (promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.delete(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="uncaughtException事件"><a href="#uncaughtException事件" class="headerlink" title="uncaughtException事件"></a>uncaughtException事件</h5><p>当未捕获的JavaScript异常一直冒泡回到事件循环时，会触发uncaughtExpection事件。</p><h5 id="unhandledRejection事件"><a href="#unhandledRejection事件" class="headerlink" title="unhandledRejection事件"></a>unhandledRejection事件</h5><p>如果在事件循环的一次轮询中，一个Promise被拒绝，并且此Promise没有绑定错误处理器，unhandledRejection事件会被触发。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之perf_hooks</title>
      <link href="/articles/2020-02-06-node-perf-hooks.html"/>
      <url>/articles/2020-02-06-node-perf-hooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="perf-hooks"><a href="#perf-hooks" class="headerlink" title="perf_hooks"></a>perf_hooks</h2><p>性能钩子。</p><p>性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; PerformanceObserver, performance &#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((items) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(items.getEntries()[0].duration);</span><br><span class="line">  performance.clearMarks();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;measure&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;A&#39;);</span><br><span class="line">doSomeLongRunningProcess(() &#x3D;&gt; &#123;</span><br><span class="line">  performance.mark(&#39;B&#39;);</span><br><span class="line">  performance.measure(&#39;A to B&#39;, &#39;A&#39;, &#39;B&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Performance类"><a href="#Performance类" class="headerlink" title="Performance类"></a>Performance类</h4><h5 id="performance-clearMarks-name"><a href="#performance-clearMarks-name" class="headerlink" title="performance.clearMarks([name])"></a>performance.clearMarks([name])</h5><h5 id="performance-mark-name"><a href="#performance-mark-name" class="headerlink" title="performance.mark([name])"></a>performance.mark([name])</h5><p>创建一个新的PerformanceMark实体。</p><h5 id="performance-measure-name-startMark-endMark"><a href="#performance-measure-name-startMark-endMark" class="headerlink" title="performance.measure(name, startMark, endMark)"></a>performance.measure(name, startMark, endMark)</h5><h5 id="performance-nodeTiming"><a href="#performance-nodeTiming" class="headerlink" title="performance.nodeTiming"></a>performance.nodeTiming</h5><h5 id="performance-now"><a href="#performance-now" class="headerlink" title="performance.now()"></a>performance.now()</h5><h5 id="performance-timeOrigin"><a href="#performance-timeOrigin" class="headerlink" title="performance.timeOrigin"></a>performance.timeOrigin</h5><h5 id="performance-timerify-fn"><a href="#performance-timerify-fn" class="headerlink" title="performance.timerify(fn)"></a>performance.timerify(fn)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">function someFunction() &#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped &#x3D; performance.timerify(someFunction);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries()[0].duration);</span><br><span class="line">  obs.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;function&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A performance timeline entry will be created</span><br><span class="line">wrapped();</span><br></pre></td></tr></table></figure><h4 id="PerformanceEntry类"><a href="#PerformanceEntry类" class="headerlink" title="PerformanceEntry类"></a>PerformanceEntry类</h4><h5 id="performanceEntry-duration"><a href="#performanceEntry-duration" class="headerlink" title="performanceEntry.duration"></a>performanceEntry.duration</h5><h5 id="performanceEntry-name"><a href="#performanceEntry-name" class="headerlink" title="performanceEntry.name"></a>performanceEntry.name</h5><h5 id="performanceEntry-startTime"><a href="#performanceEntry-startTime" class="headerlink" title="performanceEntry.startTime"></a>performanceEntry.startTime</h5><h5 id="performanceEntry-entryType"><a href="#performanceEntry-entryType" class="headerlink" title="performanceEntry.entryType"></a>performanceEntry.entryType</h5><h5 id="performanceEntry-kind"><a href="#performanceEntry-kind" class="headerlink" title="performanceEntry.kind"></a>performanceEntry.kind</h5><h4 id="PerformanceObserver类"><a href="#PerformanceObserver类" class="headerlink" title="PerformanceObserver类"></a>PerformanceObserver类</h4><h5 id="new-PerformanceObserver-callback"><a href="#new-PerformanceObserver-callback" class="headerlink" title="new PerformanceObserver(callback)"></a>new PerformanceObserver(callback)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries());</span><br><span class="line">  observer.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;test&#39;);</span><br></pre></td></tr></table></figure><h5 id="performanceObserver-disconnect"><a href="#performanceObserver-disconnect" class="headerlink" title="performanceObserver.disconnect()"></a>performanceObserver.disconnect()</h5><h5 id="performanceObserver-observe-options"><a href="#performanceObserver-observe-options" class="headerlink" title="performanceObserver.observe(options)"></a>performanceObserver.observe(options)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called three times synchronously. &#96;list&#96; contains one item.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buffered是false的时候，callback会在每次PerformanceEntry的时候回调。</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called once. &#96;list&#96; contains three items.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br></pre></td></tr></table></figure><h5 id="PerformanceObserverEntryList类"><a href="#PerformanceObserverEntryList类" class="headerlink" title="PerformanceObserverEntryList类"></a>PerformanceObserverEntryList类</h5><h5 id="performanceObserverEntryList-getEntries"><a href="#performanceObserverEntryList-getEntries" class="headerlink" title="performanceObserverEntryList.getEntries()"></a>performanceObserverEntryList.getEntries()</h5><h5 id="performanceObserverEntryList-getEntriesByName-name-type"><a href="#performanceObserverEntryList-getEntriesByName-name-type" class="headerlink" title="performanceObserverEntryList.getEntriesByName(name[,type])"></a>performanceObserverEntryList.getEntriesByName(name[,type])</h5><h4 id="Histogram类"><a href="#Histogram类" class="headerlink" title="Histogram类"></a>Histogram类</h4><h5 id="histogram-disable"><a href="#histogram-disable" class="headerlink" title="histogram.disable()"></a>histogram.disable()</h5><h5 id="histogram-enable"><a href="#histogram-enable" class="headerlink" title="histogram.enable()"></a>histogram.enable()</h5><h5 id="histogram-exceeds"><a href="#histogram-exceeds" class="headerlink" title="histogram.exceeds"></a>histogram.exceeds</h5><h5 id="histogram-max"><a href="#histogram-max" class="headerlink" title="histogram.max"></a>histogram.max</h5><h5 id="histogram-mean"><a href="#histogram-mean" class="headerlink" title="histogram.mean"></a>histogram.mean</h5><h5 id="histogram-min"><a href="#histogram-min" class="headerlink" title="histogram.min"></a>histogram.min</h5><h5 id="histogram-reset"><a href="#histogram-reset" class="headerlink" title="histogram.reset()"></a>histogram.reset()</h5>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之path</title>
      <link href="/articles/2020-02-06-node-path.html"/>
      <url>/articles/2020-02-06-node-path.html</url>
      
        <content type="html"><![CDATA[<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>路径。<br>path模块提供用于处理文件路径和目录路径的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h4><p>返回path的目录名。</p><h4 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h4><p>返回path的扩展名。</p><h4 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h4><p>从对象返回路径字符串。</p><h4 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h4><p>检测path是否为绝对路径。</p><h4 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h4><p>使用平台特定的分隔符作为定界符将所有给定的path片段连接在一起，然后规范化生成的路径。</p><h4 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h4><p>规范化给定的path，解析’..’和’.’片段。</p><h4 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h4><p>返回一个对象，其属性表示path的重要元素。尾部的目录分隔符将被忽略。</p><h4 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h4><p>根据当前工作目录返回from到to的相对路径。<br>如果from和to各自解析到相同的路径，则返回零长度的字符串。</p><h4 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h4><p>将路径或路径片段的序列解析为绝对路径。</p><h4 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h4><p>提供pingt特定的路径片段分隔符。</p><h4 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h4><p>提供对特定于Windows的path方法的实现的访问。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之os</title>
      <link href="/articles/2020-02-06-node-os.html"/>
      <url>/articles/2020-02-06-node-os.html</url>
      
        <content type="html"><![CDATA[<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>操作系统。</p><p>os模块提供了与操作系统相关的实用方法和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const os &#x3D; require(&#39;os&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="os-EOL"><a href="#os-EOL" class="headerlink" title="os.EOL"></a>os.EOL</h4><p>操作系统特定的行末标志。</p><ul><li>在POSIX上是\n</li><li>在Windows上是\r\n</li></ul><h4 id="os-constants"><a href="#os-constants" class="headerlink" title="os.constants"></a>os.constants</h4><p>包含错误码、进程信号等常用的操作系统特定的常量。<br>定义的特定常量在os常量中定义。</p><h4 id="os-cpus"><a href="#os-cpus" class="headerlink" title="os.cpus()"></a>os.cpus()</h4><p>返回一个对象数组，其中包含有关每个逻辑CPU内核的信息。</p><h4 id="os-endianness"><a href="#os-endianness" class="headerlink" title="os.endianness()"></a>os.endianness()</h4><p>返回一个字符串，该字符串标识为其编译Nodejs二进制文件的CPU的字节序。<br>可能的值有，BE用于大端字节序，LE用于小端字节序。</p><h4 id="os-freemem"><a href="#os-freemem" class="headerlink" title="os.freemem()"></a>os.freemem()</h4><p>以整数的形式返回空闲的系统内存量。</p><h4 id="os-getPriority-pid"><a href="#os-getPriority-pid" class="headerlink" title="os.getPriority([pid])"></a>os.getPriority([pid])</h4><p>返回由pid指定的进程的调度优先级。如果未提供pid或为0，则返回当前进程的优先级。</p><h4 id="os-homedir"><a href="#os-homedir" class="headerlink" title="os.homedir()"></a>os.homedir()</h4><p>返回当前用户的主目录的字符串路径。</p><h4 id="os-hostname"><a href="#os-hostname" class="headerlink" title="os.hostname()"></a>os.hostname()</h4><p>以字符串的形式返回操作系统的主机名。</p><h4 id="os-platform"><a href="#os-platform" class="headerlink" title="os.platform()"></a>os.platform()</h4><p>返回标识操作系统平台的字符串。</p><h4 id="os-release"><a href="#os-release" class="headerlink" title="os.release()"></a>os.release()</h4><p>以字符串的形式返回操作系统。</p><h4 id="os-tmpdir"><a href="#os-tmpdir" class="headerlink" title="os.tmpdir()"></a>os.tmpdir()</h4><p>以字符串的形式返回操作系统的默认临时文件目录。</p><h4 id="os-totalmem"><a href="#os-totalmem" class="headerlink" title="os.totalmem()"></a>os.totalmem()</h4><p>以整数的形式返回系统的内存总量。</p><h4 id="os-type"><a href="#os-type" class="headerlink" title="os.type()"></a>os.type()</h4><p>返回与uname(3)返回一样的操作系统名字。</p><h4 id="os-uptime"><a href="#os-uptime" class="headerlink" title="os.uptime()"></a>os.uptime()</h4><p>返回系统的正常运行时间</p><h4 id="os-userInfo-options"><a href="#os-userInfo-options" class="headerlink" title="os.userInfo([options])"></a>os.userInfo([options])</h4><p>返回关于当前有效的用户信息。</p><h4 id="os常量"><a href="#os常量" class="headerlink" title="os常量"></a>os常量</h4><p>并不是所有的常量在每一个操作系统上都是可用的。<br>下面的常量被os.constants所输出。</p><h5 id="信号常量"><a href="#信号常量" class="headerlink" title="信号常量"></a>信号常量</h5><p>os.constants.signals</p><h5 id="错误常量"><a href="#错误常量" class="headerlink" title="错误常量"></a>错误常量</h5><p>os.constants.errno</p><h5 id="POSIX错误常量"><a href="#POSIX错误常量" class="headerlink" title="POSIX错误常量"></a>POSIX错误常量</h5><h5 id="Windows系统特有的错误常量"><a href="#Windows系统特有的错误常量" class="headerlink" title="Windows系统特有的错误常量"></a>Windows系统特有的错误常量</h5><h5 id="dlopen常量"><a href="#dlopen常量" class="headerlink" title="dlopen常量"></a>dlopen常量</h5><h5 id="优先级常量"><a href="#优先级常量" class="headerlink" title="优先级常量"></a>优先级常量</h5><h5 id="libuv常量"><a href="#libuv常量" class="headerlink" title="libuv常量"></a>libuv常量</h5>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之net</title>
      <link href="/articles/2020-02-05-node-net.html"/>
      <url>/articles/2020-02-05-node-net.html</url>
      
        <content type="html"><![CDATA[<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络。</p><p>net模块用于创建基于流的TCP或IPC的服务器与客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const net &#x3D; require(&#39;net&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="IPC支持"><a href="#IPC支持" class="headerlink" title="IPC支持"></a>IPC支持</h4><p>net模块在windows上支持命名管道IPC，在其他操作系统上支持Unix域套接字。</p><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><p>此类用于创建TCP或IPC服务器。</p><h5 id="new-net-Server-options-connectionListener"><a href="#new-net-Server-options-connectionListener" class="headerlink" title="new net.Server([options][,connectionListener])"></a>new net.Server([options][,connectionListener])</h5><p>net.Server是一个EventEmitter，实现了以下事件：</p><ul><li><p>close事件<br>  当Server关闭的时候触发，如果有连接存在，直到所有的连接结束才会触发这个事件。</p></li><li><p>connection事件<br>  当一个新的连接建立的时候触发。socket是一个net.Socket实例。</p></li><li><p>error事件<br>  当错误出现的时候触发。</p></li><li><p>listening事件<br>  当调用server.listen()绑定服务器之后触发。</p></li></ul><h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><p>如果在IP socket上监听，则返回操作系统报告的绑定的address、地址family名称、以及服务器port（<br>用于查找在获取操作系统分配的地址时分配的端口）：<code>{port:12346, family:&#39;IPv4&#39;, address:&#39;127.0.0.1&#39;}</code></p><p>对于在管道或Unix域套接字上监听的server，该名称返回为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; net.createServer((socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.end(&#39;再见\n&#39;);</span><br><span class="line">&#125;).on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取任意未使用的端口。</span><br><span class="line">server.listen(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;打开服务器&#39;, server.address());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不要在listening事件触发之前调用server.address()</p><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><p>组织server接受新的连接并保持现有的连接。<br>该函数是异步的，server将在所有连接结束后关闭并触发close事件。<br>可选的callback将在close事件发生时被调用。</p><h5 id="server-getConnections-callback"><a href="#server-getConnections-callback" class="headerlink" title="server.getConnections(callback)"></a>server.getConnections(callback)</h5><p>异步获取服务器的当前并发连接数。当socket被传递给子进程时工作。<br>回调函数的两个参数是err和count。</p><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><p>启动一个服务器来监听连接。</p><h5 id="server-listening"><a href="#server-listening" class="headerlink" title="server.listening"></a>server.listening</h5><p>表明server是否正在监听连接。</p><h5 id="server-maxConnections"><a href="#server-maxConnections" class="headerlink" title="server.maxConnections"></a>server.maxConnections</h5><p>该属性使得server连接数过多时拒绝连接。</p><h5 id="server-ref"><a href="#server-ref" class="headerlink" title="server.ref()"></a>server.ref()</h5><p>与unref()相反，在一个已经调用unref的server中调用ref，如果server是仅存的server，<br>则程序不会退出。对一个已经调用ref的server再次调用ref()将不会再有效果。</p><h5 id="server-unref"><a href="#server-unref" class="headerlink" title="server.unref()"></a>server.unref()</h5><p>如果这个server在事件系统中是唯一有效的，那么对server调用unref()将允许程序退出。<br>如果这个server已经调用过unref那么再次调用unref()将不会再有效果。</p><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><p>net.Socket可以由用户创建并且直接与服务器进行交互。<br>也可以由Nodejs创建，并在收到连接时传给用户。</p><h5 id="new-net-Socket-options"><a href="#new-net-Socket-options" class="headerlink" title="new net.Socket([options])"></a>new net.Socket([options])</h5><p>创建一个socket对象。</p><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><p>一旦socket完全关闭就发出该事件。</p><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><p>当一个socket连接成功建立的时候触发该事件。</p><h5 id="data事件"><a href="#data事件" class="headerlink" title="data事件"></a>data事件</h5><p>当接收到数据的时候触发该事件。<br>data参数是一个Buffer或String<br>当Socket触发data事件的时候，如果没有监听器则数据将会丢失。</p><h5 id="drain事件"><a href="#drain事件" class="headerlink" title="drain事件"></a>drain事件</h5><p>当写入缓冲区变为空时触发。可以用来做上传节流。</p><h5 id="end事件"><a href="#end事件" class="headerlink" title="end事件"></a>end事件</h5><p>当socket的另一端发送一个FIN包的时候触发，从而结束socket的可读流。</p><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><p>当错误发生时触发。close事件也会紧接着该事件被触发。</p><h5 id="lookup事件"><a href="#lookup事件" class="headerlink" title="lookup事件"></a>lookup事件</h5><p>当找到主机之后创建连接之前触发。</p><h5 id="ready事件"><a href="#ready事件" class="headerlink" title="ready事件"></a>ready事件</h5><p>套接字准备好使用时触发。<br>connect后立即触发。</p><h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><p>当socket超时的时候触发。</p><h5 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect()"></a>socket.connect()</h5><h5 id="socket-connecting"><a href="#socket-connecting" class="headerlink" title="socket.connecting()"></a>socket.connecting()</h5><h5 id="socket-destrory-exception"><a href="#socket-destrory-exception" class="headerlink" title="socket.destrory([exception])"></a>socket.destrory([exception])</h5><h5 id="socket-destroyed"><a href="#socket-destroyed" class="headerlink" title="socket.destroyed"></a>socket.destroyed</h5><p>指示连接是否已经被销毁。<br>一旦连接被销毁就不能再使用它传输任何数据。</p><h5 id="socket-end-data-encoding-callback"><a href="#socket-end-data-encoding-callback" class="headerlink" title="socket.end([data[,encoding]][, callback])"></a>socket.end([data[,encoding]][, callback])</h5><p>半关闭socket。</p><h4 id="net-isIP-input"><a href="#net-isIP-input" class="headerlink" title="net.isIP(input)"></a>net.isIP(input)</h4><p>测试输入是否是IP地址。<br>无效的字符串则返回0<br>IPv4地址则返回4<br>IPv6的地址则返回6</p><h4 id="net-isIPv4-input"><a href="#net-isIPv4-input" class="headerlink" title="net.isIPv4(input)"></a>net.isIPv4(input)</h4><p>如果输入是IPv4地址返回true，否则返回false</p><h4 id="net-isIPv6-input"><a href="#net-isIPv6-input" class="headerlink" title="net.isIPv6(input)"></a>net.isIPv6(input)</h4><p>如果输入是IPv6地址返回true，否则返回false</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之module</title>
      <link href="/articles/2020-02-05-node-module.html"/>
      <url>/articles/2020-02-05-node-module.html</url>
      
        <content type="html"><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>模块。</p><p>在Nodejs模块系统中，每个文件都被视为一个独立的模块。</p><a id="more"></a><h4 id="访问主模块"><a href="#访问主模块" class="headerlink" title="访问主模块"></a>访问主模块</h4><p>当Nodejs直接运行一个文件时mrequire.main会被视为module。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>模块在第一次加载后会被缓存。<br>每次调用相同的模块都解析到同一个文件，则返回相同的对象。</p><h5 id="模块缓存的注意事项"><a href="#模块缓存的注意事项" class="headerlink" title="模块缓存的注意事项"></a>模块缓存的注意事项</h5><p>模块是基于其解析的文件名进行缓存的。由于调用模块的位置不同，模块可能被解析成不同的<br>文件名，这样就不能保证总能返回完全相同的对象。</p><p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，<br>但缓存仍然会将它们视为不同的模块，并多次重新加载。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>核心模块定义在Nodejs原代码的lib/目录下。<br>require()总是会优先加载核心模块。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当循环调用require()时，一个模块可能在未完成执行时被返回。</p><h4 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h4><p>提供一个单一的入口来指向它。</p><h4 id="从node-modules目录加载"><a href="#从node-modules目录加载" class="headerlink" title="从node_modules目录加载"></a>从node_modules目录加载</h4><h4 id="从全局目录加载"><a href="#从全局目录加载" class="headerlink" title="从全局目录加载"></a>从全局目录加载</h4><h4 id="模块封装器"><a href="#模块封装器" class="headerlink" title="模块封装器"></a>模块封装器</h4><p>在指向模块代码之前，Nodejs会使用一个如下的函数封装器将其封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">&#x2F;&#x2F; 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这样做，Nodejs实现了以下几点：</p><ul><li>它保持了顶层的变量（用var、const或let定义）作用在模块范围内，而不是全局对象；</li><li>它有助于提高一些看似全局但实际是模块特定的变量；</li></ul><h4 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h4><h5 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h5><p>当前模块的目录名。</p><h5 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h5><p>当前模块的文件名。</p><h5 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h5><h5 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h5><p>对当前模块的引用。</p><h5 id="require-id"><a href="#require-id" class="headerlink" title="require(id)"></a>require(id)</h5><h5 id="require-cache"><a href="#require-cache" class="headerlink" title="require.cache"></a>require.cache</h5><p>被引入的模块江北诶缓存在这个对象中，从此对象中删除键值对将会导致下一次require重新加载<br>被删除的模块。这不适用原生插件，因为它们的重载将会导致错误。</p><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>module的自由变量是对表示当前模块的对象的引用。</p><h5 id="module-children"><a href="#module-children" class="headerlink" title="module.children"></a>module.children</h5><p>被该模块引用的模块对象。</p><h5 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h5><p>module.exports对象由Module系统创建。</p><h5 id="exports快捷方式"><a href="#exports快捷方式" class="headerlink" title="exports快捷方式"></a>exports快捷方式</h5><p>exports变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给module。exports。</p><h5 id="module-filename"><a href="#module-filename" class="headerlink" title="module.filename"></a>module.filename</h5><p>模块的完全解析后的文件名。</p><h5 id="module-id"><a href="#module-id" class="headerlink" title="module.id"></a>module.id</h5><p>模块的标识符。通常是完全解析后的文件名。</p><h5 id="module-loaded"><a href="#module-loaded" class="headerlink" title="module.loaded"></a>module.loaded</h5><p>模块是否已经加载完成，或正在加载中。</p><h5 id="module-parent"><a href="#module-parent" class="headerlink" title="module.parent"></a>module.parent</h5><p>最先引用该模块的模块。</p><h5 id="module-paths"><a href="#module-paths" class="headerlink" title="module.paths"></a>module.paths</h5><p>模块的搜索路径。</p><h5 id="module-require-id"><a href="#module-require-id" class="headerlink" title="module.require(id)"></a>module.require(id)</h5><p>提供一种加载模块的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之inspector</title>
      <link href="/articles/2020-02-05-node-inspector.html"/>
      <url>/articles/2020-02-05-node-inspector.html</url>
      
        <content type="html"><![CDATA[<h2 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h2><p>检查器。</p><p>inspector模块提供了一个用户与V8 inspector交互的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const inspector &#x3D; require(&#39;inspector&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="inspector-close"><a href="#inspector-close" class="headerlink" title="inspector.close()"></a>inspector.close()</h4><h4 id="inspector-close-1"><a href="#inspector-close-1" class="headerlink" title="inspector.close"></a>inspector.close</h4><h4 id="inspector-open-port-host-wait"><a href="#inspector-open-port-host-wait" class="headerlink" title="inspector.open([port[, host[, wait]]])"></a>inspector.open([port[, host[, wait]]])</h4><h4 id="inspector-url"><a href="#inspector-url" class="headerlink" title="inspector.url()"></a>inspector.url()</h4><h4 id="inspector-waitForDebugger"><a href="#inspector-waitForDebugger" class="headerlink" title="inspector.waitForDebugger()"></a>inspector.waitForDebugger()</h4><h4 id="inspector-Session类"><a href="#inspector-Session类" class="headerlink" title="inspector.Session类"></a>inspector.Session类</h4><h5 id="new-inspector-Session"><a href="#new-inspector-Session" class="headerlink" title="new inspector.Session()"></a>new inspector.Session()</h5>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之HTTPS</title>
      <link href="/articles/2020-02-05-node-HTTPS.html"/>
      <url>/articles/2020-02-05-node-HTTPS.html</url>
      
        <content type="html"><![CDATA[<h2 id="https-HTTPS"><a href="#https-HTTPS" class="headerlink" title="https(HTTPS)"></a>https(HTTPS)</h2><p>HTTPS是基于TLS/SSL的HTTP协议。在NodeJS中，作为一个单独的模块实现。</p><a id="more"></a><h4 id="https-Agent类"><a href="#https-Agent类" class="headerlink" title="https.Agent类"></a>https.Agent类</h4><p>HTTPS的Agent对象，类似于http.Agent.</p><h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><h4 id="https-Server类"><a href="#https-Server类" class="headerlink" title="https.Server类"></a>https.Server类</h4><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h5 id="server-headersTimeout"><a href="#server-headersTimeout" class="headerlink" title="server.headersTimeout"></a>server.headersTimeout</h5><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><h5 id="server-maxHeadersCount"><a href="#server-maxHeadersCount" class="headerlink" title="server.maxHeadersCount"></a>server.maxHeadersCount</h5><h5 id="server-setTimeout-msecs-callback"><a href="#server-setTimeout-msecs-callback" class="headerlink" title="server.setTimeout([msecs][,callback])"></a>server.setTimeout([msecs][,callback])</h5><h5 id="server-timeout"><a href="#server-timeout" class="headerlink" title="server.timeout"></a>server.timeout</h5><h5 id="server-keepAliveTimeout"><a href="#server-keepAliveTimeout" class="headerlink" title="server.keepAliveTimeout"></a>server.keepAliveTimeout</h5><h5 id="heeps-createServer-options-requestListener"><a href="#heeps-createServer-options-requestListener" class="headerlink" title="heeps.createServer([options][,requestListener])"></a>heeps.createServer([options][,requestListener])</h5><h5 id="https-get-options-callback"><a href="#https-get-options-callback" class="headerlink" title="https.get(options[,callback])"></a>https.get(options[,callback])</h5><h5 id="https-get-url-options-callback"><a href="#https-get-url-options-callback" class="headerlink" title="https.get(url[,options][,callback])"></a>https.get(url[,options][,callback])</h5><h5 id="https-request-options-callback"><a href="#https-request-options-callback" class="headerlink" title="https.request(options[,callback])"></a>https.request(options[,callback])</h5><h5 id="https-request-url-options-callback"><a href="#https-request-url-options-callback" class="headerlink" title="https.request(url[,options][,callback])"></a>https.request(url[,options][,callback])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const https &#x3D; require(&#39;https&#39;);</span><br><span class="line"></span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  hostname: &#39;encrypted.google.com&#39;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  method: &#39;GET&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const req &#x3D; https.request(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;状态码:&#39;, res.statusCode);</span><br><span class="line">  console.log(&#39;请求头:&#39;, res.headers);</span><br><span class="line"></span><br><span class="line">  res.on(&#39;data&#39;, (d) &#x3D;&gt; &#123;</span><br><span class="line">    process.stdout.write(d);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(e);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS之HTTP/2</title>
      <link href="/articles/2020-02-05-node-Http-2.html"/>
      <url>/articles/2020-02-05-node-Http-2.html</url>
      
        <content type="html"><![CDATA[<h2 id="http2-HTTP-2"><a href="#http2-HTTP-2" class="headerlink" title="http2 (HTTP/2)"></a>http2 (HTTP/2)</h2><p>http2模块提供了HTTP/2协议的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h4><p>核心API提供了专门针对支持HTTP/2协议的特性而设计的底层接口。</p><p>http2核心API在客户端和服务器之间比http API更加对称。</p><h4 id="Http2Session类"><a href="#Http2Session类" class="headerlink" title="Http2Session类"></a>Http2Session类</h4><p>Http2Session类的实例代表了HTTP/2客户端与服务器之间的一个活跃的通信会话。</p><p>每个Http2Session实例会有略有不同的行为，这取决于它是作为服务器还是客户端运行。<br>Http2Session.type属性可用于判断Http2Session的运行模式。</p><p>用户代码不会直接的创建Http2Session实例。<br>当接收到新的http/2连接时，服务端的Http2Session实例由Http2Server实例创建。</p><h5 id="Http2Session与Socket"><a href="#Http2Session与Socket" class="headerlink" title="Http2Session与Socket"></a>Http2Session与Socket</h5><p>每个Http2Session实例在创建时都会与一个net.Socket或tls.TLSSocket关联。<br>当Socket或Http2Session被销毁时，两者都会被销毁。</p><p>一旦将Socket绑定到Http2Session，则用户代码应仅依赖于Http2Session的API。</p><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="stream事件"><a href="#stream事件" class="headerlink" title="stream事件"></a>stream事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line">session.on(&#39;stream&#39;, (stream, headers, flags) &#x3D;&gt; &#123;</span><br><span class="line">  const method &#x3D; headers[&#39;:method&#39;];</span><br><span class="line">  const path &#x3D; headers[&#39;:path&#39;];</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;:status&#39;: 200,</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;plain&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.write(&#39;hello &#39;);</span><br><span class="line">  stream.end(&#39;world&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an unencrypted HTTP&#x2F;2 server</span><br><span class="line">const server &#x3D; http2.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;stream&#39;, (stream, headers) &#x3D;&gt; &#123;</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;html&#39;,</span><br><span class="line">    &#39;:status&#39;: 200</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.on(&#39;error&#39;, (error) &#x3D;&gt; console.error(error));</span><br><span class="line">  stream.end(&#39;&lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br></pre></td></tr></table></figure><h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><h4 id="ClientHttp2Session类"><a href="#ClientHttp2Session类" class="headerlink" title="ClientHttp2Session类"></a>ClientHttp2Session类</h4><h4 id="Http2Stream类"><a href="#Http2Stream类" class="headerlink" title="Http2Stream类"></a>Http2Stream类</h4><h5 id="Http2Stream的生命周期"><a href="#Http2Stream的生命周期" class="headerlink" title="Http2Stream的生命周期"></a>Http2Stream的生命周期</h5><p>创建、销毁、</p><h4 id="ClientHttp2Stream类"><a href="#ClientHttp2Stream类" class="headerlink" title="ClientHttp2Stream类"></a>ClientHttp2Stream类</h4><h4 id="ServerHttp2Stream类"><a href="#ServerHttp2Stream类" class="headerlink" title="ServerHttp2Stream类"></a>ServerHttp2Stream类</h4><h4 id="Http2Server类"><a href="#Http2Server类" class="headerlink" title="Http2Server类"></a>Http2Server类</h4><h4 id="Http2SecureServer类"><a href="#Http2SecureServer类" class="headerlink" title="Http2SecureServer类"></a>Http2SecureServer类</h4><h4 id="http2-Http2ServerRequest类"><a href="#http2-Http2ServerRequest类" class="headerlink" title="http2.Http2ServerRequest类"></a>http2.Http2ServerRequest类</h4><h4 id="http2-Http2ServerResponse类"><a href="#http2-Http2ServerResponse类" class="headerlink" title="http2.Http2ServerResponse类"></a>http2.Http2ServerResponse类</h4>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之Http</title>
      <link href="/articles/2020-02-02-node-Http.html"/>
      <url>/articles/2020-02-02-node-Http.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>要使用HTTP服务器和客户端，必须require(‘http’);</p><a id="more"></a><h4 id="http-Agent类"><a href="#http-Agent类" class="headerlink" title="http.Agent类"></a>http.Agent类</h4><p>Agent负责管理HTTP客户端的链接持久性和重用。</p><p>它为给定的主机和端口维护一个待处理请求队列，为每个请求重用单独的套接字连接，<br>直到队列为空，此时套接字被销毁或放入连接池，以便再次用于请求到同一个主机和端口。</p><p>销毁还是放入连接池取决于keepAlive选项。</p><p>连接池中的连接已启用TCP Keep-Alive，但服务器仍可能关闭空闲连接，<br>这种情况下，它们将从连接池中删除，并且当为该主机和端口发出新的HTTP请求时将建立新的连接。<br>服务器也可以拒绝通过同一连接允许多个请求，在这种情况下，必须为每个请求重新建立连接，<br>并且不能放入连接池。Agent仍将向该服务器发出请求，但每个请求都将通过新连接发生。</p><p>当客户端或服务器关闭连接时，它将从连接池中删除。连接池中任何未使用的套接字都将被销毁，<br>以便当没有未完成的请求时不用保持Nodejs进程运行。</p><p>当不再使用时最好destrory() Agent实例，因为未使用的套接字会消耗操作系统资源。</p><p>当套接字触发close事件或agentRemove事件时，则套接字从代理中删除。<br>当打算长时间保持一个HTTP请求打开而不将其保留在代理中时，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.get(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 做些事情。</span><br><span class="line">&#125;).on(&#39;socket&#39;, (socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.emit(&#39;agentRemove&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代理也可以用于单个请求，通过提供{agent:false}作为http.get()或http.request()<br>函数的选项，则将使用一次性的具有默认选项的Agent用于客户端的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.get(&#123;</span><br><span class="line">  hostname: &#39;localhost&#39;,</span><br><span class="line">  port: 80,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  agent: false  &#x2F;&#x2F; 仅为此一个请求创建一个新代理。</span><br><span class="line">&#125;, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 用响应做些事情。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><p>options要在代理上设置的可配置选项集。</p><p>要配置其中任何一个，则必须创建自定义的http.Agent实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const keepAliveAgent &#x3D; new http.Agent(&#123; keepAlive: true &#125;);</span><br><span class="line">options.agent &#x3D; keepAliveAgent;</span><br><span class="line">http.request(options, onResponseCallback);</span><br></pre></td></tr></table></figure><h5 id="agent-createConnection-options-callback"><a href="#agent-createConnection-options-callback" class="headerlink" title="agent.createConnection(options[, callback])"></a>agent.createConnection(options[, callback])</h5><p>生成用于http请求的套接字或流。</p><h5 id="agent-keepSocketAlive-socket"><a href="#agent-keepSocketAlive-socket" class="headerlink" title="agent.keepSocketAlive(socket)"></a>agent.keepSocketAlive(socket)</h5><p>当socket与请求分离并且可以由Agent保留时调用，默认行为是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(true, this.keepAliveMsecs);</span><br><span class="line">socket.unref();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><h5 id="agent-reuseSocket-socket-request"><a href="#agent-reuseSocket-socket-request" class="headerlink" title="agent.reuseSocket(socket, request)"></a>agent.reuseSocket(socket, request)</h5><p>由于keep-alive选项而在持久化后将socket附加到request时调用。<br>默认行为是<code>socket.ref()</code></p><h5 id="agent-destroy"><a href="#agent-destroy" class="headerlink" title="agent.destroy()"></a>agent.destroy()</h5><p>销毁代理当前使用的所有套接字。</p><h5 id="agent-maxSockets"><a href="#agent-maxSockets" class="headerlink" title="agent.maxSockets"></a>agent.maxSockets</h5><p>决定代理可以为每个来源打开多少并发套接字。</p><h5 id="agent-requests"><a href="#agent-requests" class="headerlink" title="agent.requests"></a>agent.requests</h5><p>一个对象，包含尚未分配给套接字的请求队列，不要修改。</p><h5 id="agent-sockets"><a href="#agent-sockets" class="headerlink" title="agent.sockets"></a>agent.sockets</h5><p>一个对象，包含当前代理正在使用的套接字数组，不要修改。</p><h4 id="http-ClientRequest类"><a href="#http-ClientRequest类" class="headerlink" title="http.ClientRequest类"></a>http.ClientRequest类</h4><h4 id="http-Server类"><a href="#http-Server类" class="headerlink" title="http.Server类"></a>http.Server类</h4><h4 id="http-ServerResponse类"><a href="#http-ServerResponse类" class="headerlink" title="http.ServerResponse类"></a>http.ServerResponse类</h4><h4 id="http-IncomingMessage类"><a href="#http-IncomingMessage类" class="headerlink" title="http.IncomingMessage类"></a>http.IncomingMessage类</h4><h4 id="http-METHODS"><a href="#http-METHODS" class="headerlink" title="http.METHODS"></a>http.METHODS</h4><h4 id="http-STATUS-CODES"><a href="#http-STATUS-CODES" class="headerlink" title="http.STATUS_CODES"></a>http.STATUS_CODES</h4><h4 id="http-createServer-options-requestListener"><a href="#http-createServer-options-requestListener" class="headerlink" title="http.createServer([options][, requestListener])"></a>http.createServer([options][, requestListener])</h4><h4 id="http-get-options-callback"><a href="#http-get-options-callback" class="headerlink" title="http.get(options[,callback])"></a>http.get(options[,callback])</h4><h4 id="http-get-url-options-callback"><a href="#http-get-url-options-callback" class="headerlink" title="http.get(url[,options][,callback])"></a>http.get(url[,options][,callback])</h4><h4 id="http-globalAgent"><a href="#http-globalAgent" class="headerlink" title="http.globalAgent"></a>http.globalAgent</h4><h4 id="http-maxHeaderSize"><a href="#http-maxHeaderSize" class="headerlink" title="http.maxHeaderSize"></a>http.maxHeaderSize</h4><h4 id="http-request-options-callback"><a href="#http-request-options-callback" class="headerlink" title="http.request(options[,callback])"></a>http.request(options[,callback])</h4><h4 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[,options][,callback])"></a>http.request(url[,options][,callback])</h4>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之global</title>
      <link href="/articles/2020-02-02-node-global.html"/>
      <url>/articles/2020-02-02-node-global.html</url>
      
        <content type="html"><![CDATA[<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>全局变量。</p><p>所有模块都提供这些对象。</p><h4 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h4><p>用于处理二进制数据。</p><h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><a id="more"></a><h4 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h4><h4 id="clearInterval-intervalObject"><a href="#clearInterval-intervalObject" class="headerlink" title="clearInterval(intervalObject)"></a>clearInterval(intervalObject)</h4><h4 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h4><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="global-1"><a href="#global-1" class="headerlink" title="global"></a>global</h4><p>在浏览器中，顶层作用域是全局作用域。<br>在nodejs中，顶层作用于不是全局作用域，nodejs模块中的var something的作用域只在该模块内。</p><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>进程对象。</p><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h4><h4 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[,…args])"></a>setInterval(callback, delay[,…args])</h4><h4 id="setTimeout-callback-delay-…-args"><a href="#setTimeout-callback-delay-…-args" class="headerlink" title="setTimeout(callback, delay[, ….args])"></a>setTimeout(callback, delay[, ….args])</h4><h4 id="TextDecoder"><a href="#TextDecoder" class="headerlink" title="TextDecoder"></a>TextDecoder</h4><h4 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h4><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之fs</title>
      <link href="/articles/2020-02-01-node-fs.html"/>
      <url>/articles/2020-02-01-node-fs.html</url>
      
        <content type="html"><![CDATA[<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p>文件系统</p><p>fs模块提供了一个API，用于模仿标准的POSIX函数的方式与文件系统进行交互。</p><p>引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br></pre></td></tr></table></figure><p>所有文件系统操作都具有同步和异步的形式；</p><a id="more"></a><h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>fs操作接受的文件路径可以指定为字符串、Buffer、或使用file：协议的URL对象。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>fs.open()方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、写入数据或请求关于文件的信息。</p><h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>所有的文件系统API，除了fs.FSWatcher()和那些显示同步之外，都使用libuv的线程池。</p><h4 id="fs-Dir类"><a href="#fs-Dir类" class="headerlink" title="fs.Dir类"></a>fs.Dir类</h4><p>目录流的类。<br>由fs.opendir(), fs.opendirSync()和fsPromises.opendir()创建。</p><h5 id="dir-close"><a href="#dir-close" class="headerlink" title="dir.close()"></a>dir.close()</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>返回一个Promise，将会在关闭资源之后被解决。</p><h5 id="dir-close-callback"><a href="#dir-close-callback" class="headerlink" title="dir.close(callback)"></a>dir.close(callback)</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>关闭资源句柄之后就会调用callback</p><h5 id="dir-closeSync"><a href="#dir-closeSync" class="headerlink" title="dir.closeSync()"></a>dir.closeSync()</h5><p>同步的关闭目录的底层资源句柄。</p><h5 id="dir-path"><a href="#dir-path" class="headerlink" title="dir.path"></a>dir.path</h5><p>此目录的只读路径。</p><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>代码逐条执行，会阻塞。</p><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.openSync(path, flags[,mode])</span><br></pre></td></tr></table></figure><p>写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeSync(fd, string[, position[,encoding]])</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.closeSync(fd)</span><br></pre></td></tr></table></figure><h5 id="异步文件写入"><a href="#异步文件写入" class="headerlink" title="异步文件写入"></a>异步文件写入</h5><p>代码会一起执行不会阻塞。</p><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags[,mode], callback)</span><br></pre></td></tr></table></figure><p>写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.write(fd, string[, position[,encoding]], callback)</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure><h5 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h5><p>同步异步简单文件的写入不适合大文件的写入，性能较差，容易导致内存溢出，<br>而流式文件写入会一点一点的写进去，不会导致内存溢出的状况。</p><p>创建一个可写流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.createWriteStream(path[,options])</span><br></pre></td></tr></table></figure><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ws &#x3D; fs.createWriteStream(&#39;hello.txt&#39;)</span><br><span class="line"></span><br><span class="line">监听流可选：</span><br><span class="line">ws.once(&#39;open&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流打开了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#39;close&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流关闭了&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过ws向文件中输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.write(&#39;hhhhhhhh&#39;)</span><br><span class="line">ws.write(&#39;gggggggg&#39;)</span><br></pre></td></tr></table></figure><p>关闭流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.end()</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>将可读流中的内容，直接输出到可写流里。</p><h5 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path)"></a>fs.existsSync(path)</h5><p>检查一个文件是否存在。</p><h5 id="fs-stat-path-options-callback-fs-statSync-path-options"><a href="#fs-stat-path-options-callback-fs-statSync-path-options" class="headerlink" title="fs.stat(path[,options], callback) / fs.statSync(path[,options])"></a>fs.stat(path[,options], callback) / fs.statSync(path[,options])</h5><p>获取文件状态。</p><h5 id="fs-unlink-path-callback-fs-unlinkSync-path"><a href="#fs-unlink-path-callback-fs-unlinkSync-path" class="headerlink" title="fs.unlink(path, callback) / fs.unlinkSync(path)"></a>fs.unlink(path, callback) / fs.unlinkSync(path)</h5><p>删除文件。</p><h5 id="fs-readdir-path-options-callback-fs-readdirSync-path-options"><a href="#fs-readdir-path-options-callback-fs-readdirSync-path-options" class="headerlink" title="fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])"></a>fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])</h5><p>读取一个目录的目录结构。</p><h5 id="fs-truncate-path-len-callback-fs-truncateSync-path-len"><a href="#fs-truncate-path-len-callback-fs-truncateSync-path-len" class="headerlink" title="fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])"></a>fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])</h5><p>截断文件。</p><h5 id="fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode"><a href="#fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode" class="headerlink" title="fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])"></a>fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])</h5><p>创建一个文件夹。</p><h5 id="fs-rmdir-path-callback-fs-rmdirSync-path"><a href="#fs-rmdir-path-callback-fs-rmdirSync-path" class="headerlink" title="fs.rmdir(path, callback) / fs.rmdirSync(path)"></a>fs.rmdir(path, callback) / fs.rmdirSync(path)</h5><p>删除一个目录。</p><h5 id="fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath"><a href="#fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath" class="headerlink" title="fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)"></a>fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)</h5><p>重命名文件夹。</p><h5 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[,options], listener)"></a>fs.watchFile(filename[,options], listener)</h5><p>监视文件的修改。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之events</title>
      <link href="/articles/2020-02-01-node-events.html"/>
      <url>/articles/2020-02-01-node-events.html</url>
      
        <content type="html"><![CDATA[<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>事件触发器。</p><p>eventEmitter.on()：用于注册监听器；<br>eventEmitter.emit()：用于触发事件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line"></span><br><span class="line">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="将参数和this传给监听器"><a href="#将参数和this传给监听器" class="headerlink" title="将参数和this传给监听器"></a>将参数和this传给监听器</h4><p>eventEmitter.emit()方法可以传任意数量的参数到监听器函数。<br>当监听器函数被调用时，this关键词被指向监听器所绑定的EventEmitter实例。<br>当使用ES6de箭头函数作为监听器，this不会指向EventEmitter实例。</p><h4 id="异步-VS-同步"><a href="#异步-VS-同步" class="headerlink" title="异步 VS 同步"></a>异步 VS 同步</h4><p>EventEmitter以注册的顺序同步调用所有监听器。<br>监听器函数可以使用setImmediate()和process.nextTick()方法切换到异步的操作模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;异步地发生&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);</span><br></pre></td></tr></table></figure><h4 id="仅处理事件一次"><a href="#仅处理事件一次" class="headerlink" title="仅处理事件一次"></a>仅处理事件一次</h4><p>eventEmitter.on()注册监听器时，监听器会在每次触发命名事件时调用。<br>eventEmitter.once()可以注册最多可调用一次的监听器，当事件被触发时，监听器会被注销，然后再调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">let m &#x3D; 0;</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 2</span><br><span class="line"></span><br><span class="line">myEmitter.once(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 不触发</span><br></pre></td></tr></table></figure><h4 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h4><p>EventEmitter实例出错时，应该触发error事件，<br>如果没有为error事件注册监听器，当error事件触发时，会抛出错误、打印堆栈跟踪、并退出Node进程。</p><p>为了防止崩溃Node进程，可以使用domain模块，不推荐。<br>最佳是应该始终为error事件注册监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;错误信息&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;error&#39;, new Error(&#39;错误&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印: 错误信息</span><br></pre></td></tr></table></figure><h4 id="EventEmitter类"><a href="#EventEmitter类" class="headerlink" title="EventEmitter类"></a>EventEmitter类</h4><p>由events模块定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br></pre></td></tr></table></figure><p>当新增监听器时，会触发newListener事件；<br>当移除已存在的监听器时，则触发removeListener事件；</p><p>emitter.addListener(eventName, listener)：emitter.on(eventName, listener)的别名。<br>emitter.emit(eventName[, …args])：按照监听器注册的顺序，同步调用每个注册到名为eventName事件的监听器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const myEmitter &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function firstListener() &#123;</span><br><span class="line">  console.log(&#39;第一个监听器&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第二个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function secondListener(arg1, arg2) &#123;</span><br><span class="line">  console.log(&#96;第二个监听器中的事件有参数 $&#123;arg1&#125;、$&#123;arg2&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第三个监听器</span><br><span class="line">myEmitter.on(&#39;event&#39;, function thirdListener(...args) &#123;</span><br><span class="line">  const parameters &#x3D; args.join(&#39;, &#39;);</span><br><span class="line">  console.log(&#96;第三个监听器中的事件有参数 $&#123;parameters&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(myEmitter.listeners(&#39;event&#39;));</span><br><span class="line"></span><br><span class="line">myEmitter.emit(&#39;event&#39;, 1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;   [Function: firstListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: secondListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: thirdListener]</span><br><span class="line">&#x2F;&#x2F; ]</span><br><span class="line">&#x2F;&#x2F; 第一个监听器</span><br><span class="line">&#x2F;&#x2F; 第二个监听器中的事件有参数 1、2</span><br><span class="line">&#x2F;&#x2F; 第三个监听器中的事件有参数 1, 2, 3, 4, 5</span><br></pre></td></tr></table></figure><p>emitter.eventNames()：返回已注册监听器的事件名数组。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之error</title>
      <link href="/articles/2020-02-01-node-error.html"/>
      <url>/articles/2020-02-01-node-error.html</url>
      
        <content type="html"><![CDATA[<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>错误。</p><p>NodeJs应用程序一般会有四种错误：</p><ul><li>标准的JavaScript错误；</li><li>由底层操作系统触发的系统错误；</li><li>由应用程序代码触发的用户自定义的错误；</li><li>AssertionError错误，当Node监测到不应该发生的异常逻辑时触发，这类错误通常来自assert模块；</li></ul><p>所有由Nodejs引起的Javascript错误与系统错误都继承自或实例化自标准的JavaScript<Error>类，<br>且保证至少提供类中的属性。</p><a id="more"></a><h4 id="错误的冒泡和捕获"><a href="#错误的冒泡和捕获" class="headerlink" title="错误的冒泡和捕获"></a>错误的冒泡和捕获</h4><p>异常捕获处理<code>try...catch</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 抛出一个 ReferenceError，因为 z 未定义。</span><br><span class="line">try &#123;</span><br><span class="line">  const m &#x3D; 1;</span><br><span class="line">  const n &#x3D; m + z;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在这里处理错误。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调中的Error参数"><a href="#回调中的Error参数" class="headerlink" title="回调中的Error参数"></a>回调中的Error参数</h4><p>大多数Nodejs核心API所提供的异步方法都遵从错误信息优先的回调模式惯例，这种模式有时也称为Nodejs回调。</p><p>但JavaScript的try…catch机制不能用来截获异步方法产生的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">     setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异常错误，这是因为异步函数执行上下文不同，所以捕获不到。</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了捕获异步产生的异常错误，可以用domain模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var domain &#x3D; require(&#39;domain&#39;);</span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line">d.run(function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异步异常</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    console.log(err); &#x2F;&#x2F; 这里可以捕获异步异常</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者express挂载接受error函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(function (err,req,res,next)&#123;</span><br><span class="line">   &#x2F;&#x2F;前面的中间件的错误next(err),都在这里接收。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>new Error(message)：新建一个Error实例，创建一个异常错误对象；<br>throw new Error(message)：创建一个对象并抛出错误，如果不捕获则node崩溃；</p><p>error.code：标识错误类别的字符标签；<br>error.message：错误描述；<br>error.stack：一个字符串；</p><h4 id="AssertionError类"><a href="#AssertionError类" class="headerlink" title="AssertionError类"></a>AssertionError类</h4><p>表明断言的失败。</p><h4 id="ReferenceError类"><a href="#ReferenceError类" class="headerlink" title="ReferenceError类"></a>ReferenceError类</h4><p>表明试图访问一个未定义的变量。<br>此类错误通常表明代码有拼写错误或程序已损坏。</p><h4 id="SyntaxError类"><a href="#SyntaxError类" class="headerlink" title="SyntaxError类"></a>SyntaxError类</h4><p>表明程序不是有效的JavaScript。</p><h4 id="TypeError类"><a href="#TypeError类" class="headerlink" title="TypeError类"></a>TypeError类</h4><p>表明提供的参数不是被允许的类型。</p><h4 id="NodeJs中常用的异常处理方式"><a href="#NodeJs中常用的异常处理方式" class="headerlink" title="NodeJs中常用的异常处理方式"></a>NodeJs中常用的异常处理方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每秒钟打印一次时间，确保程序没有奔溃</span><br><span class="line">(function loop() &#123;</span><br><span class="line">    console.log(new Date().getTime())</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        loop() </span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 模拟同步代码块内出现异常</span><br><span class="line">let syncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;Sync Error&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 模拟异步代码块内出现异常</span><br><span class="line">let asyncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;Async Error&#39;)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">try &#123;</span><br><span class="line">    syncError()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;异常被捕获了，我可以继续执行&#39;)</span><br><span class="line"></span><br><span class="line">2. callback方式</span><br><span class="line">fs.mkdir(&#39;&#x2F;dir&#39;, function (e) &#123;</span><br><span class="line">    if (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;创建目录成功&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3. event方式</span><br><span class="line">let events &#x3D; require(&quot;events&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个事件监听对象</span><br><span class="line">let emitter &#x3D; new events.EventEmitter();</span><br><span class="line">&#x2F;&#x2F;监听error事件</span><br><span class="line">emitter.addListener(&quot;error&quot;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发error事件</span><br><span class="line">emitter.emit(&quot;error&quot;, new Error(&#39;出错啦&#39;));</span><br><span class="line"></span><br><span class="line">4. Promise方式</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    syncError()</span><br><span class="line">    &#x2F;* or</span><br><span class="line">    try&#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">Promise同样无法处理异步代码块中抛出的异常</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    asyncError()</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*异常无法被捕获,导致进程退出*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">5. Async&#x2F;Await方式</span><br><span class="line">var sleep &#x3D; function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await sleep(100);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">6. process方式（可以捕获任何异常，但过于笨重）</span><br><span class="line">process.on(&#39;uncaughtException&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">asyncError()</span><br><span class="line">syncError()</span><br><span class="line"></span><br><span class="line">7. domain方式（也可以处理任何异常模块）</span><br><span class="line">let domain &#x3D; require(&#39;domain&#39;)</span><br><span class="line">let d &#x3D; domain.create()</span><br><span class="line">d.on(&#39;error&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">d.run(asyncError)</span><br><span class="line">d.run(syncError)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之domain</title>
      <link href="/articles/2020-02-01-node-domain.html"/>
      <url>/articles/2020-02-01-node-domain.html</url>
      
        <content type="html"><![CDATA[<h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h2><p>域。<br>简化了异步代码的异常处理，可以捕捉try catch无法捕捉的异常。</p><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const domain &#x3D; require(&#39;domain&#39;)</span><br></pre></td></tr></table></figure><p>domain模块把处理多个不同的IO操作为一个组。<br>当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不会导致程序错误立即退出、</p><h4 id="显示绑定和隐式绑定"><a href="#显示绑定和隐式绑定" class="headerlink" title="显示绑定和隐式绑定"></a>显示绑定和隐式绑定</h4><p>显示绑定：把不是在domain上下文中定义的变量，以代码的方式绑定到domain。<br>隐式绑定：把在domain上下文中定义的变量，自动绑定到domain对象。</p><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>domain.members：已加入domain对象的域定时器和事件发射器的数组。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>domain.run(function)：在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</p><p>doamin.add(emitter)：显示的增加事件。</p><p>doamin.remove(emitter)：删除事件。</p><p>domain.bind(callback)：返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数时，所有被抛出的错误都会被导向到这个域的error事件。</p><p>domain.intercept(callback)：和bind类似，除了捕捉错误外，它还会拦截error对象作为参数传递到这个函数。</p><p>domain.enter()：进入一个异步调用的上下文，绑定到domain。</p><p>domain.exit()：退出当前的domain，切换到不同的链的异步调用的上下文中。</p><p>domain.dispose()：释放一个domain对象，让node进程回收这部分资源。</p><p>domain.create()：返回一个domain对象。</p>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之dns</title>
      <link href="/articles/2020-02-01-node-dns.html"/>
      <url>/articles/2020-02-01-node-dns.html</url>
      
        <content type="html"><![CDATA[<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>域名服务器。</p><p>dns模块包含了两个不同类别的函数：<br>1、使用底层操作系统工具执行名称解析但不一定执行任何网络通信的函数。<br>此类别仅包含一个函数：dns.lookup()。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.lookup(&#39;iana.org&#39;, (err, address, family) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;地址: %j 地址族: IPv%s&#39;, address, family);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 地址: &quot;192.0.43.8&quot; 地址族: IPv4</span><br></pre></td></tr></table></figure><p>2、连接到实际的DNS服务器以执行名称解析并始终使用网络执行DNS查询的函数。包含dns模块中除dns.lookup()之外的所有函数。<br>这些函数不使用与dns.lookup()使用的同一配置文件。<br>这些函数应该由不希望使用底层系统的工具进行名称解析、而始终执行dns查询的开发者使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.resolve4(&#39;archive.org&#39;, (err, addresses) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;地址: $&#123;JSON.stringify(addresses)&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  addresses.forEach((a) &#x3D;&gt; &#123;</span><br><span class="line">    dns.reverse(a, (err, hostnames) &#x3D;&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        throw err;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#96;地址 $&#123;a&#125; 逆向解析到域名: $&#123;JSON.stringify(hostnames)&#125;&#96;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200120172840178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vXzI0Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200120174218212.png" alt="在这里插入图片描述"></p><h3 id="rrtypes"><a href="#rrtypes" class="headerlink" title="rrtypes"></a>rrtypes</h3><p>dns.resolve() 方法中有效的 rrtypes值:</p><ul><li>‘A’ IPV4 地址, 默认；</li><li>‘AAAA’ IPV6 地址；</li><li>‘MX’ 邮件交换记录；</li><li>‘TXT’ text 记录；</li><li>‘SRV’ SRV 记录；</li><li>‘PTR’ 用来反向 IP 查找；</li><li>‘NS’ 域名服务器记录；</li><li>‘CNAME’ 别名记录；</li><li>‘SOA’ 授权记录的初始值；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之dgram</title>
      <link href="/articles/2020-02-01-node-dgram.html"/>
      <url>/articles/2020-02-01-node-dgram.html</url>
      
        <content type="html"><![CDATA[<h2 id="dgram"><a href="#dgram" class="headerlink" title="dgram"></a>dgram</h2><p>dgram数据报提供了UDP数据包socket的实现。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">创建dgram.Sockrt的新实例，不使用new</span><br><span class="line">const server &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line"></span><br><span class="line">error发生错误时触发</span><br><span class="line">server.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器异常：\n$&#123;err.stack&#125;&#96;);</span><br><span class="line">  关闭一个socket之后触发，一旦触发，则这个socket上将不会触发新的message事件。</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">当有新的数据包被socket接收时，message事件会被触发</span><br><span class="line">server.on(&#39;message&#39;, (msg, rinfo) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器接收到来自 $&#123;rinfo.address&#125;:$&#123;rinfo.port&#125; 的 $&#123;msg&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">开始监听数据包信息时触发</span><br><span class="line">server.on(&#39;listening&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  const address &#x3D; server.address();</span><br><span class="line">  console.log(&#96;服务器监听 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.bind(41234);</span><br><span class="line">&#x2F;&#x2F; 服务器监听 0.0.0.0:41234</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>addMembership()<br>  添加组播成员；</li><li>dropMembership()<br>  删除组播成员；</li><li>address()<br>  返回socket地址信息对象，UDP socket对象包含address、family和port属性；</li><li>bind()<br>  绑定端口和主机。<br>  若端口未指定，操作系统绑定一个随机的端口；<br>  若address未指定，操作系统会尝试在所有地址上监听；</li><li>close()<br>  关闭该socket并停止监听其上的数据。</li><li>connect()<br>  关联一个远程地址和端口。</li><li>disconnect()<br>  与远程地址断掉的同步函数。</li><li>ref()<br>将socket重新添加到这个引用列表中，并恢复默认行为。</li><li>unref()<br>将socket从node进程的引用列表中删除。<br>socket对象不再进行通信，程序会退出。<br>即使socket对象还在坚挺数据，也允许退出。</li><li>send()<br>在socket上广播数据报。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">const message &#x3D; Buffer.from(&#39;一些字节&#39;);</span><br><span class="line">const client &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line">client.send(message, 41234, &#39;localhost&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>setTTL()<br>  设置数据报生存时间</li><li>setMulticastTTL()<br>  设置组播数据报生存时间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之crypto</title>
      <link href="/articles/2020-02-01-node-crypto.html"/>
      <url>/articles/2020-02-01-node-crypto.html</url>
      
        <content type="html"><![CDATA[<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><p>crypto模块提供了加密脑功能，包括对OpenSSL的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装。</p><p>下面整理了一些平常经常用到的加密解密方法：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">const crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const Crypto &#x3D; require(&#39;cryptojs&#39;).Crypto</span><br><span class="line">const _crypto &#x3D; require(&#39;crypto&#39;)</span><br><span class="line">const cryptoJS &#x3D; require(&#39;crypto-js&#39;)</span><br><span class="line">const mode &#x3D; new Crypto.mode.CBC(Crypto.pad.pkcs7)</span><br><span class="line">const bytes &#x3D; require(&#39;utf8-bytes&#39;)</span><br><span class="line">const aesKey &#x3D; &#39;&#39;</span><br><span class="line">const aesIv &#x3D; &#39;&#39;</span><br><span class="line">const algorithm &#x3D; &#39;aes-128-cbc&#39;</span><br><span class="line"></span><br><span class="line">1. sha1</span><br><span class="line">function sha1Sign(src) &#123;</span><br><span class="line">    const sha1 &#x3D; crypto.createHash(&#39;sha1&#39;);</span><br><span class="line">    sha1.update(src);</span><br><span class="line">    return sha1.digest(&#39;hex&#39;).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function makeSalt() &#123;</span><br><span class="line">    return crypto.randomBytes(16).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. hash</span><br><span class="line">function hashPassword(password, salt) &#123;</span><br><span class="line">    assert(password &amp;&amp; salt, &#39;pwd or salt missing&#39;);</span><br><span class="line">    const _salt &#x3D; new Buffer(salt, &#39;base64&#39;);</span><br><span class="line">    return crypto.pbkdf2Sync(password, _salt, 10000, 64).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. dec</span><br><span class="line">const algorithm &#x3D; &#39;aes-256-ctr&#39;,</span><br><span class="line">    password &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">function encrypt(buffer)&#123;</span><br><span class="line">    let cipher &#x3D; crypto.createCipher(algorithm,password)</span><br><span class="line">    let crypted &#x3D; Buffer.concat([cipher.update(buffer),cipher.final()]);</span><br><span class="line">    return crypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt(buffer)&#123;</span><br><span class="line">    let decipher &#x3D; crypto.createDecipher(algorithm,password)</span><br><span class="line">    let dec &#x3D; Buffer.concat([decipher.update(buffer) , decipher.final()]);</span><br><span class="line">    return dec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. des-cbc</span><br><span class="line">const desIv &#x3D; &#39;\1\2\3\4\5\6\7\x08&#39;; (在不同的语言对初始向量的处理方式不同会造成解密不完全、乱码等，需要初始向量的表现形式)</span><br><span class="line"></span><br><span class="line">function desCreateCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv ? desIv : 0);</span><br><span class="line">    &#x2F;&#x2F; encrypt</span><br><span class="line">    let cipher &#x3D; crypto.createCipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    cipher.setAutoPadding(true);</span><br><span class="line">    let ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;hex&#39;);</span><br><span class="line">    return ciph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desDecryptCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv);</span><br><span class="line">    const decipher &#x3D; crypto.createDecipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    decipher.setAutoPadding(true);</span><br><span class="line">    let txt &#x3D; decipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    txt +&#x3D; decipher.final(&#39;utf8&#39;);</span><br><span class="line">    return txt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. des-ecb</span><br><span class="line">function desEcbEncrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createCipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;base64&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desEcbDecrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createDecipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;utf8&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7. md5</span><br><span class="line">function md5(Str) &#123;</span><br><span class="line">    var md5sum &#x3D; _crypto.createHash(&#39;md5&#39;)</span><br><span class="line">    md5sum.update(new Buffer(Str))</span><br><span class="line">    return md5sum.digest(&#39;hex&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5to16(Str) &#123;</span><br><span class="line">    let res &#x3D; md5(Str)</span><br><span class="line">    return res.substring(8, 24)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8. dec</span><br><span class="line">function encrypt(plaintext, key) &#123;</span><br><span class="line">    var ub &#x3D; Crypto.charenc.UTF8.stringToBytes(plaintext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var eb &#x3D; Crypto.AES.encrypt(ub, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.util.bytesToBase64(eb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt (ciphertext, key) &#123;</span><br><span class="line">    var eb &#x3D; Crypto.util.base64ToBytes(ciphertext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var ub &#x3D; Crypto.AES.decrypt(eb, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.charenc.UTF8.bytesToString(ub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateKey (buffer) &#123;</span><br><span class="line">    if (buffer) return Crypto.util.bytesToBase64(buffer)</span><br><span class="line">    return Crypto.util.bytesToBase64(Crypto.util.randomBytes(16))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateEpubKey(chapterName) &#123;</span><br><span class="line">    let key &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.key&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.key&#125;&#96;)</span><br><span class="line">    let IV &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.IV&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.IV&#125;&#96;)</span><br><span class="line">    return IV + key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function encryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createCipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createDecipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipher(ciphertext) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipher(data) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(data, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dictSort(obj) &#x3D;&gt; &#123;</span><br><span class="line">    const sorted &#x3D; Object.keys(obj).sort();</span><br><span class="line">    let str &#x3D; &#39;&#39;;</span><br><span class="line">    sorted.forEach((key) &#x3D;&gt; str +&#x3D; obj[key]);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherIv (plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherHexIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;hex&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherHexIv(plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;) + cip.final(&#39;hex&#39;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接请求字符串并加密</span><br><span class="line">function hmacSHA256 (content, appKey) &#123;</span><br><span class="line">    return cryptoJS.enc.Hex.stringify(cryptoJS.HmacSHA256(content, appKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9. AES解密 </span><br><span class="line">function aesDecrypt(content, keys, ivs) &#123;</span><br><span class="line">    const key &#x3D; cryptoJS.enc.Utf8.parse(keys);</span><br><span class="line">    const iv &#x3D; cryptoJS.enc.Utf8.parse(ivs);</span><br><span class="line">    const encryptedHexStr &#x3D; cryptoJS.enc.Hex.parse(content);</span><br><span class="line">    const srcs &#x3D; cryptoJS.enc.Base64.stringify(encryptedHexStr);</span><br><span class="line">    const decrypt &#x3D; cryptoJS.AES.decrypt(srcs, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: cryptoJS.mode.CBC,</span><br><span class="line">        padding: cryptoJS.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    const decryptedStr &#x3D; decrypt.toString(cryptoJS.enc.Utf8);</span><br><span class="line">    return decryptedStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之cluster</title>
      <link href="/articles/2020-02-01-node-cluster.html"/>
      <url>/articles/2020-02-01-node-cluster.html</url>
      
        <content type="html"><![CDATA[<h2 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h2><p>集群<br>单个Nodejs实例运行在单个线程中，为充分利用多核系统，需要启用一组Node进程处理负载任务。</p><p>cluster允许建立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。<br>worker之间采用进程通信交换消息，cluster模块内置一个负载均衡。</p><p>cluster集成两个方面：</p><ul><li>集成了child_process.fork方法创建node子进程的方式；</li><li>继承了很多多核cpu创建子进程后，自动控制负载均衡的方式；</li></ul><a id="more"></a><p>cluster模块可以创建共享服务器端口的子进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const numCPUs &#x3D; require(&#39;os&#39;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#96;主进程 $&#123;process.pid&#125; 正在运行&#96;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 衍生工作进程。</span><br><span class="line">  for (let i &#x3D; 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作进程 $&#123;worker.process.pid&#125; 已退出&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程可以共享任何 TCP 连接。</span><br><span class="line">  &#x2F;&#x2F; 在本例子中，共享的是 HTTP 服务器。</span><br><span class="line">  http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end(&#39;你好世界\n&#39;);</span><br><span class="line">  &#125;).listen(8000);</span><br><span class="line"></span><br><span class="line">  console.log(&#96;工作进程 $&#123;process.pid&#125; 已启动&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主进程 3596 正在运行</span><br><span class="line">工作进程 4324 已启动</span><br><span class="line">工作进程 4520 已启动</span><br><span class="line">工作进程 6056 已启动</span><br><span class="line">工作进程 5644 已启动</span><br></pre></td></tr></table></figure><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>cluster支持两种分发连接方法：</p><ol><li>循环法，由主进程负责监听端口，接收新连接后再将连接循环发给工作进程，在分发中使用了一些内置技巧防止工作进程中任务过载；</li><li>主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接；</li></ol><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker对象包含了关于工作进程的所有的公共的信息和方法。<br>主进程中，使用cluster.workers获取<br>工作进程中，使用cluster.worker获取</p><h4 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>断开连接</p><h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><p>工作进程中，可以使用process.on(‘error’)</p><h4 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const worker &#x3D; cluster.fork();</span><br><span class="line">worker.on(&#39;exit&#39;, (code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (signal) &#123;</span><br><span class="line">    console.log(&#96;工作进程已被信号 $&#123;signal&#125; 杀死&#96;);</span><br><span class="line">  &#125; else if (code !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    console.log(&#96;工作进程退出，退出码: $&#123;code&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;工作进程成功退出&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="listening事件"><a href="#listening事件" class="headerlink" title="listening事件"></a>listening事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster.fork().on(&#39;listening&#39;, (address) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程正在监听。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h4><p>在工作进程内，也可以使用 process.on(‘message’)</p><h4 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster.fork().on(&#39;online&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程已上线。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="worker-disconnect"><a href="#worker-disconnect" class="headerlink" title="worker.disconnect()"></a>worker.disconnect()</h4><p>在一个工作进程内，调用此方法会关闭所有的 server，并等待这些 server 的 ‘close’ 事件执行，然后关闭 IPC 管道。</p><p>在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用 .disconnect()</p><h4 id="worker-exitedAfterDisconnect"><a href="#worker-exitedAfterDisconnect" class="headerlink" title="worker.exitedAfterDisconnect"></a>worker.exitedAfterDisconnect</h4><p>如果工作进程由于 .kill() 或 .disconnect() 而退出，则此属性为 true。<br>如果工作进程以任何其他方式退出，则为 false。<br>如果工作进程尚未退出，则为 undefined。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (worker.exitedAfterDisconnect &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">    console.log(&#39;这是自发退出，无需担心&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 杀死工作进程。</span><br><span class="line">worker.kill();</span><br></pre></td></tr></table></figure><h4 id="worker-id"><a href="#worker-id" class="headerlink" title="worker.id"></a>worker.id</h4><p>每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。</p><h4 id="worker-isConnected"><a href="#worker-isConnected" class="headerlink" title="worker.isConnected()"></a>worker.isConnected()</h4><p>当工作进程通过 IPC 管道连接至主进程时，这个方法返回 true，否则返回 false。<br>一个工作进程在创建后会自动连接到它的主进程。<br>当 ‘disconnect’ 事件被触发时才会断开连接。</p><h4 id="worker-isDead"><a href="#worker-isDead" class="headerlink" title="worker.isDead()"></a>worker.isDead()</h4><p>当工作进程被终止时（包括自动退出或被发送信号），这个方法返回 true。 否则，返回 false。</p><h4 id="worker-kill-signal-’SIGTERM’"><a href="#worker-kill-signal-’SIGTERM’" class="headerlink" title="worker.kill([signal=’SIGTERM’])"></a>worker.kill([signal=’SIGTERM’])</h4><p>杀死工作进程。<br>主进程，通过断开与worker.process的连接来实现，一旦断开连接，通过signal杀死工作进程；<br>工作进程，通过断开IPC管道来实现，然后以代码0退出进程；</p><h4 id="worker-process"><a href="#worker-process" class="headerlink" title="worker.process"></a>worker.process</h4><p>所有的工作都通过child_process.fork()创建，返回的对象被存储为.process。工作进程中，process属于全局对象。</p><p>当process发生disconnect事件，且.exitedAfterDisconnect的值不是true时，工作进程会调用process.exit(0)来防止连接意外断开。</p><h4 id="worker-send"><a href="#worker-send" class="headerlink" title="worker.send()"></a>worker.send()</h4><p>发送消息给主进程或工作进程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  const worker &#x3D; cluster.fork();</span><br><span class="line">  worker.send(&#39;你好&#39;);</span><br><span class="line"></span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  process.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">    process.send(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="disconnect事件-1"><a href="#disconnect事件-1" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>工作进程的IPC管道被断开后触发。<br>可能导致触发的原因：</p><ul><li><p>工作进程优雅的退出；</p></li><li><p>被杀死；</p></li><li><p>手动断开连接；</p><p>‘disconnect’ 和 ‘exit’ 事件之间可能存在延迟。 这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(&#39;disconnect&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;工作进程 #$&#123;worker.id&#125; 已断开连接&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="exit事件-1"><a href="#exit事件-1" class="headerlink" title="exit事件"></a>exit事件</h4><p>当任何一个工作进程关闭的时候，cluster模块都会触发exit事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程 %d 关闭 (%s). 重启中...&#39;,</span><br><span class="line">              worker.process.pid, signal || code);</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="fork事件"><a href="#fork事件" class="headerlink" title="fork事件"></a>fork事件</h4><p>当新的工作进程被衍生时，cluster触发fork事件。<br>可以被用来记录工作进程活动，并产生一个自定义的超时。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const timeouts &#x3D; [];</span><br><span class="line">function errorMsg() &#123;</span><br><span class="line">  console.error(&#39;连接出错&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cluster.on(&#39;fork&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  timeouts[worker.id] &#x3D; setTimeout(errorMsg, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">  errorMsg();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="listening事件-1"><a href="#listening事件-1" class="headerlink" title="listening事件"></a>listening事件</h4><p>当工作进程调用listen()后，工作进程上的server会触发listening事件，<br>同时主进程上的cluster会触发listening事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">worker 包含了工作进程对象</span><br><span class="line">address 包含了以下的连接属性：address、 port 和 addressType。 </span><br><span class="line"></span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;工作进程已连接到 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>addressType 可选值包括:</p><ul><li>4 (TCPv4) </li><li>6 (TCPv6)</li><li>-1 (Unix 域 socket)</li><li>‘udp4’ or ‘udp6’ (UDP v4 或 v6)</li></ul><h4 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h4><p>当集群主进程从任何工作进程接收到消息时触发。</p><h4 id="online事件-1"><a href="#online事件-1" class="headerlink" title="online事件"></a>online事件</h4><p>当衍生一个新的工作进程后，工作进程会响应一个上线消息。<br>当主进程收到上线消息后悔触发此事件。</p><p>当主进程衍生工作进程时触发fork；<br>当工作进程运行时触发online；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cluster.on(&#39;online&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程被衍生后响应&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="setup事件"><a href="#setup事件" class="headerlink" title="setup事件"></a>setup事件</h4><p>每当.setupMaster()被调用时触发。</p><h4 id="cluster-disconnect"><a href="#cluster-disconnect" class="headerlink" title="cluster.disconnect()"></a>cluster.disconnect()</h4><p>cluster.workers的每个工作进程中调用.disconnect()</p><h4 id="cluster-fork"><a href="#cluster-fork" class="headerlink" title="cluster.fork()"></a>cluster.fork()</h4><p>衍生出一个新的工作进程，只能通过主进程调用。</p><h4 id="cluster-isMaster"><a href="#cluster-isMaster" class="headerlink" title="cluster.isMaster"></a>cluster.isMaster</h4><p>如果进程是主进程，则为true。</p><h4 id="cluster-isWorker"><a href="#cluster-isWorker" class="headerlink" title="cluster.isWorker"></a>cluster.isWorker</h4><p>如果进程不是主进程，则为true。</p><h4 id="cluster-schdulingPolicy"><a href="#cluster-schdulingPolicy" class="headerlink" title="cluster.schdulingPolicy"></a>cluster.schdulingPolicy</h4><p>调度策略。</p><h4 id="cluster-settings"><a href="#cluster-settings" class="headerlink" title="cluster.settings"></a>cluster.settings</h4><p>调用.setupMaster()或.fork()之后，这个配置对象将会包含这些配置项，包括默认值。</p><h4 id="cluster-setupMaster"><a href="#cluster-setupMaster" class="headerlink" title="cluster.setupMaster()"></a>cluster.setupMaster()</h4><p>setupMaster用于修改默认的fork行为，一旦调用，会按照cluster.settings进行设置。<br>所有的设置只对后来的.fork()调用有效，对之前的工作进程无影响。<br>唯一无法通过.setupMaster()设置的属性是传给.fork()的env属性。<br>只能由主进程调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">上述的默认值只在第一次调用时有效，当后续调用时，将采用 cluster.setupMaster() 调用时的当前值。</span><br><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;https&#39;],</span><br><span class="line">  silent: true</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; https 工作进程</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;http&#39;]</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; http 工作进程</span><br></pre></td></tr></table></figure><h4 id="cluster-worker"><a href="#cluster-worker" class="headerlink" title="cluster.worker"></a>cluster.worker</h4><p>当前工作进程对象的引用，对于主进程是无用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#39;这是主进程&#39;);</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  console.log(&#96;这是工作进程 #$&#123;cluster.worker.id&#125;&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="cluster-workers"><a href="#cluster-workers" class="headerlink" title="cluster.workers"></a>cluster.workers</h4><p>一个哈希表，储存了活跃的工作进程对象，id作为键名。<br>只能在主进程中调用。<br>工作进程断开连接及退出后，将会从cluster.workers里面移除。<br>移除工作在disconnect和exit两个事件中的最后一个触发之前完成。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历所有工作进程。</span><br><span class="line">function eachWorker(callback) &#123;</span><br><span class="line">  for (const id in cluster.workers) &#123;</span><br><span class="line">    callback(cluster.workers[id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">eachWorker((worker) &#x3D;&gt; &#123;</span><br><span class="line">  worker.send(&#39;通知所有工作进程&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">使用工作进程的唯一 id 是定位工作进程最简单的方式。</span><br><span class="line">socket.on(&#39;data&#39;, (id) &#x3D;&gt; &#123;</span><br><span class="line">  const worker &#x3D; cluster.workers[id];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之child_process</title>
      <link href="/articles/2020-02-01-node-child-process.html"/>
      <url>/articles/2020-02-01-node-child-process.html</url>
      
        <content type="html"><![CDATA[<h2 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h2><p>child_process提供了衍生子进程的能力。</p><p>node单线程的问题就是会导致无法充分利用CPU等资源，通过child_process实现子进程，从而实现1个主进程(master)，多个子进程的模式(工作进程)。</p><a id="more"></a><h4 id="创建异步的子进程"><a href="#创建异步的子进程" class="headerlink" title="创建异步的子进程"></a>创建异步的子进程</h4><ul><li><p>child_process.exec(command[, options][, callback])<br>执行的是非node程序，是一个shell命令，执行结果以回调的形式返回。</p><p>  【注意】</p><pre><code> 1、command 是一个 shell 命令的字符串，一般是 shell 内置的 命令或shell脚本组成的文件，如 ls、cat、start.sh等，包含了命令的参数；2、可以使用 callback；3、执行成功，error为null；失败，error为Error的实例，error.code为错误码；4、若timeout大于0，则当子进程运行超过timeout毫秒，会给进程发送killSignal指定的信号；</code></pre> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">exec(&#39;cat *.js missing_file | wc -l&#39;, (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.error(&#96;执行的错误: $&#123;error&#125;&#96;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#96;stdout: $&#123;stdout&#125;&#96;);</span><br><span class="line">  console.error(&#96;stderr: $&#123;stderr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const exec &#x3D; util.promisify(require(&#39;child_process&#39;).exec);</span><br><span class="line"></span><br><span class="line">async function lsExample() &#123;</span><br><span class="line">  const &#123; stdout, stderr &#125; &#x3D; await exec(&#39;ls&#39;);</span><br><span class="line">  console.log(&#39;stdout:&#39;, stdout);</span><br><span class="line">  console.error(&#39;stderr:&#39;, stderr);</span><br><span class="line">&#125;</span><br><span class="line">lsExample();</span><br></pre></td></tr></table></figure></li><li><p>child_process.execFile(file[, args][, options][, callback])<br>执行的是非node程序，是一个可执行文件或应用，执行结果以回调的形式返回。</p><p> 【注意】<br> 1、比exec更高效，更安全；<br> 2、命令的参数只能作为第二个参数传递；<br> 3、默认情况下不会衍生 shell（和exec的最大差别），指定的可执行 file 直接作为新进程衍生；<br> 3、file 是要运行的可执行文件的名称或路径，如 node.exe，不能是 start.js 这种脚本文件；<br> 4、不支持I/O重定向，文件glob等；</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; execFile &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const execFile &#x3D; util.promisify(require(&#39;child_process&#39;).execFile);</span><br><span class="line">async function getVersion() &#123;</span><br><span class="line">  const &#123; stdout &#125; &#x3D; await execFile(&#39;node&#39;, [&#39;--version&#39;]);</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;</span><br><span class="line">getVersion();</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>child_process.spawn(command[, args][, options])<br>执行的是非node程序，是一个shell命令，不需要获取执行结果，执行结果以流的形式返回。</p><p> 【注意】<br> 1、 使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数，默认是空数组；<br> 2、以流的形式，可以减少内存占用提高输入输出效率；</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1. 检查失败的spawn</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const subprocess &#x3D; spawn(&#39;bad_command&#39;);</span><br><span class="line"></span><br><span class="line">subprocess.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;启动子进程失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. 运行ls -lh &#x2F;usr，并捕获stdout、stderr、退出码</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const ls &#x3D; spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;&#x2F;usr&#39;]);</span><br><span class="line"></span><br><span class="line">ls.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;stdout: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#96;stderr: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.on(&#39;close&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;子进程退出，退出码 $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>child_process.fork(modulePath[, args][, options])<br>执行的是node程序，是一个.js文件，不需要获取执行结果，执行结果以流的形式返回，fork出来的进程一定是node进程。</p><p>  【注意】<br> 1、专门用于衍生新的 node进程；<br> 2、返回子进程ChildProcess对象，并内置为一个额外的IPC通信通道，允许消息在父进程和子进程之间来回传递，子进程独立于父进程；<br> 3、modulePath 要在node子进程中运行的模块，由于是 node.js 的进程，所以可以是 .js 文件；<br> 4、无回调，参数要以第二个参数传入；</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">通过process.on(&#39;message&#39;)和process.send()的机制来接收和发送消息</span><br><span class="line">child.js</span><br><span class="line">process.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">   process.send(msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">parent.js</span><br><span class="line">let cp&#x3D;require(&#39;child_process&#39;);</span><br><span class="line">let child&#x3D;cp.fork(&#39;.&#x2F;child&#39;);</span><br><span class="line">child.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">  console.log(&#39;got a message is&#39;,msg);</span><br><span class="line">&#125;);</span><br><span class="line">child.send(&#39;hello world&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; child.disconnect() 父进程中调用， 断开父子间IPC通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; got a message is hello world</span><br></pre></td></tr></table></figure><h4 id="ChildProcess类"><a href="#ChildProcess类" class="headerlink" title="ChildProcess类"></a>ChildProcess类</h4><p>1、childProcess的实例代表衍生的子进程；<br>2、每个实例都有stdout、stdin、stderr三个流对象；</p><ul><li><p>subprocess.stderr 子进程的stderr可读流，subprocess.stderr 是 subprocess.stdio[2] 的别名。 两个属性都将会指向相同的值；</p></li><li><p>subprocess.stdin 子进程的stdin的可写流，subprocess.stdin 是 subprocess.stdio[0] 的别名。 两个属性都将会指向相同的值；</p></li><li><p>subprocess.stdio 一个到子进程的稀疏数组，subprocess.stdio[0]、 subprocess.stdio[1] 和 subprocess.stdio[2] 也分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr；</p></li><li><p>subprocess.stdout 子进程的stdout的可读流，subprocess.stdout 是 subprocess.stdio[1] 的别名。 两个属性都将会指向相同的值；</p></li></ul><p>3、通过fork产生的子进程与父进程可以用send即监听message来相互通信；<br>4、事件：error、close、message、exit、disconnect</p><ul><li>close当子进程的stdio流已被关闭时会触发close事件；</li><li>disconnect断开连接，不再发送或接收消息；</li><li>error出现情况有4中：<br>  1）无法衍生进程；<br>  2）无法杀死进程；<br>  3）向子进程发送消息失败；</li><li>exit子进程结束后退出，但子进程的stdio流可能仍然是打开的；</li><li>message子进程使用process.send()发送消息时会触发message事件；</li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之buffer</title>
      <link href="/articles/2020-02-01-node-buffer.html"/>
      <url>/articles/2020-02-01-node-buffer.html</url>
      
        <content type="html"><![CDATA[<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer类是作为Node API的一部分引入的，用于在TCP流、文件系统操作及其他上下文中与八位字节流进行交互。<br>一个更好的操作二进制数据的类。<br>暂时存放输入输出数据的一段内存。</p><ul><li>Buffer的大小在创建的时候确定，且无法更改；</li><li>Buffer类在全局作用域中，所以无需引用require(‘buffer’)；</li><li>分配的内存不在V8内存中，而是在node的C++层实现的；</li><li>采用slab分配机制，slab是动态内存管理机制，分为full(完全分配状态)、partial(部分分配状态)、empty(未分配状态)；</li></ul><a id="more"></a><p><strong>创建Buffer：</strong></p><ul><li>Buffer.alloc(size，string， encoding)<br>  必填：size<br>  非必填：string、encoding<br>  创建的buffer是被初始化的，Buffer的每一项都用00填充</li><li>Buffer.allocUnsafe(size，string， encoding)<br>  创建的Buffer并没有经过初始化，在内存中只要有闲置的buffer就使用。创建Buffer使得内存分配非常快，但已分配的内存段可能包含敏感的数据，有明显性能优势却不安全。</li></ul><p> <strong>根据内容直接创建buffer：</strong></p><ul><li><p>Buffer.from(buffer)</p></li><li><p>Buffer.from(array)</p></li><li><p>Buffer.from(string, encoding)<br>  必填：string<br>  非必填：encoding</p><ul><li>Buffer.from(buffer)<br> 参数为buffer的时候，会创建一个新的buffer并复制上面的每一个成员；<br> Buffer为引用类型，一个Buffer复制另一个buffer的成员，当其中一个Buffer复制的成员更改，另一个Buffer对应成员跟着改变。</li></ul></li></ul><p>  <strong>操作Buffer：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查下buffer的结构</span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer里存的是16进制数字，按照字节长度计算</span><br><span class="line">buf.length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写入数据到buffer</span><br><span class="line">buf.write()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解码buffer</span><br><span class="line">buf.toString()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer拼接</span><br><span class="line">buf.concat(list[, totalLength])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断对象是否为 Buffer</span><br><span class="line">Buffer.isBuffer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断 Buffer 对象编码</span><br><span class="line">Buffer.isEncoding</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和数组的 indexOf 类似，返回某字符串、acsii 码或者 buf 在改 buf 中的位置</span><br><span class="line">buf.indexOf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将一个 buf 的（部分）内容复制到另外一个 buf 中</span><br><span class="line">buf.copy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之async_hooks</title>
      <link href="/articles/2020-02-01-node-async-hooks.html"/>
      <url>/articles/2020-02-01-node-async-hooks.html</url>
      
        <content type="html"><![CDATA[<h2 id="async-hooks"><a href="#async-hooks" class="headerlink" title="async_hooks"></a>async_hooks</h2><p>异步钩子；<br>提供了一组API用来跟踪Nodejs的异步资源(asynchronous resources)的生命周期；</p><p>特性：</p><ol><li>每个函数都会提供一个上下文，为async scope（node为每个函数都提供了一个async scope）;</li><li>每个async scope都有一个asyncId标志，最外层的asyncId是1，每个异步资源在创建时asyncId是全量递增的；</li><li>同步函数不会改变其调用者的asyncId；</li><li>同一个函数，不同时刻进行异步调用，会分配不同的asyncId；</li><li>triggerAsyncId当前函数调用者的asyncId；</li><li>executionAsyncId当前函数的asyncId；</li></ol><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">const async_hooks &#x3D; require(&#39;async_hooks&#39;)</span><br><span class="line"></span><br><span class="line">const eid &#x3D; async_hooks.executionAsyncId()</span><br><span class="line">const tid &#x3D; async_hooks.triggerAsyncId()</span><br><span class="line">console.log(&#96;executionAsyncId: $&#123;eid&#125;, triggerAsyncId: $&#123;tid&#125;&#96;)</span><br><span class="line"></span><br><span class="line">const asyncHooks &#x3D; async_hooks.createHook(&#123;</span><br><span class="line">    &#x2F;&#x2F; fs.writeSync向控制台打印消息，不可用console.log，因为它是一个异步调用，再次使用会触发hook事件，造成无限循环。</span><br><span class="line">    init(asyncId, type, triggerAsyncId, resource) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;init start: asyncId-$&#123;asyncId&#125;, type-$&#123;type&#125;, triggerAsyncId-$&#123;triggerAsyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    before(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;before: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    after(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;after: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;destroy: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动跟踪</span><br><span class="line">asyncHooks.enable()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; asyncHooks.disable()</span><br></pre></td></tr></table></figure><p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20191218171717821.png" alt="在这里插入图片描述"></p><ul><li><p>async_hooks.createHook(callbacks)<br>  创建一个hook，初始化hook的声明周期的工厂方法。<br>  用来跟踪应用中的异步资源，当资源在被初始化，回调之前，回调之后，销毁后，自动触发init，before，after，destory。</p></li><li><p>asyncHooks.enable()<br>  启用跟踪</p></li><li><p>asyncHooks.disable()<br>  关闭跟踪</p></li><li><p>init(asyncId, type, triggerAsyncId, resource)<br>  asyncId：代表当前异步资源的ID，每个异步资源都会生成一个唯一性标志；<br>  type：表示该资源的类型；<br>  triggerAsyncId：调用者的asyncId，即触发当前异步资源被创建的对应的async scope的asyncid；<br>  resource：被初始化的异步资源包含的一些信息；</p></li><li><p>before(asyncId)<br>  在asyncId对应的异步资源操作完成后，准备执行回调函数前被调用，由回调的次数决定执行的次数。</p></li><li><p>after(asyncId)<br>  异步资源操作完成后立即被调用。</p></li><li><p>destroy(asyncId)<br>  asyncid被销毁时调用</p></li><li><p>promiseResolve(asyncId)</p></li><li><p>async_hooks.executionAsyncId()<br>  当前异步资源的ID</p></li><li><p>async_hooks.triggerAsyncId()<br>  调用者的ID</p></li></ul><ul><li>Promise执行跟踪<br>  PromiseResolve(asyncId)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1729).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;Promise resolve: executionAsyncId: $&#123;async_hooks.executionAsyncId()&#125;, triggerAsyncId: $&#123;async_hooks.triggerAsyncId()&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJs之assert</title>
      <link href="/articles/2020-02-01-node-assert.html"/>
      <url>/articles/2020-02-01-node-assert.html</url>
      
        <content type="html"><![CDATA[<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>断言模块，断言测试、用于测试不变量；<br>发现代码问题、定位问题；<br>对代码的可维护性、代码重构及后期功能扩展有重要意义；</p><a id="more"></a><ul><li><p>assert.AssertionError类<br>表明断言的失败，assert所有的错误都是AssertionError类的实例。</p></li><li><p>严格模式：严格相等和不相等判断<br>严格相等满足‘===’<br>assert.deepEqual(actual, expected[, message])</p></li><li><p>相等和不相等判断<br>assert.equal(actual, expected[, message])</p></li><li><p>深度匹配和不匹配判断<br>assert.deepEqual(actual, expected[,message])<br>assert.notDeepEqual(actual, expected[,message])</p></li><li><p>错误：抛出断言异常<br>assert.fail([message])</p></li><li><p>抛出异常<br>assert.throws(fn[, error][,message])</p></li><li><p>判断是否为假<br>assert.ifError(value)</p></li><li><p>判断是否为真<br>assert.ok(value[, message])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; AssertionError: 假值</span><br><span class="line">assert.ok(false, &#39;假值&#39;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程常用的工具汇总</title>
      <link href="/articles/2020-01-31-code-tools.html"/>
      <url>/articles/2020-01-31-code-tools.html</url>
      
        <content type="html"><![CDATA[<p>1、在线工具汇总：<a href="https://tool.lu；" target="_blank" rel="noopener">https://tool.lu；</a><br>2、草料二维码生成器：<a href="https://cli.im/text；" target="_blank" rel="noopener">https://cli.im/text；</a><br>3、正则表达式工具：<a href="https://tool.lu/regex/；" target="_blank" rel="noopener">https://tool.lu/regex/；</a><br>4、JSON在线解析及格式化验证：<a href="https://www.json.cn；" target="_blank" rel="noopener">https://www.json.cn；</a><br>5、在线编码转换：<a href="http://tool.oschina.net/encode?type=4；" target="_blank" rel="noopener">http://tool.oschina.net/encode?type=4；</a></p>]]></content>
      
      
      <categories>
          
          <category> code-tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> code-tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决出现Cannot find module &#39;XXX’的错误</title>
      <link href="/articles/2020-01-31-node-cannot-find-module.html"/>
      <url>/articles/2020-01-31-node-cannot-find-module.html</url>
      
        <content type="html"><![CDATA[<p>在进行webpack打包的时候，会出现Cannot find module ‘XXX’的错误，找不到某个模块的错误，今天给出解决方法：</p><p>1、直接进行npm install重新打包；<br>2、如果npm install重新打包之后，仍然出现这个问题，可以进行删除node_modules文件夹，同时清除缓存，如下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line"></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>删除node_modules文件夹</title>
      <link href="/articles/2020-01-31-node-modules.html"/>
      <url>/articles/2020-01-31-node-modules.html</url>
      
        <content type="html"><![CDATA[<p>有时候很难直接删除node_modules文件夹，以下提供两种删除node_modules文件夹的方法：<br>1、如果能够直接右击鼠标删除文件夹，则直接执行删除 ；<br>2、否则</p><ul><li><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install rimraf -g</span><br></pre></td></tr></table></figure></li><li><p>执行删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> node_modules </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node_modules </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/articles/2020-01-30-git.html"/>
      <url>/articles/2020-01-30-git.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clone远程工程：</span><br><span class="line">    git clone https:&#x2F;&#x2F;xxxx.git</span><br><span class="line"></span><br><span class="line">fetch远程分支到本地某分支：</span><br><span class="line">    git fetch origin &lt;originname&gt;:&lt;clonename&gt;</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">查看分支：</span><br><span class="line">    git branch</span><br><span class="line"></span><br><span class="line">查看远程所有分支：</span><br><span class="line">    git branch -r</span><br><span class="line"></span><br><span class="line">查看本地和远程所有分支：</span><br><span class="line">    git branch -a</span><br><span class="line"></span><br><span class="line">创建分支：</span><br><span class="line">    git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：</span><br><span class="line">    git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建并切换分支：</span><br><span class="line">    git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：</span><br><span class="line">    git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">把分支推送到远程：</span><br><span class="line">    git push origin &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除本地分支：</span><br><span class="line">    git branch (-d|-D) &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除远程分支：</span><br><span class="line">    git push origin -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line">分支重命名：</span><br><span class="line">    git branch (-m|-M) &lt;oldbranch&gt; &lt;newbranch&gt;</span><br><span class="line"></span><br><span class="line">查看分支最近一次的修改列表：</span><br><span class="line">    git status</span><br><span class="line"></span><br><span class="line">查看分支的commit信息（倒序）：</span><br><span class="line">    git log: (commit id,Author,Date,Commit info)；</span><br><span class="line">    git shortlog:按提交者分类显示所有提交信息；</span><br><span class="line">    git log --online:只输出commit id和commit info；</span><br><span class="line">    git log --stat：查看增删改查了哪些文件；</span><br><span class="line"></span><br><span class="line">版本回退：</span><br><span class="line">    回退到上一版本：git reset --hard HEAD^</span><br><span class="line">    回退到上上版本：git reset --hard HEAD^^</span><br><span class="line">                 git reset --hard HEAD~2</span><br><span class="line">    回退到某个版本：git reset --hard &lt;commit id&gt;</span><br><span class="line">    强制推送到远程分支：git push -f</span><br><span class="line"></span><br><span class="line">    注意：</span><br><span class="line">        HEAD：指向的版本是当前版本，^表示上一个版本，~N表示上N个版本，&lt;commit id&gt;可简写</span><br><span class="line">        git log：查看&lt;commit id&gt;</span><br><span class="line">        git reflog:查看命令历史，回退到某个未来的版本；</span><br><span class="line"></span><br><span class="line">文件增加、提交、拉取、推送、比对、合并</span><br><span class="line">    添加新增文件：git add README.md</span><br><span class="line">    添加所有新增文件：git add .</span><br><span class="line">    暂存变更文件：git stash [save &quot;暂存备注&quot;]</span><br><span class="line">    恢复暂存文件：git stash pop</span><br><span class="line">    提交变更文件：git commit -m &quot;变更备注&quot;</span><br><span class="line">    拉取远程代码：git pull [origin &lt;name&gt;]</span><br><span class="line">    推送到远程：git push origin &lt;name&gt;</span><br><span class="line">    比对两个分支：git diff &lt;name1&gt; &lt;name2&gt;</span><br><span class="line">    比对两个分支变更的文件列表：git diff &lt;name1&gt; &lt;name2&gt; --stat</span><br><span class="line">    比对本地和远程分支：git diff &lt;name&gt; origin&#x2F;&lt;name&gt;</span><br><span class="line">    合并某个分支：git merge &lt;name&gt;</span><br><span class="line">    强制覆盖本地分支：  </span><br><span class="line">        git fetch --all</span><br><span class="line">        git reset  --hard origin&#x2F;&lt;name&gt;</span><br><span class="line">        git pull</span><br><span class="line"></span><br><span class="line">常用选项和其他命令</span><br><span class="line">    git中部分选项解释</span><br><span class="line">        -f --force：强制</span><br><span class="line">        -d --delete：删除</span><br><span class="line">        -D --delete --force</span><br><span class="line">        -m --move：移动或重命名</span><br><span class="line">        -M --remote：远程</span><br><span class="line">        -a --all：所有</span><br><span class="line"></span><br><span class="line">    其他命令</span><br><span class="line">        清空工程：</span><br><span class="line">            $ git rm -rf .</span><br><span class="line">        每隔X秒运行一次git pull：</span><br><span class="line">            $ for((i&#x3D;1;i&lt;&#x3D;10000;i+&#x3D;1)); do sleep X &amp;&amp; git pull; done</span><br><span class="line">        使用git rebase将一个feature分支变基到master分支</span><br><span class="line">            $ git checkout feature</span><br><span class="line">            $ git rebase master</span><br><span class="line"></span><br><span class="line">配置相关:</span><br><span class="line">    查看当前配置：  git config --list</span><br><span class="line">    修改git的name和email：</span><br><span class="line">        git config --global user.name &lt;name&gt;</span><br><span class="line">        git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Hexo+github进行搭建博客</title>
      <link href="/articles/2020-01-29-hexo.html"/>
      <url>/articles/2020-01-29-hexo.html</url>
      
        <content type="html"><![CDATA[<p>Hexo+github搭建博客步骤：</p><ol><li>git账号创建</li><li>node环境搭建</li><li>安装Hexo</li><li>github创建个人仓库</li><li>hexo部署到github</li><li>个人域名</li><li>发布文章<a id="more"></a></li></ol><h4 id="1-git账号创建"><a href="#1-git账号创建" class="headerlink" title="1. git账号创建"></a>1. git账号创建</h4><p>git官网上可以注册创建一个账号。</p><h4 id="2-node环境搭建"><a href="#2-node环境搭建" class="headerlink" title="2. node环境搭建"></a>2. node环境搭建</h4><p>安装node和npm，查看node是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install nodejs</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure><h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h4><ul><li><p>安装hexo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li><li><p>初始化一个boke</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line">cd my-blog</span><br></pre></td></tr></table></figure></li><li><p>成功后，可看到文件目录<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p></li><li><p>部署后，打开服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>本地的<a href="localhost:4000">localhost:4000</a>就可以访问你生成的博客了。</p></li></ul><h4 id="4-github创建个人仓库"><a href="#4-github创建个人仓库" class="headerlink" title="4. github创建个人仓库"></a>4. github创建个人仓库</h4><p>github官网创建好账号之后，新建一个仓库：用户名.github.io</p><h4 id="5-hexo部署到github"><a href="#5-hexo部署到github" class="headerlink" title="5. hexo部署到github"></a>5. hexo部署到github</h4><ul><li><p>将hexo和github关联起来，需要修改配置文件_config.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;git名&#x2F;git用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>此时需要安装deploy-git，即部署命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除之前的东西</span><br><span class="line">hexo g  &#x2F;&#x2F; 生成静态文章</span><br><span class="line">hexo d  &#x2F;&#x2F; 部署文章</span><br></pre></td></tr></table></figure><p>执行完成后，就可以在<a href="https://github.com/git名/git用户名.github.io.git" target="_blank" rel="noopener">https://github.com/git名/git用户名.github.io.git</a>看到博客了。</p></li></ul><h4 id="6-个人域名"><a href="#6-个人域名" class="headerlink" title="6. 个人域名"></a>6. 个人域名</h4><p>需要自己去买个域名，在阿里云，买好域名后：<br>需要进行解析域名，解析时把地址指向你的github的地址。</p><p>登录github后，进入刚刚创建的仓库，点击settings，设置Custom domain，输入你的域名地址。<br>并且在my-blog项目下的source中创建一个名为CNAME的文件，把域名加入。<br>最后一步再进行部署，此时访问你的域名就可以看到你的博客了</p><h4 id="7-发布文章"><a href="#7-发布文章" class="headerlink" title="7. 发布文章"></a>7. 发布文章</h4><p>创建标签或自定义文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &#39;name&#39;</span><br></pre></td></tr></table></figure><p>写文章：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new pageName</span><br></pre></td></tr></table></figure><p>部署：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 搭建博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
