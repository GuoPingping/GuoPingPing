<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>English</title>
    <url>/articles/2020-02-22-interview-english.html</url>
    <content><![CDATA[<a id="more"></a>

<p>Thank you for giving me this opportunity for this interview</p>
<p>My name is guopp , and from zhoukou, a city in HeNan provixe<br>I am 26 years old, born inb Henan Provice.</p>
<p>I think I’m a good team player in project teams.<br>and so on<br>during my college yearss</p>
<p>there’s all thank you<br>Team player  善于团队协作<br>motivated 积极的 [ˈməʊtɪveɪtɪd]<br>Helpfulness and caring.<br>Adaptability and sense of humor.<br> friendliness.<br>  I like people who possess the “can do” spirit.</p>
<p>I gained many skills and experiences</p>
<blockquote>
<p>what is your greatest strength?<br>I feel that my strengest asset is my ability to stick to things to get them done.<br>what is your greatest weakness?<br>I am such a perfectionist that i will not stop until a job is well done</p>
</blockquote>
<blockquote>
<p>Do you think you are introverted or extroverted?（introverted[ˈɪntrəvɜːtɪd]）<br>i am quite outgoing, i think<br>I wouldn’t call myself introverted though sometimes I’m reserved and enjoy staying all by myself，often and often I like sharing activities with others．</p>
</blockquote>
<blockquote>
<p>How do you get along with others？<br>I keep close contacts with my friends．(contacts[ˈkɒntækt]),We often get together and talk with each other</p>
</blockquote>
<blockquote>
<p>Which schools have you attended？<br>i graduated from Shanghai Second Polytechnic University（Polytechnic[ˌpɒliˈteknɪk]）in 2017（two thousand and seventeen）</p>
</blockquote>
<blockquote>
<p>what’s your major in university<br>software engineering</p>
</blockquote>
<blockquote>
<p>Have you received any certificates ?</p>
</blockquote>
<blockquote>
<p>Have you got any experience in advertisting</p>
</blockquote>
<blockquote>
<p>I am someone who can adapt to any situation</p>
</blockquote>
<blockquote>
<p>If hired , when could you start work?<br>We’ll notify you as soon as possible, when can you start working if we decide to use you ?<br>I’d like to begin to work any time you want<br>when I accepted, i will do my best for the company </p>
</blockquote>
<blockquote>
<p>what do you look for in the job ?<br>what advantages are you seeking from this change of job ?<br>I am hoping to get an offer of a better position, if opportunity knocks, i will take it.</p>
</blockquote>
<blockquote>
<p>what do you want to get from your new job?<br>what do you expect from this job?<br>what is important to you in your job?</p>
</blockquote>
<blockquote>
<p>What’s your marital status ?<br>what’s your plan for the future?<br>what’s your long-range career objective?<br>Do you have a clear career path to follow?<br>What are you long-term goals set for youself?<br>There is no hurry to get married, In order to achieve this goal, I just want to work step by step.<br>I wish to move up to higher positions with acquisition of more experience in the future.<br>I plan to continue working for a long time, My career is the most important to me.<br>I hope to command a skill, to set a solid foundation and to build my interpersonal network.</p>
</blockquote>
<blockquote>
<p>Any other questions ?<br>May I ask about the salary?<br>Do you mind if I ask abount the wages?<br>Are there any additional year-end bonuses?<br>What starting salary would you expect here?<br>The salary I should require would be 21000 a month </p>
</blockquote>
<blockquote>
<p>Could you pleasse tell me something about the wages?<br>I’d like to have the salary which matches my ability<br>I should require a commencing salary of 21000 Yuan a month.<br>Based on my skills and experience, I am looking for 21000 yuan a month.</p>
</blockquote>
<p>Good afternoon,my dear manager !</p>
<p>My name is wang guipeng,I’m very happy and excited for having a face to face interview in your company.</p>
<p> I hope i can make a good performance today.Now I would like to introduce myself briefly.</p>
<p>I am 29 years old,born in Anhui province,graduated from the north university of china.</p>
<p>My major is Software Engneering,and i got my bachelor degree after my graduation in the year of 2013.</p>
<p>I hava about 5 years work experience,I worked for my first company as a technical support engineer,and I worked for my second company as a function/automation/perfomance test engineer.</p>
<p>During my tenure, I participated in the skills competition organized by Huawei and won the first place.</p>
<p>In my daily life,I’m fond of hiking,party,writing blogs.</p>
<p>I think I’m a good team player and I’m a person of great honesty to others.Also I am able to work under great pressure.</p>
<p>all right.thank you for giving me the chance!</p>
<p>After graduation, I spent two companies<br>The first company is to be a Java programmer<br>In life, my personality sunlight, cheerful, like to listen to music, read a book;<br>Work is responsible earnestly, positive initiative, can bear hardships and stand hard work, self-motivated, diligently study, can constantly  improve their ability and comprehensive quality.</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Rabbitmq</title>
    <url>/articles/2020-02-16-interview-rabbitmq.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-Rabbitmq"><a href="#1-Rabbitmq" class="headerlink" title="1. Rabbitmq"></a>1. Rabbitmq</h4><p>采用AMQP高级消息队列协议的一种消息队列技术，<br>最大的特点就是消费并不需要确保提供方存在，实现了服务之间的高度解耦。</p>
<p>解耦、异步、削峰</p>
<h5 id="1-1-解耦"><a href="#1-1-解耦" class="headerlink" title="1.1 解耦"></a>1.1 解耦</h5><p>传统模式：<br>缺点：系统间耦合性太强</p>
<p>中间件模式：<br>优点：将消息写入消息列表，需要消息的系统自己从消息队列中订阅，从而系统A不需要做任何修改。</p>
<h5 id="1-2-异步"><a href="#1-2-异步" class="headerlink" title="1.2 异步"></a>1.2 异步</h5><p>传统模式：<br>缺点：一些非必要的业务逻辑以同步的方式运行，太耗费时间。</p>
<p>中间件模式：<br>优点：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度；</p>
<h5 id="1-3-削峰"><a href="#1-3-削峰" class="headerlink" title="1.3 削峰"></a>1.3 削峰</h5><p>传统模式：<br>缺点：并发量大的时候，所有的请求直接怼到数据库，造成数据库连接异常；</p>
<p>中间件模式：<br>优点：系统A慢慢的按照数据库能处理的并发量，从消息队列中慢慢拉取消息。在生产中，这个短暂的高峰期积压是允许的。</p>
<h4 id="2-为什么要使用rabbitmq"><a href="#2-为什么要使用rabbitmq" class="headerlink" title="2. 为什么要使用rabbitmq"></a>2. 为什么要使用rabbitmq</h4><ul>
<li>在分布式系统下具备异步、削峰、负载均衡等一系列高级功能；</li>
<li>拥有持久化的机制，进程消息、队列中的消息也可以保存下来；</li>
<li>实现消费者和生产者之间的解耦；</li>
<li>对于高并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作；</li>
<li>可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单</li>
</ul>
<h4 id="3-使用rabbitmq的场景"><a href="#3-使用rabbitmq的场景" class="headerlink" title="3. 使用rabbitmq的场景"></a>3. 使用rabbitmq的场景</h4><ul>
<li>服务间异步通信</li>
<li>顺序消费</li>
<li>定时任务</li>
<li>请求削峰</li>
</ul>
<h4 id="4-如何确保消息正确的发送至rabbitmq？如何确保消息接收方消费了消息？"><a href="#4-如何确保消息正确的发送至rabbitmq？如何确保消息接收方消费了消息？" class="headerlink" title="4. 如何确保消息正确的发送至rabbitmq？如何确保消息接收方消费了消息？"></a>4. 如何确保消息正确的发送至rabbitmq？如何确保消息接收方消费了消息？</h4><h5 id="发送方确认模式"><a href="#发送方确认模式" class="headerlink" title="发送方确认模式"></a>发送方确认模式</h5><p>将信道设置成confirm模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的ID。<br>一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一ID）。<br>如果Rabbitmq发生内部错误从而导致消息丢失，会发送一条nack（not ack nowledged,未确认）消息。<br>发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息达到生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</p>
<h5 id="接收方确认机制"><a href="#接收方确认机制" class="headerlink" title="接收方确认机制"></a>接收方确认机制</h5><p>消费者接收每一条消息后都必须进行确认（消息接收和确认是两个不同操作）。只有消费者确认了消息，Rabbitmq才能安全的把消息从队列中删除。</p>
<p>这里并没有用到超时机制，Rabbitmq仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，Rabbitmq给了Consumer足够长的时间来处理消息。保证数据的最终一致性；</p>
<p>下面几种特殊情况：</p>
<ul>
<li>如果消费者接收到消息，在确认之前断开了连接或取消订阅，Rabbitmq会认为消息没有被分发，然后重新分发给下一个订阅的消费者。（可能存在消息重复消费的隐患，需要去重）。</li>
<li>如果消费者接收到消息却没有确认消息，连接也未断开，则Rabbitmq认为消费者繁忙，将不会给消费者分发更多的消息。</li>
</ul>
<h4 id="5-如何避免消息重复投递或重复消费？"><a href="#5-如何避免消息重复投递或重复消费？" class="headerlink" title="5. 如何避免消息重复投递或重复消费？"></a>5. 如何避免消息重复投递或重复消费？</h4><p>在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进入队列；<br>在消息消费时，要求消息体中必须要有一个bixId（对于同一业务全局的唯一，如支付ID、订单ID、帖子ID等）作为去重的依据，避免同一条消息被重复消费。</p>
<h4 id="6-消息基于什么传输"><a href="#6-消息基于什么传输" class="headerlink" title="6. 消息基于什么传输"></a>6. 消息基于什么传输</h4><p>由于TCP连接的创建和销毁开销较大，且并发受系统资源限制，会造成性能瓶颈。<br>Rabbitmq使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。</p>
<h4 id="7-消息如何分发"><a href="#7-消息如何分发" class="headerlink" title="7. 消息如何分发"></a>7. 消息如何分发</h4><p>若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消息者（前提是消费者能够正常处理消息并进行确认）。通过路由可实现多消费的功能。</p>
<h4 id="8-消息怎么路由"><a href="#8-消息怎么路由" class="headerlink" title="8. 消息怎么路由"></a>8. 消息怎么路由</h4><p>消息提供方 -》 路由 -》 一到多个队列消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。通过队列路由键，可以把队列绑定到交换器上。消息到达交换器后，Rabbitmq会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）；</p>
<p>常见的交换器有三种：</p>
<ul>
<li>fanout：如果交换器收到消息，就会广播到所有绑定的队列上；</li>
<li>direct：如果路由键完全匹配，消息就被投递到相应的队列；</li>
<li>topic：可以使来自不同源头的消息能够达到同一个队列。使用topic交换器时，可以使用通配符；</li>
</ul>
<h4 id="9-如何确保消息不丢失？"><a href="#9-如何确保消息不丢失？" class="headerlink" title="9. 如何确保消息不丢失？"></a>9. 如何确保消息不丢失？</h4><p>消息持久化，当前前提是队列必须持久化</p>
<p>Rabbitmq确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久化消息到持久交换器上时，Rabbitmq会在消息提交到日志文件后才发送响应。一旦消费者从持久队列中消费了一条持久化消息，Rabbitmq会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前Rabbitmq重启，那么Rabbit会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。</p>
<h4 id="10-使用Rabbitmq有什么好处"><a href="#10-使用Rabbitmq有什么好处" class="headerlink" title="10. 使用Rabbitmq有什么好处"></a>10. 使用Rabbitmq有什么好处</h4><ul>
<li>服务间高度解耦</li>
<li>异步通信性能高</li>
<li>流量削峰</li>
</ul>
<h4 id="11-Rabbitmq的集群"><a href="#11-Rabbitmq的集群" class="headerlink" title="11. Rabbitmq的集群"></a>11. Rabbitmq的集群</h4><p>镜像集群模式<br>你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。<br>好处在于，你任何一个机器宕机了，没事，别的机器都可以用。<br>坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重；第二，这么玩，没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。</p>
<h4 id="12-mq的缺点"><a href="#12-mq的缺点" class="headerlink" title="12. mq的缺点"></a>12. mq的缺点</h4><ul>
<li>系统可用性降低<br>系统引入的外部依赖较多，就容易挂掉，本来你就是A，系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没问题，如果加个mq进来，如果mq挂了，整套系统就崩溃了。</li>
<li>系统复杂性提高<br>加个mq，如何保证消息没有重复消费？如何处理消息丢失情况？如何保证消息传递的顺序性？</li>
<li>一致性问题<br>A系统处理完了直接返回成功了，人都以为这个请求成功了；但问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，数据就不一致了。</li>
</ul>
<p>所以消息队列实际是一种非常复杂的架构，引入有很多好处，但也得针对它带来的坏处做各种额外的技术方案和架构来规避掉。</p>
<h4 id="13-消息队列如何选型"><a href="#13-消息队列如何选型" class="headerlink" title="13. 消息队列如何选型"></a>13. 消息队列如何选型</h4>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/articles/2020-02-12-interview-ES6.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-let-var的区别"><a href="#1-let-var的区别" class="headerlink" title="1. let var的区别"></a>1. let var的区别</h4><p>let声明的变量</p>
<ul>
<li>不能重复声明</li>
<li>作用域为该语句所在的代码块内</li>
<li>不存在变量提升(会报错)</li>
<li>存在暂时性死域（只能先声明再使用）</li>
</ul>
<p>var声明的变量</p>
<ul>
<li>能重复声明</li>
<li>作用域为该语句所在的函数内</li>
<li>存在变量提升(变量可以在声明之前使用，值为undefined)；</li>
</ul>
<h4 id="2-WeakMap和Map的区别？"><a href="#2-WeakMap和Map的区别？" class="headerlink" title="2. WeakMap和Map的区别？"></a>2. WeakMap和Map的区别？</h4><p>WeakMap和Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>最大的好处是可以避免内存泄漏。一个仅被WeakMap作为key而引用的对象，会被垃圾回收期回收掉。<br>WeakMap有和Map类似的set(key, value), get(key), has(key), delete(key)和clear()方法，没有任何与迭代有关的属性和方法。</p>
<h4 id="3-ES6模块加载"><a href="#3-ES6模块加载" class="headerlink" title="3. ES6模块加载"></a>3. ES6模块加载</h4><p>ES6 实现了模块功能，将文件当作独立的模块，一个文件一个模块。<br>每个模块可以导出自己的API成员，也可以导入其他模块或者模块中特定的API</p>
<p>ES6 模块的设计思想：是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。</p>
<p>CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。<br>所以编译期会检查对导入模块的API或成员的引用</p>
<p>模块有两个主要特征：</p>
<ul>
<li>为创建内部作用域而调用了一个包装函数</li>
<li>包装函数的返回值至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包</li>
</ul>
<h4 id="4-require、exports、module-exports、import、export"><a href="#4-require、exports、module-exports、import、export" class="headerlink" title="4. require、exports、module.exports、import、export"></a>4. require、exports、module.exports、import、export</h4><p>使用范围：</p>
<ul>
<li>require：node 和 es6 都支持的引入</li>
<li>module.exports / exports：只有 node 支持的导出</li>
<li>export / import：只有es6 支持的导出引入</li>
</ul>
<p>在node模块里是遵循CommonJS规范的，执行模块文件时，会同时生成一个module对象和一个exports对象，<br>module对象又有一个exports属性，他们初始化时指向同一块{}内存区域，<br>注意是同一块，即exports对象是module.exports的引用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; test.js</span><br><span class="line">var module.exports &#x3D; &#123;&#125;;</span><br><span class="line">var exports &#x3D; module.exports;</span><br><span class="line">console.log(module.exports);         &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">console.log(exports);                &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">exports.name &#x3D; 2;</span><br><span class="line">console.log(module.exports);         &#x2F;&#x2F; &#123;name: 2&#125;</span><br><span class="line">console.log(exports);                &#x2F;&#x2F; &#123;name: 2&#125;</span><br><span class="line"></span><br><span class="line">var exports &#x3D; &#123;name: 3&#125;;</span><br><span class="line">console.log(module.exports);         &#x2F;&#x2F; &#123;name: 2&#125;</span><br><span class="line">console.log(exports);                &#x2F;&#x2F; &#123;name: 3&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：其实require导出的内容是module.exports指向的内存块内容，并不是exports的。<br>区分他们之间的区别就是exports只是module.exports的引用，辅助后者添加内容用的。<br>当其中一个指向另一块内存时，两者便没什么关系了。</p>
<h4 id="5-CommonJS中require-exports和ES6中import-export区别"><a href="#5-CommonJS中require-exports和ES6中import-export区别" class="headerlink" title="5. CommonJS中require/exports和ES6中import/export区别"></a>5. CommonJS中require/exports和ES6中import/export区别</h4><p>CommonJS模块的重要特性是加载时执行，及脚本代码在require的时候，就会全部执行。<br>一旦出现某个模块被“循环加载”就只输出已经执行的部分，还没有执行的部分是不输出的。</p>
<p>ES6模块的动态引用，如果使用import从一个模块加载变量，那些变量不会缓存，而是成为<br>一个指向被加载模块的引用。需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>import/export最终都是编译为require/exports来执行的</p>
<p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p>
<p>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p>
<h4 id="6-几种常见模块化规范的简介"><a href="#6-几种常见模块化规范的简介" class="headerlink" title="6. 几种常见模块化规范的简介"></a>6. 几种常见模块化规范的简介</h4><p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的。</p>
<p>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难。</p>
<p>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Nodejs中运行。</p>
<p>ES6在语言标椎的层面上，实现了模块功能，而且实现的相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<h4 id="7-模块化开发是怎么做的？"><a href="#7-模块化开发是怎么做的？" class="headerlink" title="7. 模块化开发是怎么做的？"></a>7. 模块化开发是怎么做的？</h4><p>使用命名空间</p>
<h4 id="8-ES5的defineProperty"><a href="#8-ES5的defineProperty" class="headerlink" title="8. ES5的defineProperty"></a>8. ES5的defineProperty</h4><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，<br>并返回这个对象。</p>
<h4 id="9-map、each、some、forEach"><a href="#9-map、each、some、forEach" class="headerlink" title="9. map、each、some、forEach"></a>9. map、each、some、forEach</h4><ul>
<li><p>map<br>map遍历数组，克隆原数组，对新数组进行操作并返回一个新的数组，滥用map会造成内存浪费；<br>有return；</p>
</li>
<li><p>each<br>返回原来的数组，不会创建一个新的数组；<br>无return；</p>
</li>
<li><p>every<br>当内部return false时跳出整个循环；<br>有一项不满足元素，则整个表达式返回false，剩余元素不再执行；</p>
</li>
<li><p>some<br>当内部return true时跳出整个循环；<br>有一个元素满足条件，则表达式返回true，剩余元素不再执行；</p>
</li>
<li><p>foreach<br>没有返回值；<br>对原本数组进行操作；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var array &#x3D; [1,2,3,4,5];  </span><br><span class="line">var res &#x3D; _.forEach(array, function (item,index,input) &#123;  </span><br><span class="line">       input[index] &#x3D; item*10;  </span><br><span class="line">&#125;)  </span><br><span class="line">console.log(res);&#x2F;&#x2F;&#x3D;&gt;undefined</span><br><span class="line">console.log(array);&#x2F;&#x2F;&#x3D;&gt;[10,20,30,40,50]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var res &#x3D; _.map(array, function (item,index,input) &#123;  </span><br><span class="line">       input[index] &#x3D; item*10;  </span><br><span class="line">&#125;)  </span><br><span class="line">console.log(res);&#x2F;&#x2F;&#x3D;&gt;[10,20,30,40,50]</span><br><span class="line">console.log(array);&#x2F;&#x2F;&#x3D;&gt;[1,2,3,4,5]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>linux</title>
    <url>/articles/2020-02-11-linux.html</url>
    <content><![CDATA[<h4 id="1-常用操作及概念"><a href="#1-常用操作及概念" class="headerlink" title="1. 常用操作及概念"></a>1. 常用操作及概念</h4><p>Tab：命令和文件名补全；</p>
<p>Ctrl + C：中断正在运行的程序；</p>
<p>Ctrl + D：结束键盘输入</p>
<a id="more"></a>

<p>man<br>man date</p>
<p>info：将文档分成一个个页面，每个页面可以进行跳转；</p>
<p>doc：/usr/share/doc 存放着软件的一整套说明文件;</p>
<p>who：查看有没有其它用户在线；</p>
<p>sync：为了加快磁盘文件的读写速度，位于内存中的文件数据不会立即<br>同步到磁盘上，因此关机之前需要先进行sync同步操作；</p>
<ul>
<li><p>修改权限<br>  r：4，w：2，x:1<br>  chmod  [-R] xyz dirname/filename</p>
</li>
<li><p>默认权限<br>  文件默认：666，-rw-rw-rw-<br>  目录默认：777，drwxrwxrwx</p>
</li>
<li><p>获取文件内容<br>  cat：取得文件内容<br>  tac：是cat反向操作，从最后一行开始打印<br>  more：一页一页查看文件内容<br>  less：向前翻页<br>  head：head [-n number] filename 取得文件前几行<br>  tail：取得文件最后几行<br>  od：以字符或十六进制的形式显示二进制文件</p>
</li>
<li><p>指令与文件搜索<br>  which：指令搜索 which [-a] command<br>  whereis：文件搜索，速度比较快，因为它只搜索几个特定的目录<br>  locate：文件搜索，可以用正则或关键字搜索<br>  find：文件搜索，可以使用文件的属性和权限进行搜索</p>
</li>
<li><p>正则表达式<br>  grep<br>  grep -n ‘the’ regular_express.txt</p>
<p>  last<br>  last -n 5</p>
<p>  ps：查看某个时间点的进程信息<br>  ps -l：查看自己的进程<br>  ps aux：查看系统所有进程</p>
<p>  top：实时查看进程信息<br>  top -d 2：两秒钟刷新一次</p>
<p>  netstat：查看占用端口的进程<br>  netstat -anp | grep port</p>
</li>
</ul>
<h4 id="2-目录配置"><a href="#2-目录配置" class="headerlink" title="2. 目录配置"></a>2. 目录配置</h4><p>/ : root，根目录；<br>/usr（unix software resource）: 所有系统默认软件都会安装到这个目录；<br>/var（variable）：存放系统或程序运行过程中的数据文件；</p>
<h4 id="3-进程"><a href="#3-进程" class="headerlink" title="3. 进程"></a>3. 进程</h4><ul>
<li><p>孤儿进程<br>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。<br>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。<br>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
</li>
<li><p>僵尸进程<br>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。<br>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。<br>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。<br>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统原理</title>
    <url>/articles/2020-02-11-dataBase.html</url>
    <content><![CDATA[<h4 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h4><p>能满足ACID特性的一组操作，可以通过commit提交一个事务，也可以用Rollback进行回滚。</p>
<a id="more"></a>

<h5 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h5><ul>
<li>A原子性(Atomicity)<br>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚；<br>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li>
<li>C一致性(Consistency)<br>数据库在事务执行前后都保持一致性状态。<br>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li>
<li>I隔离性(Isolationn)<br>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li>
<li>D持久性(Durability)<br>一旦事务提交，所做的修改将会蝾螈保存到数据库中。<br>即使系统发生崩溃，事务执行的结果也不能丢失。<br>使用重组日志来保证持久性。</li>
</ul>
<h5 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h5><p>只有满足一致性，事务的执行结果才是正确的；<br>在无并发的情况下，事务串行执行，隔离性一定能够满足，此时只要能满足原子性，一定能满足一致性；<br>在并发情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性；<br>事务满足持久化是为了能应对数据库崩溃的情况；</p>
<h5 id="Autocommit"><a href="#Autocommit" class="headerlink" title="Autocommit"></a>Autocommit</h5><p>mysql默认采用自动提交模式。即不显示使用start transaction语句来开始一个事务，则每个查询都会被当做一个事务自动提交。</p>
<h4 id="2-并发一致性问题"><a href="#2-并发一致性问题" class="headerlink" title="2. 并发一致性问题"></a>2. 并发一致性问题</h4><p>在并发环境下，事务的隔离性很难保证，因为会出现很多并发一致性的问题。<br>产生并发不一致性问题的主要原因是破坏了事务的隔离性。</p>
<h5 id="解决办法是"><a href="#解决办法是" class="headerlink" title="解决办法是"></a>解决办法是</h5><p>通过并发控制来保证隔离性。<br>并发控制可以通过封锁来实现，但是封锁操作需要用户自己来控制，相当复杂。<br>数据库管理系统提供了事务的隔离级别，让用户以一种更轻松的方式处理并发一致性问题。</p>
<h5 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h5><ul>
<li><p>丢失修改；<br>T1和T2两个事务都对同一个数据修改，T1先修改，T2后修改，T2的修改覆盖了T1。</p>
</li>
<li><p>读脏数据；<br>T1修改一个数据，T2随后读取这个数据，如果T1撤销了这次修改，则T2读取的数据是脏数据。</p>
</li>
<li><p>不可重复读；<br>T2读取一个数据，T1修改该数据，如果T2再次读取，则和第一次结果不同。</p>
</li>
<li><p>幻影读；<br>T1读取某个范围的数据，T2在这个范围内插入新的数据，T1再次读取这个范围的数据，此时读取的结果和第一次不同。</p>
</li>
</ul>
<h4 id="3-封锁粒度"><a href="#3-封锁粒度" class="headerlink" title="3. 封锁粒度"></a>3. 封锁粒度</h4><p>mysql提供了两种封锁粒度：行级锁和表级锁。</p>
<p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。<br>锁定的数据量越少，发生锁争用的可能性就越小，系统的并发程度就越高。</p>
<p>加锁需要消耗资源，锁的各种操作(包括获取锁、释放锁、及检查锁状态)都会增加系统开销，因此锁粒度越小，系统开销越大。</p>
<p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p>
<h5 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h5><ul>
<li>读写锁<br>排它锁(Exclusive)：简写X锁，又称写锁；<br>共享锁(Shared)：简写S锁，又称读锁；</li>
</ul>
<p>一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其它事务不能对A加任何锁；<br>一个事务对数据对象A加了S锁，就可以对A进行读取操作，但不能更新。加锁期间其它事务对A加S锁，但不能加X锁；</p>
<p>锁的兼容关系：</p>
<ul>
<li>X S<br>X × ×<br>S × √</li>
</ul>
<ul>
<li>意向锁<br>使用意向锁Intention Locks可以更容易的支持多粒度封锁。</li>
</ul>
<p>在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要检测是否有其他事务对A或A中任意一行加了锁，需要对A每一行都检测一次，比较耗时。</p>
<p>意向锁在原来的x/s锁之上引入了IX/IS，IX/IS都是表锁，表示一个事务想要在表中的某个数据行了加X锁或S锁，规定：<br>一个事务在获得某个数据行对象的S锁之前，必须先获得表的IS锁或更强的锁；<br>一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁；</p>
<p>引入意向锁，事务T对表A加X锁，只需要先检测是否有其他事务对表A加了X/IX/S/IS锁，如果加了，表示有其它事务正在使用这个表或表中某一行的锁，因此事务T加X锁失败。</p>
<p>兼容关系：<br>任意IX/IS之间都是兼容的，因为他们只是表示想要对表加锁，而不是真正的锁；<br>S锁只与S锁和IS锁兼容，即事务T想要对数据进行加S锁，其它事务可以已经获得对表或表中行的S锁；</p>
<ul>
<li>X IX S IS<br>X × × × ×<br>IX × √ × √<br>S × × √ √<br>IS × √ √ √</li>
</ul>
<h5 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h5><p>1、三级封锁协议</p>
<ul>
<li>一级封锁协议<br>事务A要修改数据A时必须加X锁，直到T结束才释放锁</li>
</ul>
<p>可以解决丢失修改的问题，因为不可能同时有两个事务对同一个数据进行修改，那么事务的修改就不会被覆盖。</p>
<ul>
<li>二级封锁协议<br>在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。</li>
</ul>
<p>可以解决读脏数据问题，因为一个事务对数据A进行修改，根据1级封锁协议，会加X锁，那么就不能再加S锁了，也就是不会读入数据。</p>
<ul>
<li>三级封锁协议<br>在二级的基础上，要求读取数据A时必须加S锁，知道事务结束才能释放S锁。</li>
</ul>
<p>可以解决不可重复读的问题，因为读A时，其它事务不能对A加X锁，从而避免了在读的期间数据发生改变。</p>
<p>2、两段锁协议<br>加锁和解锁分两个阶段进行。</p>
<p>可串行化调度：通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。</p>
<p>事务遵循两段锁协议是保证可串行化调度的充分条件。<br>但不是必要条件</p>
<h5 id="mysql隐式与显示锁定"><a href="#mysql隐式与显示锁定" class="headerlink" title="mysql隐式与显示锁定"></a>mysql隐式与显示锁定</h5><p>mysql的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，且所有的锁都在同一时刻释放，这被称为隐式锁定。</p>
<h4 id="4-隔离级别"><a href="#4-隔离级别" class="headerlink" title="4. 隔离级别"></a>4. 隔离级别</h4><h5 id="未提交读（Read-Uncommited）"><a href="#未提交读（Read-Uncommited）" class="headerlink" title="未提交读（Read Uncommited）"></a>未提交读（Read Uncommited）</h5><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p>
<h5 id="提交读（Read-commited）"><a href="#提交读（Read-commited）" class="headerlink" title="提交读（Read commited）"></a>提交读（Read commited）</h5><p>一个事务只能读取已经提交的事务所做的修改。<br>即一个事务所做的修改在提交之前对其它事务是不可见的。</p>
<h5 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h5><p>保证在同一个事务中多次获取同样数据的结果是一样的。</p>
<h5 id="可串行化（Serializable）"><a href="#可串行化（Serializable）" class="headerlink" title="可串行化（Serializable）"></a>可串行化（Serializable）</h5><p>强制事务串行执行。<br>需要加锁实现，而其它隔离级别通常不需要。</p>
<p>隔离级别 脏读 不可重复读 幻影读<br>未提交读 √ √ √<br>提交读 × √ √<br>可重复读 × × √<br>可串行化 × × ×</p>
<h4 id="5-多版本并发控制"><a href="#5-多版本并发控制" class="headerlink" title="5. 多版本并发控制"></a>5. 多版本并发控制</h4><p>多版本并发控制（Multi-Version Concurrency Control，MVCC）<br>是Mysql的InnoDB存储引擎实现隔离级别的一种具体方式，<br>用于实现提交读和可重复读这两种隔离级别。<br>而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。<br>可串行化隔离级别需要对所有读取的行都加锁，单纯使用MVCC无法实现。</p>
<h5 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h5><p>系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。<br>事务版本号：事务开始时的系统版本号。</p>
<h5 id="隐藏的列"><a href="#隐藏的列" class="headerlink" title="隐藏的列"></a>隐藏的列</h5><p>MVCC在每行记录后面都保存着两个隐藏的列，用来存储两个版本号：</p>
<h5 id="创建版本号"><a href="#创建版本号" class="headerlink" title="创建版本号"></a>创建版本号</h5><p>指示创建一个数据行的快照时的系统版本号；<br>删除版本号：<br>如果该快照的删除版本号大于当前事务版本号 表示该快照有效，否则表示该快照已经被删除了。</p>
<h5 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h5><p>MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行（Record）的所有快照连接起来。</p>
<h5 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h5><p>当开始一个事务，该事务的版本号肯定大于当前所有数据行快照的创建版本号。<br>数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都打，也就是比所有数据行快照的创建版本号都大。</p>
<ul>
<li>select</li>
<li>insert</li>
<li>delete</li>
<li>update</li>
</ul>
<h5 id="快照读与当前读"><a href="#快照读与当前读" class="headerlink" title="快照读与当前读"></a>快照读与当前读</h5><p>快照读<br>使用MVCC读取的是快照中的数据，这样可以减少加锁带来的开销；</p>
<p>当前读<br>读取的是最新的数据，需要加锁。</p>
<h4 id="6-Net-Key-Locks"><a href="#6-Net-Key-Locks" class="headerlink" title="6. Net-Key Locks"></a>6. Net-Key Locks</h4><p>Next-Key Locks是mysql的InnoDB存储引擎的一种锁的实现。</p>
<p>MVCC不能解决幻影读的问题，Next-Key Locks就是为解决这个问题。<br>在可重复读的隔离级别下，使用MVCC+Next-key Locks可以解决幻影读问题。</p>
<p>Record Locks<br>锁定一个记录上的索引，而不是记录本身。<br>如果表没有设置索引，InnoDB会自动在主键上创建隐藏的聚簇索引，因此Record Locks依然可以使用</p>
<p>Gap Locks<br>锁定索引之间的间隙，但不包含索引本身</p>
<p>Next-Key Locks<br>是Record Locks和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p>
<h4 id="7-关系数据库设计理论"><a href="#7-关系数据库设计理论" class="headerlink" title="7. 关系数据库设计理论"></a>7. 关系数据库设计理论</h4><h5 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h5><p>记A-&gt;B表示A函数觉得B，也可以说B函数依赖于A。</p>
<p>如果 {A1，A2，… ，An} 是关系的一个或多个属性的集合，该集合函数决定了关系的其它所有属性并且是最小的，那么该集合就称为键码。</p>
<p>对于 A-&gt;B，如果能找到 A 的真子集 A’，使得 A’-&gt; B，那么 A-&gt;B 就是部分函数依赖，否则就是完全函数依赖。</p>
<p>对于 A-&gt;B，B-&gt;C，则 A-&gt;C 是一个传递函数依赖。</p>
<h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p>不符合范式的关系，会产生很多异常：<br>    冗余数据<br>    修改异常<br>    删除异常<br>    插入异常</p>
<h5 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h5><p>范式理论是为了解决以上四种异常。<br>高级别范式的依赖于低级别的范式</p>
<ul>
<li><p>第一范式（1NF）<br>属性不可分</p>
</li>
<li><p>第二范式（2NF）<br>每个非主属性完全函数依赖于键码。<br>可以通过分解来满足。</p>
</li>
<li><p>第三范式（3NF）<br>非主属性不传递函数依赖于键码。</p>
</li>
</ul>
<h4 id="8-ER图"><a href="#8-ER图" class="headerlink" title="8. ER图"></a>8. ER图</h4><p>Entity-Relationship</p>
<p>包括：实体、属性、联系</p>
<p>用来进行关系型数据库系统的概念设计。</p>
<h5 id="实体的三种联系"><a href="#实体的三种联系" class="headerlink" title="实体的三种联系"></a>实体的三种联系</h5><ul>
<li><p>一对一：<br>画两个带箭头的线段</p>
</li>
<li><p>一对多：<br>A到B是一对多，则画指向B的箭头</p>
</li>
<li><p>多对多：<br>两个不带箭头的线段</p>
</li>
</ul>
<h5 id="表示出现多次的关系"><a href="#表示出现多次的关系" class="headerlink" title="表示出现多次的关系"></a>表示出现多次的关系</h5><p>一个实体在联系出现几次，就要用几条线连接。</p>
<h5 id="联系的多向性"><a href="#联系的多向性" class="headerlink" title="联系的多向性"></a>联系的多向性</h5><p>三元关系</p>
<h5 id="表示子类"><a href="#表示子类" class="headerlink" title="表示子类"></a>表示子类</h5><p>用一个三角形和两条线来连接类和子类，与子类有关的属性和联系都连到子类上，与父类和子类有关系的连到父类上。</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql</title>
    <url>/articles/2020-02-11-dataBase-Mysql.html</url>
    <content><![CDATA[<h4 id="1-索引"><a href="#1-索引" class="headerlink" title="1. 索引"></a>1. 索引</h4><h5 id="B-Tree原理"><a href="#B-Tree原理" class="headerlink" title="B+ Tree原理"></a>B+ Tree原理</h5><ol>
<li>数据结构<br>B Tree （Balance Tree，平衡树）：查找树，且所有叶子节点位于同一层。<br>B+ Tree是基于B Tree和叶子节点顺序访问指针进行实现的，它具有B Tree的平衡性，通过顺序访问指针提高区间查询性能。</li>
</ol>
<p>一个节点中的key从左到右非递减排列，key左右是key(i)、key(i+1)，且不为null，则该指针指向节点的所有key大于等于key(i)且小于等于key(i+1)。</p>
<a id="more"></a>

<ol start="2">
<li>操作</li>
</ol>
<h4 id="2-Mysql索引"><a href="#2-Mysql索引" class="headerlink" title="2. Mysql索引"></a>2. Mysql索引</h4><p>索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同的存储引擎具有不同的索引类型和实现。</p>
<h5 id="B-Tree索引"><a href="#B-Tree索引" class="headerlink" title="B+ Tree索引"></a>B+ Tree索引</h5><p>大多数Mysql存储引擎的默认索引类型。</p>
<p>不需要进行全表扫描，只需要对树进行搜索即可，查找速度快很多。<br>B+Tree的有序性，所以除了用于查找，还可以用于排序和分组。</p>
<p>可以指定多个列作为索引列，多个索引列共同组成键。<br>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。<br>如果不是按照索引列的顺序进行查找，则无法使用索引。</p>
<p>InnoDB的B+Tree索引分为主索引和辅助索引。<br>主索引的叶子节点data记录着完整的数据记录，这种记录称为聚簇索引。<br>因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，<br>需要先查找到主键值，然后再到主索引中进行查找。</p>
<h5 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h5><p>哈希索引能以O(1)时间进行查找，但失去了有序性。<br>无法用于排序与分组<br>只支持精确查找，无法用于部分查找和范围查找</p>
<p>InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”<br>当某个索引值被使用的非常频繁时，会在B+Tree索引之上再创建一个哈希索引，<br>这样就让B+Tree索引具有哈希索引的一些优点，如：快速的哈希查找。</p>
<h5 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h5><p>MyISAM存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。</p>
<p>查找条件使用Match Against，而不是普通的Where</p>
<p>全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。</p>
<p>InnoDB存储引擎在Mysql5.6.4版本中也开始支持全文索引。</p>
<h5 id="空间数据索引"><a href="#空间数据索引" class="headerlink" title="空间数据索引"></a>空间数据索引</h5><p>MyISAM存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。<br>空间数据索引会从所有维度来索引数据，可以有效的使用任意维度来进行组合查询。<br>必须使用GIS相关的函数来维护数据。</p>
<h4 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3. 索引优化"></a>3. 索引优化</h4><ol>
<li>独立的列<br>在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不能使用 actor_id 列的索引</span><br><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 &#x3D; 5;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>多列索引<br>在需要使用多列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 最好把 actor_id 和 film_id 设置为多列索引</span><br><span class="line">SELECT film_id, actor_ id FROM sakila.film_actor</span><br><span class="line">WHERE actor_id &#x3D; 1 AND film_id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>索引列的顺序<br>让选择项最强的索引列放在前面</li>
</ol>
<p>索引的选择性是指：<br>    不重复的索引值和记录总数的比值。<br>    最大值为1，此时每个记录都有唯一的索引与其对应。<br>    选择性越高，每个记录的区分度越高，查询效率也越高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面</span><br><span class="line">SELECT COUNT(DISTINCT staff_id)&#x2F;COUNT(*) AS staff_id_selectivity,</span><br><span class="line">COUNT(DISTINCT customer_id)&#x2F;COUNT(*) AS customer_id_selectivity,</span><br><span class="line">COUNT(*)</span><br><span class="line">FROM payment;</span><br><span class="line"></span><br><span class="line">staff_id_selectivity: 0.0001</span><br><span class="line">customer_id_selectivity: 0.0373</span><br><span class="line">               COUNT(*): 16049</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>前缀索引<br>对于Blob、Text和Varcher类型的列，必须使用前缀索引，只索引开始的部分字符。<br>前缀长度的选取需要根据索引选择性来确定。</p>
</li>
<li><p>覆盖索引<br>索引包含所有需要查询的字段的值。</p>
</li>
</ol>
<p>优点：</p>
<ul>
<li>索引通常远小于数据行的大小，只读取索引能大大减少数据访问量；</li>
<li>一些存储引擎在内存中只缓存索引，而数据依赖于操作系统来缓存，因此，只访问索引可以不使用系统调用；</li>
<li>对于InnoDB引擎，若辅助索引能够覆盖查询，则无需访问主索引；</li>
</ul>
<h5 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h5><ul>
<li>大大减少了服务器需要扫描的数据行数；</li>
<li>帮助服务器避免进行排序和分组，以及比曼创建临时表；（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）；</li>
<li>将随机I/O变为顺序I/O（B+Tree索引是有序的，会将相邻的数据都存储在一起）；</li>
</ul>
<h5 id="索引的使用条件"><a href="#索引的使用条件" class="headerlink" title="索引的使用条件"></a>索引的使用条件</h5><ul>
<li>对于非常小的表，大部分情况下简单的全表扫描比建立索引更高效；</li>
<li>对于中到大型的表，索引非常有效；</li>
<li>对于特大型的表，建立和维护索引的代价将会随之增长，这时需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条一条记录的匹配，如：使用分区技术。</li>
</ul>
<h4 id="4-查询性能优化"><a href="#4-查询性能优化" class="headerlink" title="4. 查询性能优化"></a>4. 查询性能优化</h4><p>使用Explain进行分析<br>Explain用来分析select查询，通过分析explain结果来优化查询语句。</p>
<h5 id="重要字段"><a href="#重要字段" class="headerlink" title="重要字段"></a>重要字段</h5><ul>
<li>select_type：查询类型，有简单查询、联合查询、子查询等；</li>
<li>key：使用的索引；</li>
<li>rows：扫描的行数；</li>
</ul>
<h5 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h5><ol>
<li>减少请求的数据量</li>
</ol>
<ul>
<li>只返回必要的列；</li>
<li>只返回必要的行；</li>
<li>缓存重复查询的数据：使用缓存可以避免在数据库中进行查询；</li>
</ul>
<ol start="2">
<li>减少服务器端扫描的行数<br>最有效的方式是使用索引来覆盖查询</li>
</ol>
<h5 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h5><ol>
<li><p>切分大查询<br>一个大查询如果一次执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但是重要的查询</p>
</li>
<li><p>分解大连接查询<br>将一个大连接查询分解成对每一个表进行一次单表查询，然后再应用程序中进行关联<br>好处：</p>
</li>
</ol>
<ul>
<li>让缓存更高效；<br>  对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。<br>  而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li>
<li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询；</li>
<li>减少锁竞争；</li>
<li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩；</li>
<li>查询本身效率也可能会有所提升。</li>
</ul>
<h4 id="5-存储引擎"><a href="#5-存储引擎" class="headerlink" title="5. 存储引擎"></a>5. 存储引擎</h4><h5 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h5><p>是Mysql默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。</p>
<p>实现了四个标准的隔离级别，默认级别是可重复读（Repeatable Read），<br>在可重复读的隔离级别下，通过多版本并发控制（MVCC）+间隙锁（Next-Key Locking）防止幻影读。</p>
<p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p>
<p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、<br>能够加速插入操作的插入缓冲区等。</p>
<p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，<br>而在读写混合场景中，停止写入可能也意味着停止读取。</p>
<h5 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h5><p>设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。</p>
<p>提供了大量的特性，包括压缩表、空间数据索引等。</p>
<p>不支持事务。<br>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。<br>但在表有读取操作的同时，也可以往表中插入新的记录，成为并发插入（Concurrent insert）</p>
<p>可以手动或自动执行检查和修复操作，但和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作非常慢。</p>
<p>如果指定了Delay_key_write选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓存区，<br>只有在清理键缓存区时或关闭表的时候才会将对应的索引快写入磁盘。这种方式可以极大提升写入性能，但在数据库或主机崩溃时会造成索引损坏，需要执行修复操作。</p>
<h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><ul>
<li>事务：InnoDB是事务型，可以使用Commit和Rollback语句；</li>
<li>并发：MyISAM只支持表级锁，而InnoDB还支持行级锁；</li>
<li>外键：InnoDB支持外键；</li>
<li>备份：InnoDB支持在线热备份；</li>
<li>崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也更慢；</li>
<li>其他特性：MyISAM支持压缩表和空间数据索引；</li>
</ul>
<h4 id="6-数据类型"><a href="#6-数据类型" class="headerlink" title="6. 数据类型"></a>6. 数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p>TinyInt：8位存储空间<br>SmalInt：16位<br>MediumInt：24位<br>Int：32位<br>BigInt：64位<br>一般越小的列越好。<br>Int(11)中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。</p>
<h5 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h5><p>Float和Double浮点类型；<br>Decimal：高精度的小数类型；<br>CPU原生支持浮点运算，但不支持Decimal类型的计算，因此Decimal的计算比浮点类型需要更高的代价。<br>Float、Double、Decimal都可以指定列宽。<br>Decimal(18，9)表示总共18位，取9位存储小数部分，剩余9位存储整数部分。</p>
<h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><p>主要有Char和Varchar两种类型，一种定长，一种变长。<br>Varchar：变长类型，节省空间，只需要存储必要的内容。<br>但在执行Update时可能会使行变得比原来长，当超出一个页能够容纳的大小时，就要执行额           外的操作。MyISAM会将行拆成不同的片段存储，而InnoDB则需要分裂页来使行放进页内。</p>
<p>在进行检索和存储时，会保留Varchar末尾的空格，而会删除Char末尾的空格。</p>
<h5 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h5><p>Datetime和Timestamp</p>
<ul>
<li><p>Datetime：<br>  能够保存从1000年到9999年的日期和时间，精度为秒，使用8字节的存储空间。<br>  它与时区无关。<br>  默认情况下，Mysql以一种可排序的、无歧义的格式显示Datetime值，是ANSI标椎定义的日期和时间表示法。</p>
</li>
<li><p>Timestamp：<br>  和UNIX时间戳相同，保存从1970年1月1日午夜以来的秒数，使用4个字节，只能表示从1970到2038年。<br>  它和时区有关，即一个时间戳在不同的时区所代表的具体时间是不同的。<br>  Mysql提供了From_unixtime()函数把Unix时间戳转化为日期，Unix_Timestamp<br>  ()函数把日期转换为UNIX时间戳。<br>  默认情况下，如果插入时没有指定Timestamp列的值，会将这个值设置为当前时间。<br>  应该尽量使用Timestamp，比Datetime空间效率更高。</p>
</li>
</ul>
<h4 id="7-切分"><a href="#7-切分" class="headerlink" title="7. 切分"></a>7. 切分</h4><h5 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h5><p>水平切分：Sharding<br>是将同一个表中的记录拆分到多个结构相同的表中。</p>
<p>当一个表中的数据不断增多时，Sharding是必然的选择，它可以将数据分布到集群的不同节点上，<br>从而缓存单个数据库的压力。</p>
<h5 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h5><p>垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，<br>也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p>
<p>在数据库的层面，使用垂直切分将按数据库中表的密集程度部署到不同的库中。</p>
<h5 id="Shaeding策略"><a href="#Shaeding策略" class="headerlink" title="Shaeding策略"></a>Shaeding策略</h5><p>哈希取模：hash(key)%N<br>范围：可以是ID范围也可以是时间范围<br>映射表：使用单独的一个数据库来存储映射关系</p>
<h5 id="Sharding存在的问题"><a href="#Sharding存在的问题" class="headerlink" title="Sharding存在的问题"></a>Sharding存在的问题</h5><ol>
<li>事务问题<br> 使用分布式事务来解决，比如XA接口</li>
<li>连接<br> 可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。</li>
<li>ID唯一性<br> 使用全局唯一ID（GUID）<br> 为每个分片指定一个ID范围<br> 分布式ID生成器</li>
</ol>
<h4 id="8-复制"><a href="#8-复制" class="headerlink" title="8. 复制"></a>8. 复制</h4><h5 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h5><p>主要涉及三个线程：binlog线程、I/O线程和Sql线程<br>binlog线程：<br>负责将主服务器上的数据更改写入二进制日志（Binary log）中<br>I/O线程：<br>负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）<br>Sql线程：<br>负责读取中继日志，解析出主服务器已经执行的数据更改，并在从服务器中重放（Replay）。</p>
<h5 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h5><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。<br>读写分离能够提高性能的原因在于：<br>主从服务器负责各自的读和写，极大程度缓解了锁的争用；<br>从服务器可以使用MyISAM，提升查询性能及节约系统开销；<br>增加冗余，提高可用性；</p>
<p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Http-Net</title>
    <url>/articles/2020-02-11-Http-Net.html</url>
    <content><![CDATA[<h4 id="1-主机之间的通信方式"><a href="#1-主机之间的通信方式" class="headerlink" title="1. 主机之间的通信方式"></a>1. 主机之间的通信方式</h4><p>客户-服务器（C/S）:<br>    客户是服务的请求方，服务器是服务的提供方。</p>
<p>对等（P2P）：<br>    不区分客户和服务器</p>
<a id="more"></a>

<h4 id="2-计算机网络体系结构"><a href="#2-计算机网络体系结构" class="headerlink" title="2. 计算机网络体系结构"></a>2. 计算机网络体系结构</h4><p>OSI：应用层、表示层、会话层、运输层、网络层、数据链路层、物理层<br>五层协议：应用层、运输层、网络层、数据链路层、物理层<br>TCP/IP：应用层、运输车、网际层、网络接口层</p>
<ul>
<li>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。</li>
<li>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li>
<li>网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li>
<li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li>
<li>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li>
<li>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li>
<li>会话层 ：建立及管理会话。</li>
</ul>
<h4 id="3-HTTP"><a href="#3-HTTP" class="headerlink" title="3. HTTP"></a>3. HTTP</h4><ul>
<li><p>URI<br>包括URL和URN</p>
</li>
<li><p>请求和响应报文</p>
</li>
<li><p>HTTP方法<br>客户端发送的请求报文第一行为请求行，包括了方法字段</p>
</li>
<li><p>HTTP状态码<br>1XX信息：<br>  到目前为止都很正常，客户端可以继续发送请求或忽略这个响应</p>
</li>
</ul>
<p>2XX成功：<br>    200 ok<br>    204 No Content：<br>    请求已成功处理，但返回的响应报文不包含实体的主体部分。<br>    一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。<br>    206 Partial Content：<br>    表示客户端进行了范围请求，响应报文包含由Content-Range指定范围的实体内容。</p>
<p>3XX重定向<br>    301 Moved Permanently：永久性重定向<br>    302 Found：临时性重定向<br>    303 See Other：和302有相同的功能，但303明确要求客户端应该采用GET方法获取资源<br>    304 Not Modified：如果请求报文首部包含一些条件，如：If-Match，如果不满足，服务器会返回304状态码<br>    307 Temporary Redirect：临时重定向，要求浏览器不会把重定向请求的POST改成get方法。</p>
<p>4XX客户端错误<br>    400 Bad Request：请求报文中存在语法错误<br>    401 Unauthorized：该状态码表示发送的请求需要有认证信息，如果之前已进行过一次请求，则表示用户认证失败。<br>    403 Forbidden：请求被拒绝<br>    404 Not Found</p>
<p>5XX服务器错误<br>    500 Internal Server Error：服务器正在执行请求时发生错误<br>    503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
<ul>
<li>连接管理<br>1、短连接与长连接<br>长连接只需要建立一次TCP连接就能进行多次HTTP通信<br>从Http/1.1 开始默认是长连接，如果断开连接，需要由客户端或服务端提出断开，使用Connection：close<br>在Http/1.1之前默认是短连接，如果需要使用长连接，则使用Connection:Keep-Alive</li>
</ul>
<p>2、流水线<br>默认情况下，Http请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。<br>由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p>
<p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p>
<p>3、Cookie<br>Http协议是无状态的，主要是为了让Http协议尽可能简单，使得它能够处理大量事务。<br>http1.1引入Cookie来保存状态信息</p>
<p>Cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，<br>用于告知服务端两个请求是否来自同一浏览器。</p>
<p>Cookie会带来额外的性能开销，已渐渐被淘汰，新的浏览器API已经允许开发者直接将数据存储到本地。</p>
<p>用途：<br>    会话状态管理（如用户登录、购物车、游戏分数或其它需要记录的信息）<br>    个性化设置（如用户自定义设置、主题）<br>    浏览器行为跟踪（如跟踪分析用户行为）</p>
<p>创建过程：<br>    服务器发送的响应报文包含Set-Cookie首部字段，客户端得到响应报文后把Cookie内容保存到浏览器中<br>    客户端之后对同一个服务器发送请求时，会从浏览器中取出Cookie信息，并通过Cookie请求首部字段发送服务器</p>
<p>分类<br>    会话期 Cookie：浏览器关闭之后会自动删除，也就是说它仅在会话期内有效<br>    持久性 Cookie：指定过期时间Expires或有效期max-age之后就成为了持久性的Cookie</p>
<p>作用域：<br>    Domain标识指定了哪些主机可以接受Cookie，如果不指定，默认当前文档的主机（不包含子域名）<br>    如果指定了domain，则一般包含子域名。</p>
<p>4、Session<br>利用Session存储在服务端，存储在服务器的信息更加安全<br>可以存储在服务器上的文件、数据库或者内存中，也可以将Session存储在Redis</p>
<p>过程：<br>    用户进行登录时，用户提交包含用户名和密码的表单，放入Http请求报文中<br>    服务器验证该用户名和密码，正确，存储到Redis<br>    服务器返回响应报文的Set-Cookie首部字段包含了这个SessionId，客户端收到响应报文后存储Cookie值到浏览器<br>    客户端之后对同一个服务器请求时会包含该Cookie值，服务器收到之后提取出SessionId，从Redis取出用户信息，继续之前业务操作</p>
<p>5、Cookie与Session选择<br>Cookie只能存储ASCII码字符串，而Session则可以存储任何类型的数据，考虑数据复杂性时首选Session<br>Cookie存储在浏览器中，容易被恶意查看，如非要将隐私数据存在Cookie，可以将Cookie进行加密，然后再服务器解密<br>大型网站，用户所有的信息都存储到Session中，开销大，不建议</p>
<p>6、缓存<br>优点：<br>    缓解服务器压力<br>    降低客户端获取资源的延迟：<br>    缓存通常位于内存中，读取缓存的速度更快。<br>    并且缓存服务器在地理位置上也有可能比源服务器来的近</p>
<p>实现方法：<br>    让代理服务器进行缓存<br>    让客户端浏览器进行缓存</p>
<p>Cache-Control<br>Http/1.1通过Cache-Control首部字段来控制缓存</p>
<p>禁止进行缓存：<br>    no-store指令规定不能对请求或相应的任何一部分进行缓存（cache-control:no-store）</p>
<p>强制确认缓存：<br>    no-cache规定缓存服务器需要先向源服务器验证缓存资源的有效性，<br>    只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。<br>    Cache-Control: no-cache</p>
<p>私有缓存和公共缓存：<br>    private规定将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中<br>    Cache-Control: private</p>
<p>public规定将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中<br>Cache-Control: public</p>
<p>缓存过期机制<br>max-age出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，就能接受该缓存<br>max-age出现在响应报文，表示缓存资源在缓存服务器中保存的时间<br>Cache-Control: max-age=31536000</p>
<p>expires首部字段也可以用于告知缓存服务器该资源什么时候过期<br>Expires：Wed, 04 Jul 2012 08:23:05 GMT</p>
<p>在Http/1.1中，会优先处理max-age指令<br>在Http/1.0中，max-age指令会被忽略掉</p>
<p>缓存验证</p>
<p>7、通信数据转发</p>
<p>代理<br>代理服务器接受客户端的请求，并且转发给其它服务器</p>
<p>目的：<br>    缓存<br>    负载均衡<br>    网络访问控制<br>    访问日志记录</p>
<p>分为正向代理和反向代理：<br>    用户察觉得到正向代理的存在<br>    而反向代理一般位于内部网络中，用户察觉不到</p>
<p>网关：<br>与代理服务器不同的是，网关服务器将HTTP转化为其它协议进行通信，从而请求其它非Http服务器的服务。</p>
<p>隧道：<br>使用SSL等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p>
<p>8、HTTPS<br>Http有以下安全问题：<br>    使用明文进行通信，内容可能被窃听；<br>    不验证通信方的身份，通信方的身份有可能遭遇伪装；<br>    无法证明报文的完整性，报文有可能遭篡改；</p>
<p>HTTPS并不是新协议，而是让HTTP先和SSL（Secure Sockets Layer）通信，<br>再由SSL和TCP通信，也就是说HTTPS使用了隧道进行通信。</p>
<p>通过使用SSL，HTTPS具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）</p>
<p>缺点：<br>    需要进行加密解密等过程，速度慢<br>    需要支付证书授权的高额费用</p>
<p>9、HTTP/2.0</p>
<p>HTTP/1.X缺陷：<br>    客户端需要使用多个连接才能实现并发和缩短延迟；<br>    不会压缩请求和响应首部，从而导致不必要的网络流量；<br>    不支持有效的资源优先级，致使底层TCP连接的利用率低下；</p>
<p>二进制分帧层：<br>    HTTP/2.0将报文分成Headers帧和Data帧，它们都是二进制格式的，在通信过程中，只会有<br>    一个TCP连接存在，它承载了任意数量的双向数据流（Stream）<br>    一个数据流Stream：都有一个唯一标识符和可选的优先级消息，用于承载双向消息；<br>    消息Message：是与逻辑请求或响应对应的完成的一系列帧。</p>
<p>服务端推送：<br>HTTP/2.0在客户端请求一个资源时，会把相关的资源一起发送给客户端端，客户端不需要再次发起请求了。</p>
<p>首部压缩：<br>    HTTP/1.1首部带有大量信息，而且每次都要重复发送；<br>    HTTP/2.0要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p>
<p>10、HTTP/1.1新特性<br>    默认长连接<br>    支持流水线<br>    支持同时打开多个TCP连接<br>    支持虚拟主机<br>    新增状态码100<br>    支持分块传输编码<br>    新增缓存处理指令max-age</p>
<h4 id="4-GET和POST"><a href="#4-GET和POST" class="headerlink" title="4. GET和POST"></a>4. GET和POST</h4><ul>
<li><p>作用<br>  get用户获取资源；<br>  post用于传输实体主体</p>
</li>
<li><p>参数<br>  get参数是以查询字符串出现在URL中，url只支持ASCII码，所以Get的参数中如果存在中文字符需要进行编码<br>  post存储在实体主体中</p>
</li>
<li><p>安全<br>  安全的HTTP方法不会改变服务器状态，即它只是可读的。</p>
<p>  get是安全的，post不是，因为post的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，<br>  上传成功之后，服务器可能是把这个数据存储到数据库中，因此状态发生了改变。</p>
<p>  安全方法：get、Head、Options<br>  不安全：post、put、delete</p>
</li>
<li><p>幂等性<br>  幂等的HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。<br>  幂等方法不应该具有副作用</p>
<p>  所有的安全方法也都是幂等的。</p>
<p>  在正确实现条件下，get、head、put和delete方法都是幂等的，post不是。</p>
</li>
<li><p>可缓存<br>  如果要对响应进行缓存，需要满足：<br>  请求报文的http方法本身是可缓存的，包括Get和Head，但Put和Delete不可缓存，post多数情况下不可缓存；<br>  响应报文的状态码是可缓存的；<br>  响应报文的Cache-Control首部字段没有指定不进行缓存；</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title>Tcp</title>
    <url>/articles/2020-02-11-Http-Tcp.html</url>
    <content><![CDATA[<h4 id="1-三次握手过程"><a href="#1-三次握手过程" class="headerlink" title="1. 三次握手过程"></a>1. 三次握手过程</h4><ul>
<li>B处于Listen（监听）状态，等待来自A的连接请求；</li>
<li>A向B发送连接请求报文Syn；</li>
<li>B收到A发来的Syn，如果同意建立连接，则向A发送连接确认报文Syn Ack；</li>
<li>A收到Syn Ack后，还要向B发出确认报文Ack；</li>
<li>B收到Ack后，建立连接；</li>
</ul>
<a id="more"></a>
<p>接收到Syn后，所有的报文都存在Ack字段</p>
<h5 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h5><p>第三次握手是为了防止失效的链接请求到服务器，让服务器错误打开连接。</p>
<p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务发回的连接确认。<br>客户端等待一个超时重传时间之后，就会重新请求连接。<br>这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。<br>如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p>
<h4 id="2-四次挥手过程"><a href="#2-四次挥手过程" class="headerlink" title="2. 四次挥手过程"></a>2. 四次挥手过程</h4><ul>
<li>A发送连接释放报文FIN</li>
<li>B收到FIN后发出确认ACK，此时TCP属于半关闭状态，B能向A发送数据但是A不能向B发送数据</li>
<li>当B不再需要连接时，发送连接释放报文FIN</li>
<li>A收到FIN后发出确认ACK，进入Time-wait状态，等待2倍的MSL（最大报文存活时间）后释放连接</li>
<li>B收到ACK后释放连接</li>
</ul>
<h5 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h5><p>客户端发送了FIN连接释放报文之后，服务端收到了这个报文，进入Close-wait状态<br>这个状态是为了让服务器端发送还未传送完毕的数据，<br>传送完毕之后，服务器会发送FIN连接释放报文。</p>
<h4 id="Time-wait"><a href="#Time-wait" class="headerlink" title="Time-wait"></a>Time-wait</h4><p>客户端接收到服务器端的FIN报文之后进入此状态，而不是直接Closed状态，<br>还需要等待一个时间计时器设置的时间2MSL，原因是：</p>
<ul>
<li><p>确保最后一个确认报文ACK能够到达。<br>  如果服务器端没收到客户端发送来的确认报文ACK，那么需要重新发送连接释放请求FIN报文，<br>客户端等待一段时间就是为了处理这种情况的发生。</p>
</li>
<li><p>等待一段时间是为了让本次连接持续时间内产生的所有报文都从网络中消失，<br>  使得下一个新的连接不会出现旧的连接请求报文Syn，从而错误打开连接。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Net</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之class</title>
    <url>/articles/2020-02-11-ES-class.html</url>
    <content><![CDATA[<h4 id="1-class"><a href="#1-class" class="headerlink" title="1. class"></a>1. class</h4><p>constructor定义构造方法，this关键字代表实例对象。<br>类的一般方法都定义在类的prototype属性上面。<br>类的实例上面调用方法，其实就是调用原型上的方法。<br>类的内部所有定义的方法，都是不可枚举的。<br>类的静态方法只能用类类调用，不能用类的实例调用。<br>如果在实例上调用静态方法，会抛出错误，表示不存在该方法。<br>父类的静态方法，可以被子类继承。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">  toValue()&#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Point.prototype &#x3D; &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-Constructor方法"><a href="#2-Constructor方法" class="headerlink" title="2. Constructor方法"></a>2. Constructor方法</h4><p>类的默认方法，通过new命令生成对象实例时，自动调用该方法。<br>默认返回实例对象this</p>
<h4 id="3-类的实例对象"><a href="#3-类的实例对象" class="headerlink" title="3. 类的实例对象"></a>3. 类的实例对象</h4><p>生成类的实例对象的写法，也是使用new命令</p>
<p>class不存在变量提升，因此先使用，后定义会报错</p>
<h4 id="4-this指向"><a href="#4-this指向" class="headerlink" title="4. this指向"></a>4. this指向</h4><p>类的方法内部的this，默认指向类的实例。<br>如果静态方法包含this，指的是类，不是实例</p>
<h4 id="5-Name属性"><a href="#5-Name属性" class="headerlink" title="5. Name属性"></a>5. Name属性</h4><p>返回紧跟在class关键字后面的类名</p>
<h4 id="6-class的继承"><a href="#6-class的继承" class="headerlink" title="6. class的继承"></a>6. class的继承</h4><p>通过extends关键字实现继承<br>子类必须在constructor方法中调用super方法，否则新建实例报错<br>子类没有自己的this对象，而是继承父类的this对象，并对其加工。<br>不调用super方法，子类就得不到this对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); &#x2F;&#x2F; 调用父类的constructor(x, y)</span><br><span class="line">    this.color &#x3D; color;</span><br><span class="line">  &#125;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &#39; &#39; + super.toString(); &#x2F;&#x2F; 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-类的prototype属性和-proto-属性"><a href="#7-类的prototype属性和-proto-属性" class="headerlink" title="7. 类的prototype属性和_proto_属性"></a>7. 类的prototype属性和_proto_属性</h4><p>class同时有prototype属性和_proto_属性，因此同时存在两条继承链。<br>子类的_proto_属性，表示构造函数的继承，总是指向父类<br>子类的prototype属性的_proto_属性，总是指向父类的prototype属性</p>
<h4 id="8-Object-getPrototypeOf"><a href="#8-Object-getPrototypeOf" class="headerlink" title="8. Object.getPrototypeOf()"></a>8. Object.getPrototypeOf()</h4><p>用来从子类上获取父类，判断一个类是否继承了另一个类</p>
<h4 id="9-super关键字"><a href="#9-super关键字" class="headerlink" title="9. super关键字"></a>9. super关键字</h4><p>可以当函数，也可以当对象使用<br>必须显式指定作为函数使用还是作为对象<br>作函数时：代表父类的构造函数，且super()只能用在子类的构造函数中，用在其他地方报错。<br>作为对象时：在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    p() &#123;</span><br><span class="line">      return 2;</span><br><span class="line">    &#125;</span><br><span class="line">    static m() &#123;</span><br><span class="line">      console.log(&quot;父类的m方法被调用&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> class B extends A &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">      super();</span><br><span class="line">      console.log(super.p()); &#x2F;&#x2F; 2 super.p()在普通方法中，指向A.prototype</span><br><span class="line">    &#125;</span><br><span class="line">    static show() &#123;</span><br><span class="line">      super.m(); &#x2F;&#x2F; 在静态方法中，相当于A.m()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let b &#x3D; new B();</span><br><span class="line">  B.show(); &#x2F;&#x2F;父类的m方法被调用</span><br></pre></td></tr></table></figure>

<h4 id="10-实例的-proto-属性"><a href="#10-实例的-proto-属性" class="headerlink" title="10. 实例的_proto_属性"></a>10. 实例的_proto_属性</h4><p>子类实例的_proto_属性的_proto_属性，指向父类实例的_proto_属性。</p>
<p>Class的取值函数getter和存值函数setter</p>
<h4 id="11-Class的静态方法"><a href="#11-Class的静态方法" class="headerlink" title="11. Class的静态方法"></a>11. Class的静态方法</h4><p>在一个方法前，加static关键字<br>静态方法不会被实例继承，而是通过类来调用。<br>静态方法包含this，指向的是类，而不是实例。<br>静态方法可以和非静态方法重名。<br>父类的非静态方法可以被子类继承。</p>
<h4 id="12-Class的静态属性和实例属性"><a href="#12-Class的静态属性和实例属性" class="headerlink" title="12. Class的静态属性和实例属性"></a>12. Class的静态属性和实例属性</h4><p>静态属性指的是Class本身的属性，即class.propname，而不是定义在实例对象this上的属性。</p>
<h4 id="13-new-target属性"><a href="#13-new-target属性" class="headerlink" title="13. new.target属性"></a>13. new.target属性</h4><p>在构造函数中，返回new命令作用于的那个构造函数，如果构造函数不是通过new调用的，<br>new.target会返回undefined，<br>可以确定该构造函数是怎么调用的。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之asyncAwait</title>
    <url>/articles/2020-02-11-ES-asyncAwait.html</url>
    <content><![CDATA[<h4 id="1-async"><a href="#1-async" class="headerlink" title="1. async"></a>1. async</h4><p>async函数返回一个Promise对象，可以使用then方法添加回调函数。<br>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<a id="more"></a>

<p>async函数返回的Promise对象，必须等内部所有的await命令后面的Promise对象执行完，<br>才会发生状态改变，除非遇到return语句或抛出错误。<br>即只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。</p>
<p>async是Generator函数和自动执行器，包装在一个函数里。</p>
<h4 id="2-await"><a href="#2-await" class="headerlink" title="2. await"></a>2. await</h4><p>await ecpression：会造成异步函数停止执行并且等待Promise的解决后再恢复执行。<br>若 ecpression是Promise对象，则返回 ecpression的[[PromiseValue]]值，<br>否则，直接返回 ecpression</p>
<h4 id="3-异步Generator函数"><a href="#3-异步Generator函数" class="headerlink" title="3. 异步Generator函数"></a>3. 异步Generator函数</h4><p>异步Generator函数就是async函数与Generator函数的结合</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之Promise</title>
    <url>/articles/2020-02-11-ES-Promise.html</url>
    <content><![CDATA[<h4 id="1-Promise对象的特点"><a href="#1-Promise对象的特点" class="headerlink" title="1. Promise对象的特点"></a>1. Promise对象的特点</h4><p>三种状态：</p>
<ul>
<li>Pending</li>
<li>Resolved（Fulfilled）</li>
<li>Rejected<br>一旦状态改变，不会再变，任何时候都可以得到这个结果</li>
</ul>
<p>状态只有两种改变：</p>
<ul>
<li>Pending到Resolver</li>
<li>Pending到Rejected<br>如果改变已经发生，对Promise对象添加回调函数，也会立即得到这个结果<br>但事件Event不同，如果错过了，再去监听，是得不到结果的<br>状态一改变，即调用Promise对象的then方法</li>
</ul>
<a id="more"></a>

<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>Promise一旦新建就会立即执行，无法中途取消<br>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部<br>当处于Pending状态时，无法得知目前进展到哪个阶段</p>
<h4 id="2-Promise-all"><a href="#2-Promise-all" class="headerlink" title="2. Promise.all()"></a>2. Promise.all()</h4><pre><code>当在可迭代参数中所有Promise倍resolve，或任意一Promise被reject时，返回一个新的promise</code></pre><h4 id="3-Promise-race"><a href="#3-Promise-race" class="headerlink" title="3. Promise.race()"></a>3. Promise.race()</h4><p>返回一个新的异步的promise，只要有一个完成或失败，新的promise就会立刻完成或失败，<br>并得到那个promise对象的返回值或错误原因</p>
<p>参数为空，返回的蝾螈都是pending状态</p>
<h4 id="4-Promise-resolve"><a href="#4-Promise-resolve" class="headerlink" title="4. Promise.resolve()"></a>4. Promise.resolve()</h4><p>返回一个Promise对象</p>
<h4 id="5-Promise-reject"><a href="#5-Promise-reject" class="headerlink" title="5. Promise.reject()"></a>5. Promise.reject()</h4><p>返回一个新的Promise实例，状态为rejected，因此回调函数会立即执行</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之SetMap</title>
    <url>/articles/2020-02-11-ES-SetMap.html</url>
    <content><![CDATA[<h4 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h4><p>本身是一个构造函数，生成set数据结构。<br>接受一个数组作为参数，用来初始化。<br>去除数组的重复成员。<br>遍历顺序是插入顺序。<br>没有键名，只有键值。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const set &#x3D; new Set([1, 2, 3, 4, 4]);</span><br><span class="line">[...set]</span><br><span class="line">&#x2F;&#x2F; [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>

<h4 id="2-WeakSet"><a href="#2-WeakSet" class="headerlink" title="2. WeakSet"></a>2. WeakSet</h4><p>构造函数，可以使用new命令，创建WeakSet数据结构<br>接收数组或类似数组的对象作为参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; [[1, 2], [3, 4]];</span><br><span class="line">const ws &#x3D; new WeakSet(a);</span><br><span class="line">&#x2F;&#x2F; WeakSet &#123;[1, 2], [3, 4]&#125;</span><br></pre></td></tr></table></figure>

<p>WeakSet的成员只能是对象，而不能是其它类型的值；<br>WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，<br>即：如果其它对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用内存，<br>不考虑该对象还存在于WeakSet之中。<br>WeakSet没有size属性，不可遍历。</p>
<h4 id="3-Map"><a href="#3-Map" class="headerlink" title="3. Map"></a>3. Map</h4><p>键值对的集合（Hash结构）<br>map键是对象类型的，内存地址相同才相同<br>map键是简单类型的，两个值严格相等视为一个键，0和-0是同一个<br>map键将NaN和其自身视为同一个键<br>遍历顺序是插入顺利</p>
<h4 id="4-WeakMap"><a href="#4-WeakMap" class="headerlink" title="4. WeakMap"></a>4. WeakMap</h4><p>WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名<br>WeakMap的键名所指向的对象，不计入垃圾回收机制</p>
<p>WeakMap的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。<br>因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。<br>即一旦不再需要，WeakMap里面的键名对象和对应的键值就会自动消失，不用手动删除引用。</p>
<p>WeakMap有助于防止内存泄漏</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/articles/2020-02-11-dataBase-Redis.html</url>
    <content><![CDATA[<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>一个开源的，内存中的数据结构存储系统；<br>用作数据库、缓存和消息中间件；</p>
<a id="more"></a>

<h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h4><p>Remote Dictionary Server，数据结构服务器。<br>完全开源、非关系型、高性能的key-value存储系统。<br>速度非常快的非关系型（Nosql）内存键值数据库，可以存储键和五种不同类型的值之间的映射。</p>
<p>Redis支持很多特性。如：将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片扩展写性能。<br>键的类型只能为字符串，值有五种类型：字符串、列表、集合、散列表、有序集合（string、list、set、zset和hash）。</p>
<h4 id="2-Redis的特点"><a href="#2-Redis的特点" class="headerlink" title="2. Redis的特点"></a>2. Redis的特点</h4><p>redis是单线程的，操作是安全的；<br>redis支持数据的持久化，可将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用；<br>redis支持key-value，并提供list、set、zset、hash等数据结构的存储；<br>redis支持数据的备份，即master-slave模式的数据备份；<br>redis单个value的最大限制1GB；</p>
<h4 id="3-五种数据类型介绍及使用场景"><a href="#3-五种数据类型介绍及使用场景" class="headerlink" title="3. 五种数据类型介绍及使用场景"></a>3. 五种数据类型介绍及使用场景</h4><p>应用场景：<br>    会话缓存；<br>    消息队列，比如支付；<br>    活动排行榜或计数；<br>    发布，订阅消息（消息通知）；<br>    商品列表，评论列表等；</p>
<p>计数器<br>可以对string进行自增自减运算，从而实现计数器功能。<br>redis这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。</p>
<p>缓存<br>将热点数据放到内存中，设置内存的最大使用量，及淘汰策略来保证缓存的命中率。</p>
<p>查找表<br>如DNS记录就很适合使用Redis进行存储。</p>
<p>查找表和缓存类似，也是利用redis快速查找特性。<br>但查找表的内容不能失效，而缓存的内容可以失效，缓存不作为可靠的数据来源。</p>
<p>消息队列<br>list是一个双向链表，可以通过lpush和rpop写入和读取消息。</p>
<p>会话缓存<br>可以使用Redis来统一存储多台应用服务器的会话消息。<br>当应用服务器不再存储用户的会话消息，也就是不再具有状态，<br>一个用户可以请求任意一个应用服务器，从而容易实现高可用性及可伸缩性。</p>
<p>分布式锁实现<br>在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。</p>
<p>可以使用Redis自带的setnx命令实现分布式锁，除此之外，还可以使用RedLock分布式锁实现。</p>
<p>其它<br>set可以实现交集、并集等操作，从而实现共同好友的功能<br>zset可以有序性的操作，从而实现排行榜等功能。</p>
<p>1) String<br>    key-value，可以包含任何数据，一个键最大能存储512MB。<br>    比如图片或者序列化的对象。</p>
<pre><code>set：设置存储在指定键中的值；set key value *
get：获取存储在指定键中的值；get key
del：删除存储在指定键中的值；del key

使用场景:
    incr 自增 ；eg：生成id；
    decr 减少；eg：库存；
    计数器缓存；
    缓存–过期时间设置，模拟session；

使用案例：</code></pre><p>2） List<br>    redis列表，按照插入顺序可以添加一个元素到列表的头部或尾部。</p>
<pre><code>rpush：将给定值推入列表的右端；rpush key value *
lrange：获取列表在指定范围上的所有值；lrange key start stop
lindex：获取列表在指定范围上的单个元素；lindex key index
lpop key

使用场景：
    多任务调度队列；
    利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好；
    微博发表文章，使关注的人都能看到（使用列表做一个消息队列）；
    生产者消费者模型（多线程）；</code></pre><p>3）Set<br>    string类型的无序集合。集合是通过哈希表实现的，增删查复杂度都是O(1)</p>
<pre><code>sadd：将给定元素添加到集合；sadd key value
smembers：返回集合包含的所有元素；smembers key
sismember：检查指定元素是否存在于集合中； srem key value

使用场景：
    微博关注数。
    利用交集、并集、差集等操作，可以计算共同爱好，全部的喜好，自己独有的喜好等功能。</code></pre><p>4）hash<br>    键值对集合。是string类型的field和value的映射表，适用于存储对象。</p>
<pre><code>hset：散列里面关联起指定的键值对；hset key field value
hget：获取指定散列键的值；
hgetall：散列包含的所有键值对；hgetall key
hdel：如果给定键存在于散列中，移出这个键；hdel key field

使用场景：
    购物车
    单点登录，用这种数据结构存储用户信息，一cookie作为key，设置30分钟为缓存过期时间，
    能很好地模拟类似session效果。</code></pre><p>5）zset<br>    集合，不允许重复的成员。每个元素都会关联一个double类型的分数。<br>    redis通过分数来为集合中成员进行从小到大的排序。<br>    zset的成员是唯一的，但分数却可以重复。</p>
<pre><code>zadd：将一个带有给定分值的成员添加到有序集合里面；
zrange：根据元素在有序排列中所处的位置，从有序集合里面获取多个元素；
zrangebyscore：获取有序集合在给定分值范围内的所有元素；
zrem：如果指定成员存在于有序集合中，那么移出这个成员

使用场景
    排行榜，取Top N操作；
    延时任务
    范围查找</code></pre><h4 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4. 持久化"></a>4. 持久化</h4><p>Redis是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<p>两种方式：<br>1）rdb快照：<br>    将某个时间点的所有数据都存放到硬盘上；<br>    可以将快照复制到其它服务器，从而创建具有相同数据的服务器副本；<br>    如果系统发生故障，将会丢失最后一次创建快照之后的数据；<br>    如果数据量很大，保存快照的时间会很长；</p>
<pre><code>默认redis是会以快照的形式将数据持久化到磁盘（一个二进制文件，dump.rdb，这个文件名字可以指定），
在配置文件（redis.conf)中的格式是：save
N M表示在N秒之内，redis至少发生M次修改则redis抓快照到磁盘。

保存 900 1：900秒内如果超过1个key被修改，则启动快照保存；
保存300 10：300秒内如果超过10个key被修改，则启动快照保存；
保存60 10000：60秒内如果超过10000个重点被修改，则启动快照保存；</code></pre><p>2）aof持久化<br>    将写命令添加到AOF文件（Append Only File）的末尾。<br>    使用AOF持久化需要设置同步选项，从而确保写命令同步到磁盘文件上的时机。<br>    这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓存区，<br>    然后由操作系统决定什么时候同步磁盘，有以下选项：<br>        * always 每个写命令都同步<br>        * everysec 每秒同步一次<br>        * no 让操作系统来决定何时同步</p>
<pre><code>always：选项会严重降低服务器的性能；
everysec：选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且redis每秒执行一次同步对服务器性能几乎没有任何影响；
no：选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量；

随着服务器请求的增多，AOF文件会越来越大。
Redis提供了一种将AOF重写的特性，能够去除AOF文件中的冗余写命令。

使用aof持久时，服务将每个收到的写命令通过写函数追加到文件中（appendonly.aof)
aof持久化存储方式参数说明：
    appendonly yes：开启aof持久化存储方式；
    appendfsync always：收到写命令后就立即写入磁盘，效率最差，效果最好；
    appendfsync everysec：每秒写入磁盘一次，效率与效果居中；
    appendfsync no：完全依赖操作系统，效果最佳，效果没法保证；</code></pre><h4 id="5-redis性能、并发"><a href="#5-redis性能、并发" class="headerlink" title="5. redis性能、并发"></a>5. redis性能、并发</h4><p>性能：<br>    在碰到需要执行耗时特别久，且结果不频繁变动的sql，特别适合将运行结果放入魂村，<br>这样后面的请求就去缓存中读取，使得请求能够迅速响应。</p>
<p>并发：<br>    在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。<br>    这个时候，需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。</p>
<h4 id="6-优点"><a href="#6-优点" class="headerlink" title="6. 优点"></a>6. 优点</h4><p>1）性能极高。<br>    redis能读的速度是110000次/s,写的速度是81000次/s；<br>2）丰富的数据类型。<br>    redis支持二进制案例的strings、lists、hashes、sets及ordered sets数据类型操作；<br>3）原子。<br>    redis的所有操作都是原子性的，意思是要么成功要么失败完全不执行。<br>    单个操作都是原子性的，多个操作也支持事务，即原子性，通过Multi和Exec指令包起来。<br>4）丰富的特性。<br>    redis支持publish、subscribe，通知，key过期等特性。</p>
<h4 id="7-缺点"><a href="#7-缺点" class="headerlink" title="7. 缺点"></a>7. 缺点</h4><p>1）缓存和数据库双写一致性问题<br>2）缓存雪崩问题<br>3）缓存击穿问题<br>4）缓存并发竞争问题</p>
<h4 id="8-单线程的redis为什么这么快？"><a href="#8-单线程的redis为什么这么快？" class="headerlink" title="8. 单线程的redis为什么这么快？"></a>8. 单线程的redis为什么这么快？</h4><p>redis是单线程工作模型<br>1）纯内存操作<br>2）单线程操作，避免了频繁的上下文切换<br>3）采用非阻塞的I/o多路复用机制</p>
<h4 id="9-redis的过期策略及内存淘汰机制"><a href="#9-redis的过期策略及内存淘汰机制" class="headerlink" title="9. redis的过期策略及内存淘汰机制"></a>9. redis的过期策略及内存淘汰机制</h4><p>eg：redis只能存5G数据，可是写了10G，那会删除5G的数据。怎么删除？<br>    你的数据设置了过期时间，但是时间到了，内存占用率还是比较高，原因是什么？</p>
<pre><code>--redis：采用的是定期删除+惰性删除策略。</code></pre><p>为什么不用定时删除策略？<br>    定时删除，用一个定时器来负责监视key，过期则自动删除。<br>    虽然内存即使释放，但是十分消耗CPU资源。<br>    在大并发情况下，CPU要将时间应用在处理请求，而不是删除key，因此没有用这一策略。</p>
<p>定期删除+惰性删除是如何工作的？<br>    定期删除，redis默认每个100ms检查，是否有过期的key，有则删除。<br>    需要说明的是，redis不是每个100ms将所有key检查一次，而是随机抽取检查。<br>    因此，如果只采用定期删除策略，会导致很多key到期时间没有删除。</p>
<pre><code>所以，惰性删除是在获取某个key的时候，redis会检查一遍，这个key如果设置了过期时间，那么是否过期了？如果过期了，此时就会删除。</code></pre><p>采用定期删除+惰性删除就没有其他问题了吗？<br>    如果定期删除没有删除key，然后你也没及时请求key，也就是说惰性删除也没生效。<br>    这样，redis的内存会越来越高，那么就应该采用内存淘汰机制。</p>
<h4 id="10-redis和数据库双写一致性的问题"><a href="#10-redis和数据库双写一致性的问题" class="headerlink" title="10. redis和数据库双写一致性的问题"></a>10. redis和数据库双写一致性的问题</h4><p>一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。<br>数据库和缓存双写，就必然会存在不一致的问题。<br>如果对数据有强一致性要求，不能放缓存。<br>我们所做的一切，只能保证最终一致性。另外，从根本来上说，只能说降低不一致发生的概率，无法完全避免。<br>因此，有强一致性的要求的数据，不能放缓存。</p>
<p>首先，采用正确更新策略，先更新数据库，再删除缓存，其次，因为可能存在删除缓存失败的问题，提供了一个补偿措施即可<br>如消息队列。</p>
<h4 id="11-如何应对缓存穿透和缓存雪崩问题"><a href="#11-如何应对缓存穿透和缓存雪崩问题" class="headerlink" title="11. 如何应对缓存穿透和缓存雪崩问题"></a>11. 如何应对缓存穿透和缓存雪崩问题</h4><ul>
<li><p>缓存穿透：即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。<br>解决方案：<br>  1）利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试；<br>  2）采用异步更新策略，无论key是否取到值，都直接返回。</p>
<pre><code>value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需做环迅预热。</code></pre><p>  3）提供一个能迅速判断请求是否有效的拦截机制</p>
</li>
<li><p>缓存雪崩：即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。<br>解决方案：<br>  1）给缓存的失效时间，加上一个随机值，避免集体失效；<br>  2）使用互斥锁，但是该方案吞吐量明显下降了；<br>  3）双缓存。</p>
</li>
</ul>
<h4 id="12-如何解决redis的并发竞争key问题"><a href="#12-如何解决redis的并发竞争key问题" class="headerlink" title="12. 如何解决redis的并发竞争key问题"></a>12. 如何解决redis的并发竞争key问题</h4><p>即：同时有多个子系统去set一个key，需要注意什么？<br>1）如果对这个key操作，不要求顺序<br>    这种情况，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。<br>2）如果对这个key操作，要求顺序<br>    假设有一个key1，系统A需要将key1设置为value1，系统B需要将key1设置为valueB，系统C将key1设置为valueC，<br>    期望按照key1的value值按照valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个<br>    时间戳，<br>        系统A key1 {valueA 3:00}<br>        系统B key1 {valueB 3:05}<br>        系统C key1 {valueC 3:10}<br>    那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05},接下来系统A抢到锁，发现自己的valueA的时间戳<br>    早于缓存时间戳，那就不做set操作。</p>
<pre><code>其他方法，比如利用队列，将set方法变成串行访问也可以。</code></pre><h4 id="13-数据结构"><a href="#13-数据结构" class="headerlink" title="13. 数据结构"></a>13. 数据结构</h4><h5 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h5><p>distht：散列表结构，使用拉链法解决哈希冲突</p>
<p>Redis的字典dict中包含两个哈希表dictht，这是为了方便进行rehash操作。<br>在扩容时，将其中一个dictht上的键值对rehash到另一个dictht上，完成之后释放空间并交换两个dictht的角色。</p>
<p>rehash操作不是一次性完成，而是采用渐进方式，这是为了避免一次性执行过多的rehash操作给服务器带来的过大的负担。</p>
<p>渐进式rehash通过记录dict的rehashidx完成，从0开始，然后每执行一次rehash都会递增。</p>
<p>在rehash期间，每次对字典执行添加、删除、查找或更新操作时，都会执行一次渐进式rehash。</p>
<p>采用渐进式rehash会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。</p>
<h5 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h5><p>是有序集合的底层实现之一。</p>
<p>跳跃表是基于多指针有序链表实现的，可以看成多个有序链表。<br>在查找时，从上层指针开始查找，找到对应的区间之后再到下一层去查找。</p>
<p>与红黑树等平衡树相比，跳跃表的优点：<br>插入速度非常快速，因为不需要进行旋转灯操作来维护平衡性；<br>更容易实现；<br>支持无锁操作；</p>
<h4 id="14-Redis与Memcached"><a href="#14-Redis与Memcached" class="headerlink" title="14. Redis与Memcached"></a>14. Redis与Memcached</h4><p>两者都是非关系型内存键值数据库，主要有以下不同：</p>
<h5 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h5><p>Memcached仅支持字符串类型，redis支持五种不同的数据类型，可以灵活的解决问题。</p>
<h5 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h5><p>Redis支持两种持久化策略：RDB快照和AOF日志，而Memcached不支持持久化。</p>
<h5 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h5><p>Memcached不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储，<br>这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点。</p>
<p>redis cluster实现了分布式的支持。</p>
<h5 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h5><p>在redis中，并不是所有数据都一直存储在内存中，可以将一些很久没用的value交换到磁盘，<br>而Memcached的数据则会一直在内存中。</p>
<p>Memcached将内存分割成特定长度的块来存储数据，以完全解决内存碎片的问题。<br>但这种方式会使得内存的利用率不高。</p>
<h4 id="15-键的过期时间"><a href="#15-键的过期时间" class="headerlink" title="15. 键的过期时间"></a>15. 键的过期时间</h4><p>Redis可以为每个键设置过期时间，当键过期时，会自动删除该键。</p>
<p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p>
<h4 id="16-数据淘汰策略"><a href="#16-数据淘汰策略" class="headerlink" title="16. 数据淘汰策略"></a>16. 数据淘汰策略</h4><p>可以设置内存的最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p>
<p>Redis有6种淘汰策略：</p>
<ul>
<li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random 从所有数据集中任意选择数据进行淘汰</li>
<li>noeviction 禁止驱逐数据</li>
</ul>
<p>作为内存数据库，出于对性能和内存消耗的考虑，redis的淘汰算法实际上并非针对所有的key，<br>而是抽样一小部分并且从中选出被淘汰的key。</p>
<p>使用Redis缓存数据时，为了提高缓存命中率，需要保证缓存数据都是热点数据。<br>可以将内存最大使用量设置为热点数据占用的内存量，然后启用allkeys-lru淘汰策略，<br>将最近最少使用的数据淘汰。</p>
<p>Redis4.0引入了volatile-lfu和allkeys-lfu淘汰策略，LFU策略通过统计访问频率，将访问频率最少的键值对淘汰。</p>
<h4 id="17-事务"><a href="#17-事务" class="headerlink" title="17. 事务"></a>17. 事务</h4><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其它客户端的命令请求。</p>
<p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式成为流水线，<br>可以减少客户端与服务器之间的网络通信次数从而提升性能。</p>
<p>redis最简单的事务实现方式是使用MULTI和EXEC命令将事务操作包围起来。</p>
<h4 id="19-事件"><a href="#19-事件" class="headerlink" title="19. 事件"></a>19. 事件</h4><p>redis服务器是一个事件驱动程序。</p>
<h5 id="文件事件"><a href="#文件事件" class="headerlink" title="文件事件"></a>文件事件</h5><p>服务器通过套接字与客户端或其它服务器进行通信，文件事件就是对套接字操作的抽象。<br>Redis基于Reactor模式开发了自己的网络事件处理器，使用I/O多路复用程序来同时监听多个套接字，<br>并将到达的事件传送给文件事件分派器，分排器会根据套接字产生的事件类型调用相应的事件处理器。</p>
<h5 id="时间事件"><a href="#时间事件" class="headerlink" title="时间事件"></a>时间事件</h5><p>服务器有一些操作需要在给定的时间点执行，时间事件是对这类定时操作的抽象。<br>时间事件分为：</p>
<ul>
<li>定时事件：是让一段程序在指定的时间之内执行一次；</li>
<li>周期性事件：是让一段程序每隔指定时间就执行一次；</li>
</ul>
<p>Redis将所有时间事件都放在一个无序链表中，通过遍历整个链表查找出已到达的时间事件，<br>并调用相应的事件处理器。</p>
<h5 id="事件的调度与执行"><a href="#事件的调度与执行" class="headerlink" title="事件的调度与执行"></a>事件的调度与执行</h5><p>服务器需要不断监听文件事件的套接字才能得到待处理的文件事件，但不能一直监听，否则时间事件无法在规定的时间内执行，<br>因此监听时间应该根据距离现在最近的时间事件来决定。</p>
<h4 id="19-复制"><a href="#19-复制" class="headerlink" title="19. 复制"></a>19. 复制</h4><p>通过使用slaveof host port命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h5 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h5><ul>
<li>主服务器创建快照文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。<br>快照文件发送完毕后，开始向从服务器发送存储在缓冲区中的写命令。</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令；</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的命令</li>
</ul>
<h5 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h5><p>随着负载不断上升，主服务器可能无法很快的更新所有从服务器，或重新连接和同步从服务器将导致系统超载。<br>为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。<br>中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<h4 id="20-Sentinel"><a href="#20-Sentinel" class="headerlink" title="20. Sentinel"></a>20. Sentinel</h4><p>Sentinel哨兵：可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。</p>
<h4 id="21-分片"><a href="#21-分片" class="headerlink" title="21. 分片"></a>21. 分片</h4><p>分片是将数据划分成多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得<br>线性级别的性能提升。</p>
<p>根据分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定键应当分布到哪个节点；</li>
<li>代理分片：将客户端请求发送到代理上，由代理转发请求到正确的节点上；</li>
<li>服务器分片：Redis Cluster；</li>
</ul>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Proto3</title>
    <url>/articles/2020-02-11-proto3.html</url>
    <content><![CDATA[<h4 id="Protobuf（proto3）"><a href="#Protobuf（proto3）" class="headerlink" title="Protobuf（proto3）"></a>Protobuf（proto3）</h4><p>protocol buffer是google的语言中立的、平台中立的，可扩展机制的，用于序列化结构化数据。<br>对比XML，更小、刚快、更简单。<br>简单的设计协议，通过自带工具转换成对应的语言代码，<br>协议是二进制协议，设计时只需要描述各个类的关系，简单明了。</p>
<p>定义消息类型<br>syntax = “proto3”; // 指定使用proto3的语法，否则默认是proto2，该定义必须是文件的第一个非空的非注释行</p>
<p>// HelloWorldRequest消息定义了三个字段(名称/值对)，对应着消息内容<br>// 每个字段都由字段限制、字段类型、字段名和编号四部分组成<br>message HelloWorldRequest {<br>    string name = 1;<br>    int32 age = 2;<br>}</p>
<a id="more"></a>

<h4 id="1-指定字段类型"><a href="#1-指定字段类型" class="headerlink" title="1. 指定字段类型"></a>1. 指定字段类型</h4><pre><code>double
float
int32
int64
boolean
string
byte
uint64
sint32
sint64
fixed32
fixed64
sfixed32
sfixed64</code></pre><h4 id="2-赋予编号-数字标识符"><a href="#2-赋予编号-数字标识符" class="headerlink" title="2. 赋予编号(数字标识符)"></a>2. 赋予编号(数字标识符)</h4><p>消息中的每一个字段都有一个独一无二的数值类型的编号，用来在消息的二进制格式中识别各个字段，一旦开始使用就不能再改变。</p>
<p>1-15使用一个字节编码<br>16-2047使用两个字节编码<br>所以将编号1-15留给频繁使用的字段<br>要为将来有可能添加的、频繁出现的标识号预留一些标识号<br>最小的标识号可以从1开始，最大到2^29 - 1, or 536,870,911。<br>不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报错</p>
<h4 id="3-指定字段限制"><a href="#3-指定字段限制" class="headerlink" title="3. 指定字段限制"></a>3. 指定字段限制</h4><p>required：必须赋值的字段<br>optional：可有可无的字段<br>repeated：可重复的字段（变长字段），重复使用任意次数(包括0次)</p>
<h4 id="4-添加更多消息类型"><a href="#4-添加更多消息类型" class="headerlink" title="4. 添加更多消息类型"></a>4. 添加更多消息类型</h4><p>一个.proto文件可以定义多个消息类型</p>
<h4 id="5-添加注释"><a href="#5-添加注释" class="headerlink" title="5. 添加注释"></a>5. 添加注释</h4><p>//</p>
<h4 id="6-预留字段"><a href="#6-预留字段" class="headerlink" title="6. 预留字段"></a>6. 预留字段</h4><p>当你在某次更新消息中屏蔽或者删除了一个字段的话，未来的使用着可能在他们的更新中重用这个标签数字来标记他们自己的字段。然后当他们加载旧的消息的时候就会出现很多问题，包括数据冲突，隐藏的bug等等。指定这个字段的标签数字（或者名字，名字可能在序列化为JSON的时候可能冲突）标记为reserved来保证他们不会再次被使用。如果以后的人试用的话protobuf编译器会提示出错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 一个reserved字段不能机油标签数字又有名字</span><br></pre></td></tr></table></figure>

<h4 id="7-默认值"><a href="#7-默认值" class="headerlink" title="7. 默认值"></a>7. 默认值</h4><pre><code>string：空字符串
字节：空字节
布尔：false
数字类型：0
枚举：第一个定义的枚举值，且该值必须为0
重复字段：空</code></pre><h4 id="8-枚举"><a href="#8-枚举" class="headerlink" title="8. 枚举"></a>8. 枚举</h4><p>Corpus枚举第一个常量映射为0，每个枚举定义必须包含一个映射到0的常量作为第一个元素<br>设置可选参数allow_alias为true，可以在枚举结构中使用别名(两个值元素值相同)<br>枚举器常量必须在32位正数范围内<br>不建议使用负值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">    string query &#x3D; 1;</span><br><span class="line">    int32 page_number &#x3D; 2;</span><br><span class="line">    int32 result_per_page &#x3D; 3;</span><br><span class="line">    enum Corpus &#123; </span><br><span class="line">      UNIVERSAL &#x3D; 0;</span><br><span class="line">      WEB &#x3D; 1;</span><br><span class="line">      IMAGES &#x3D; 2;</span><br><span class="line">      LOCAL &#x3D; 3;</span><br><span class="line">      NEWS &#x3D; 4;</span><br><span class="line">      PRODUCTS &#x3D; 5;</span><br><span class="line">      VIDEO &#x3D; 6;</span><br><span class="line">    &#125;</span><br><span class="line">    Corpus corpus &#x3D; 4;</span><br><span class="line">&#125;</span><br><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">    option allow_alias &#x3D; true;</span><br><span class="line">    UNKNOWN &#x3D; 0;</span><br><span class="line">    STARTED &#x3D; 1;</span><br><span class="line">    RUNNING &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line">enum EnumNotAllowingAlias &#123;</span><br><span class="line">    UNKNOWN &#x3D; 0;</span><br><span class="line">    STARTED &#x3D; 1;</span><br><span class="line">    &#x2F;&#x2F; RUNNING &#x3D; 1;  &#x2F;&#x2F; Uncommenting this line will cause a compile error inside Google and a warning message outside.</span><br><span class="line">&#125;</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 9. 使用其他消息类型</span><br><span class="line">使用一个消息的定义作为另一个消息的字段类型</span><br></pre></td></tr></table></figure>
<p>message SearchResponse {<br>  repeated Result results = 1;<br>}</p>
<p>message Result {<br>  string url = 1;<br>  string title = 2;<br>  repeated string snippets = 3;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 10. 导入定义</span><br><span class="line">&#96;&#96;&#96;import &#39;other_protos.proto&#39;;</span><br></pre></td></tr></table></figure>

<h4 id="11-嵌套类型"><a href="#11-嵌套类型" class="headerlink" title="11. 嵌套类型"></a>11. 嵌套类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  message Result &#123;</span><br><span class="line">    string url &#x3D; 1;</span><br><span class="line">    string title &#x3D; 2;</span><br><span class="line">    repeated string snippets &#x3D; 3;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated Result results &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在另一个消息中使用Result定义</span><br><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">  SearchResponse.Result result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-更新消息类型"><a href="#12-更新消息类型" class="headerlink" title="12. 更新消息类型"></a>12. 更新消息类型</h4><ul>
<li>不要更改任何现有字段的字段编号</li>
<li>添加新字段，必须是optional和repeated限定符，否则无法保证新老程序在互相传递消息时的兼容性</li>
<li>在原有消息中，不能移出已经存在的required字段，optional和repeated类型的字段可以被移除，但是他们之前使用的标签号必须被保留，不能被新的字段重用</li>
<li>int32、uint32、int64、uint64和bool等类型之间是兼容的，sint32和sint64是兼容的，string和bytes是兼容的，fixed32和sfixed32，以及fixed64和sfixed64之间是兼容的，这意味着如果想修改原有字段的类型时，为了保证兼容性，只能将其修改为与其原有类型兼容的类型，否则就将打破新老消息格式的兼容性</li>
<li>optional和repeated限定符也是互相兼容</li>
</ul>
<h4 id="13-任意消息类型"><a href="#13-任意消息类型" class="headerlink" title="13. 任意消息类型"></a>13. 任意消息类型</h4><p>any类型不需要在.proto文件中定义就可以直接使用的消息类型，使用前import google/protobuf/any.proto文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import  &quot;google&#x2F;protobuf&#x2F;any.proto&quot;;</span><br><span class="line"></span><br><span class="line">message ErrorStatus  &#123;</span><br><span class="line">  string message &#x3D;  1;</span><br><span class="line">  repeated google.protobuf.Any details &#x3D;  2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-其中一个类型"><a href="#14-其中一个类型" class="headerlink" title="14. 其中一个类型"></a>14. 其中一个类型</h4><p>Oneof</p>
<ul>
<li>一个包含许多字段的消息，且最多只同时设置一个字段，可以使用oneof强制执行并节省内存</li>
<li>oneof字段只有最后被设置的字段才有效，即后面的set操作会覆盖前面的set操作</li>
<li>oneof不可以是repeated</li>
<li>反射api可以用在oneof字段</li>
<li>添加或删除oneof字段，如果检测到oneof字段的返回值是None/Not_Set,意味着oneof没有被设置或设置了一个不同的oneof版本，但无法区分这两种情况（向后兼容）</li>
<li>删除或添加字段到oneof，在消息序列化或解析后会丢失一些消息，一些字段会被清空</li>
<li>删除一个字段然后重新添加，在消息序列化或解析后会清除当前设置的oneof字段</li>
<li>分割或合并字段，同普通的删除字段操作</li>
</ul>
<h1 id="Maps（表映射）"><a href="#Maps（表映射）" class="headerlink" title="Maps（表映射）"></a>Maps（表映射）</h1><ul>
<li>map&lt;key_type, value_type&gt; map_field = N;</li>
<li>key_type可以是除浮点指针或bytes外的其他基本类型，value_type可以是任意类型</li>
<li>Map的字段不可以是重复的(repeated)</li>
<li>线性顺序和map值的的迭代顺序是未定义的，所以不能期待map的元素是有序的</li>
<li>maps可以通过key来排序，数值类型的key通过比较数值进行排序</li>
<li>线性解析或者合并的时候，如果出现重复的key值，最后一个key将被使用。从文本格式来解析map，如果出现重复key值则解析失败</li>
<li>向后兼容：在线性上是等价的，即使paotocol buffers没有实现maps数据结构也不会影响数据的处理</li>
</ul>
<h4 id="15-包"><a href="#15-包" class="headerlink" title="15. 包"></a>15. 包</h4><p>可以向.proto文件添加package可选说明符，以防止协议消息类型之间的名称冲突</p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Proto3</tag>
      </tags>
  </entry>
  <entry>
    <title>Mongodb</title>
    <url>/articles/2020-02-11-dataBase-Mongodb.html</url>
    <content><![CDATA[<h4 id="1-创建索引"><a href="#1-创建索引" class="headerlink" title="1. 创建索引"></a>1. 创建索引</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 2. 查询索引</span><br><span class="line">&#96;&#96;&#96;db.user.getIndexes(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="3-索引类型"><a href="#3-索引类型" class="headerlink" title="3. 索引类型"></a>3. 索引类型</h4><ul>
<li><p>默认索引<br>  强制唯一的，不可删除。</p>
</li>
<li><p>唯一索引</p>
</li>
<li><p>组合索引<br>  多个键组合，键后面的数字表明了索引的方向，1表示升序，-1表示降序。</p>
</li>
</ul>
<h4 id="4-查询数据库主从库"><a href="#4-查询数据库主从库" class="headerlink" title="4. 查询数据库主从库"></a>4. 查询数据库主从库</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查询结果：</span><br></pre></td></tr></table></figure>
<p>{<br>    “setName” : “数据库名”,<br>    “setVersion” : 25,<br>    “ismaster” : false, // 所在库是否为主库<br>    “secondary” : true, // 所在库是否为从库<br>    “hosts” : [ // 数据库hosts<br>        “<strong>***</strong>:27017”,<br>        “<strong>***</strong>:27017”,<br>        “<strong>***</strong>:27017”<br>    ],<br>    “primary” : “<strong>***</strong>:27017”, // 主库<br>    “me” : “<strong>**</strong>:27017”,<br>    “maxBsonObjectSize” : 16777216,<br>    “maxMessageSizeBytes” : 48000000,<br>    “maxWriteBatchSize” : 1000,<br>    “localTime” : ISODate(“2020-02-11T09:18:17.240Z”),<br>    “maxWireVersion” : 3,<br>    “minWireVersion” : 0,<br>    “ok” : 1.0<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 5. 获取ObjectId的时间</span><br><span class="line">&#96;&#96;&#96; ObjectId(&#39;5d01777700de3b32269aefe4&#39;).getTimestamp()</span><br></pre></td></tr></table></figure>
<p>结果：<code>ISODate(&quot;2019-06-12T22:06:47Z&quot;)</code></p>
]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>Knex</title>
    <url>/articles/2020-02-11-dataBase-knex.html</url>
    <content><![CDATA[<h4 id="1-Knexjs"><a href="#1-Knexjs" class="headerlink" title="1. Knexjs"></a>1. Knexjs</h4><p>设计的“包含电池”SQL查询构建器，设计灵活，便于携带，并且使用起来非常有趣。<br>它具有传统的节点样式回调以及用于清洁异步流控制的承诺接口，流接口，全功能查询和模式构建器，事务支持（带保存点），连接池以及不同查询客户和方言之间的标准化响应。</p>
<a id="more"></a>

<h4 id="2-支持"><a href="#2-支持" class="headerlink" title="2. 支持"></a>2. 支持</h4><p>主要目标环境是NodeJS，安装该Knex库。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><figcaption><span>install knex --save```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3. 初始数据库</span><br><span class="line">该knex模块本身是一个为Knex提供配置对象的函数，它接受一些参数。该client参数是必须的，并且确定哪个客户端适配器将与该库一起使用。</span><br><span class="line">mysql数据库初始化：</span><br></pre></td></tr></table></figure>
<p>var knex = require(‘knex’)({<br>  client: ‘mysql’,<br>  connection: {<br>    host : ‘127.0.0.1’,<br>    user : ‘your_database_user’,<br>    password : ‘your_database_password’,<br>    database : ‘myapp_test’<br>  }<br>});</p>
<pre><code>#### 4. knex查询构造器


</code></pre>]]></content>
      <categories>
        <category>Database</category>
      </categories>
      <tags>
        <tag>Knex</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC</title>
    <url>/articles/2020-02-11-gRPC.html</url>
    <content><![CDATA[<h4 id="什么是gRPC"><a href="#什么是gRPC" class="headerlink" title="什么是gRPC"></a>什么是gRPC</h4><pre><code>PRC（Remote Procedure Call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信。
google开发，一款语言中立、平台中立、开源的远程过程调用(RPC)系统.
gRPC里客户端应用可以像本地对象一样直接调用另一台不同机器上服务端应用的方法，使得能够更容易创建分布式应用和服务。
基于Http2.0且依赖protobuf

定义一个服务，指定其能够被远程调用的方法(参数和返回类型),在服务端实现这个接口，并允许一个gRPC服务器来处理客户端调用，
在客户端拥有一个存根能够像服务端一样的方法。</code></pre><a id="more"></a>

<h5 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h5><pre><code>基于Http/2:
    HTTP/2提供了连接多路复用、双向流、服务器推送、请求优先级、首部压缩等机制。
    可节省带宽、降低TCP链接次数、节省CPU，帮助移动设备延长电池寿命等。
IDL使用ProtoBuf：
    gRPC使用ProtoBuf定义服务，ProtoBuf由Google开发的一种数据序列化协议，能够将数据进行序列化，
    并广泛应用在数据存储、通信协议等方面
    压缩和传输效率高，语法简单，表达力强。
多语言支持：
    C、C++、Node、Python、Rubuy、Objective-C、PHP和C#</code></pre><h5 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. 应用场景</h5><pre><code>低延迟、高扩展性、分布式的系统
同云服务器进行通信的引动应用客户端
涉及语言独立、高效、精确的新协议
便于各方面扩展的分层涉及，如认证、负载均衡、日志记录、监控等</code></pre><h5 id="3-优点"><a href="#3-优点" class="headerlink" title="3. 优点"></a>3. 优点</h5><pre><code>protobuf二进制编码，大幅减少需要传输的数据量，性能好、效率高
proto文件生成目标代码，简单易用
protobuf定义接口，更加严格的接口约束条件
grpc可以方便的支持流式通信
序列化反序列化直接对应程序中的数据类，不需要解析后再进行映射
支持向前兼容(新加字段采用默认值)和向后兼容(忽略新加字段)，简化升级
支持多种语言
Netty等一些框架集成</code></pre><h5 id="4-缺点"><a href="#4-缺点" class="headerlink" title="4. 缺点"></a>4. 缺点</h5><pre><code>grpc尚未实现连接池，需要自行实现
尚未提供“服务发现”、“负载均衡”机制
Nginx不能讲Grpc请求作为http请求来负载均衡，而是作为普通的TCP请求
protobuf二进制可读写差</code></pre><h5 id="5-基础"><a href="#5-基础" class="headerlink" title="5. 基础"></a>5. 基础</h5><pre><code>.proto文件定义服务
protocol buffer编译器生成服务器和客户端代码
使用grpc的NodeJS API为服务实现一个简单的客户端和服务器</code></pre><h5 id="6-为什么使用gRPC？"><a href="#6-为什么使用gRPC？" class="headerlink" title="6. 为什么使用gRPC？"></a>6. 为什么使用gRPC？</h5><pre><code>允许客户端获取路由特性的信息，生成路由的总结，及交互路由信息</code></pre><h5 id="7-通信方式"><a href="#7-通信方式" class="headerlink" title="7. 通信方式"></a>7. 通信方式</h5><pre><code>Simple RPC
            一个请求对象对应一个返回对象
Server-side streaming RPC
        服务端流式rpc，一个请求对象，服务端返回多个结果对象
Client-side streaming RPC
        客户端流式rpc，客户端传入多个请求对象，服务端返回一个相应结果
Bidirectional streaming RPC
        双向流式rpc，结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象</code></pre><h5 id="8-Examples"><a href="#8-Examples" class="headerlink" title="8. Examples"></a>8. Examples</h5><ul>
<li><p><code>cd examples/node-test</code></p>
</li>
<li><p>定义服务：<br>  使用protocol buffers去定义gRPC service和方法request及response类型；</p>
</li>
<li><p>.proto文件：<br>  .proto文件也包含了所有请求的protocol buffer消息类型定义及在服务方法中使用的响应类型。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;; &#x2F;&#x2F; 指定使用proto3语法，默认是proto2，且放在proto文件的非空非注释的第一行。</span><br><span class="line"></span><br><span class="line">package helloworld;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定service</span><br><span class="line">service Greeter &#123;</span><br><span class="line">    &#x2F;&#x2F; 一个简单的rpc, 客户端使用存根发送请求到服务器并等待响应返回；</span><br><span class="line">    rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 一个服务端流式rpc 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。</span><br><span class="line">    &#x2F;&#x2F; 客户端读取返回的流，直到里面没有任何消息。</span><br><span class="line">    rpc ListFeatures(Rectangle) returns (stream Feature) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 一个客户端流式rpc 客户端写入一个消息序列并将其发送到服务器，同样适用流</span><br><span class="line">    &#x2F;&#x2F; 一旦客户端完成写入信息，它等待服务器完成读取返回它的响应</span><br><span class="line">    rpc RecordRoute(stream Point) returns (RouteSummary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 一个双向流式rpc 双方适用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务端可以任曦喜欢的顺序读写</span><br><span class="line">    rpc RouteChat(stream RouteNote) returns (stream RouteNote) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">    string name &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">    string message &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编译proto文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd protos </span><br><span class="line"></span><br><span class="line">grpc_tools_node_protoc --js_out&#x3D;import_style&#x3D;commonjs,binary:..&#x2F;protos --grpc_out&#x3D;..&#x2F;protos --plugin&#x3D;protoc-gen-grpc&#x3D;&#96;which grpc_tools_node_protoc_plugin&#96; helloword.proto</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>生成两个文件：<br>    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">helloword_pb.js</span><br><span class="line">helloword_grpc_pb.js</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>创建服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const grpc &#x3D; require(&#39;grpc&#39;);</span><br><span class="line"></span><br><span class="line">const messages &#x3D; require(&#39;.&#x2F;helloworld_pb&#39;);</span><br><span class="line">const services &#x3D; require(&#39;.&#x2F;helloworld_grpc_pb&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* Implements the SayHello RPC method.</span><br><span class="line">*&#x2F;</span><br><span class="line">function sayHello(call, callback) &#123;</span><br><span class="line">    const reply &#x3D; new messages.HelloReply();</span><br><span class="line">    reply.setMessage(&#39;Hello &#39; + call.request.getName());</span><br><span class="line">    &#x2F;&#x2F; 第一个参数为null，表示没有错误</span><br><span class="line">    callback(null, reply);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动服务器</span><br><span class="line">function main() &#123;</span><br><span class="line">    const server &#x3D; new grpc.Server();</span><br><span class="line">    server.addService(services.GreeterService, &#123;sayHello: sayHello&#125;);</span><br><span class="line">    server.bind(&#39;0.0.0.0:50051&#39;, grpc.ServerCredentials.createInsecure());</span><br><span class="line">    server.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
</li>
<li><p>client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const grpc &#x3D; require(&#39;grpc&#39;);</span><br><span class="line"></span><br><span class="line">const messages &#x3D; require(&#39;.&#x2F;helloworld_pb&#39;);</span><br><span class="line">const services &#x3D; require(&#39;.&#x2F;helloworld_grpc_pb&#39;);</span><br><span class="line"></span><br><span class="line">function main() &#123;</span><br><span class="line">    const client &#x3D; new services.GreeterClient(&#39;localhost:50051&#39;, grpc.credentials.createInsecure());</span><br><span class="line">    const request &#x3D; new messages.HelloRequest();</span><br><span class="line">    const user;</span><br><span class="line">    if (process.argv.length &gt;&#x3D; 3) &#123;</span><br><span class="line">        user &#x3D; process.argv[2];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        user &#x3D; &#39;world&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">    request.setName(user);</span><br><span class="line">    client.sayHello(request, function (err, response) &#123;</span><br><span class="line">        console.log(&#39;Greeting:&#39;, response.getMessage());</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..&#x2F;node-test</span><br><span class="line"></span><br><span class="line">node .&#x2F;static-codegen&#x2F;test_server.js</span><br><span class="line"></span><br><span class="line">node .&#x2F;static-codegen&#x2F;test_client.js</span><br></pre></td></tr></table></figure>



</li>
</ul>
]]></content>
      <categories>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>gRPC</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/articles/2020-02-11-interview-dataStructure.html</url>
    <content><![CDATA[<p>数据结构是相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成。<br>包括三个组成部分：</p>
<ul>
<li>数据的逻辑结构</li>
<li>物理结构（存储结构）</li>
<li>数据运算结构</li>
</ul>
<h4 id="1-集合（数据之间无关系）"><a href="#1-集合（数据之间无关系）" class="headerlink" title="1. 集合（数据之间无关系）"></a>1. 集合（数据之间无关系）</h4><p>集合是不同对象（成为成员）的无序聚集。两个重要特点：</p>
<blockquote>
<p>成员是无序的；<br>每个成员都只在集合中出现一次；</p>
</blockquote>
<h4 id="2-线性结构（一对一）"><a href="#2-线性结构（一对一）" class="headerlink" title="2. 线性结构（一对一）"></a>2. 线性结构（一对一）</h4><p>特点是：在数据元素的非空有限集中，线性表简单来说就是数据元素的非空有限序列，特点是可以从表中的任何位置进行插入和删除操作。</p>
<blockquote>
<p>存在唯一的一个被称作“第一个”的数据元素和唯一的一个被称作“最后一个”的数据元素；<br>除第一个之外，集合中的每个数据元素均只有一个前驱；除最后一个元素之外，集合中的每个元素均只有一个后继</p>
</blockquote>
<h4 id="3-树形结构（一对多）"><a href="#3-树形结构（一对多）" class="headerlink" title="3. 树形结构（一对多）"></a>3. 树形结构（一对多）</h4><p>数据结构是一种非线型结构。<br>定义：树（Tree）是n（n&gt;=0）个相同数据类型的数据元素的集合。<br>    树种的数据元素成为节点（Node）。<br>    n=0的树成为空树（Empty Tree）。</p>
<p>对于n &gt; 0的任意非空树T有：</p>
<blockquote>
<p>有且仅有一个特殊的节点成为树的根（root）节点，根没有前驱结点；<br>若n&gt;1，则除根结点外，其余结点被分成了m(m&gt;0)个互不相交的集合T1,T2……Tm，<br>其中每个集合集合Ti（1&lt;= i &lt;= m）本身又是一棵树，树T1,T2…Tm为这棵树的子树Subtree。</p>
</blockquote>
<p>树的定义是递归的，用树来定义树。<br>树Tree简记为T，是一个二元组T=(D,R)【D：结点的有限集合；R：结点之间关系的有限集合】</p>
<p>树具有两个特点：</p>
<blockquote>
<p>树的根节点没有前驱结点，除根节点之外的所有结点有且仅有一个前驱结点<br>树种的所有结点都可以有零个或多个后继结点</p>
</blockquote>
<h4 id="4-图形结构（多对多）"><a href="#4-图形结构（多对多）" class="headerlink" title="4. 图形结构（多对多）"></a>4. 图形结构（多对多）</h4><p>图形数据结构主要研究形状和图形数据元素之间的关系。</p>
<h4 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h4><p>所谓数组，是有序的元素序列。</p>
<h4 id="6-栈（先进后出、线性表）"><a href="#6-栈（先进后出、线性表）" class="headerlink" title="6. 栈（先进后出、线性表）"></a>6. 栈（先进后出、线性表）</h4><p>stack，一种运算受限的线性表。<br>其限制是仅允许在表的一端进行插入和删除运算，这一端被称为栈顶，另一端被称为栈底。</p>
<h4 id="7-队列（先进先出、后进后出、线性表）"><a href="#7-队列（先进先出、后进后出、线性表）" class="headerlink" title="7. 队列（先进先出、后进后出、线性表）"></a>7. 队列（先进先出、后进后出、线性表）</h4><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端进行删除操作，表的后端进行插入操作。<br>插入操作的为队尾，删除操作的为队头。</p>
<h4 id="8-链表"><a href="#8-链表" class="headerlink" title="8. 链表"></a>8. 链表</h4><p>一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。<br>链表由一系列结点组成，结点可以在运行时动态生成。<br>每个结点包括两个部分：</p>
<ul>
<li>存储数据元素的数据域</li>
<li>存储下一个结点地址的指针域</li>
</ul>
<h4 id="9-散列表"><a href="#9-散列表" class="headerlink" title="9. 散列表"></a>9. 散列表</h4><p>Hash table（哈希表）<br>是根据关键码值而直接进行访问的数据结构。<br>即通过把关键码值映射到表中的一个位置来访问记录，以加快查找的速度。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/articles/2020-02-08-interview-javaScript.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-JS作用域及This指向"><a href="#1-JS作用域及This指向" class="headerlink" title="1. JS作用域及This指向"></a>1. JS作用域及This指向</h4><p>作用域：浏览器给js的一个生存环境（栈内存）。</p>
<p>作用域链：js中的关键字var，function都可以提前声明和定义，放在内存地址（堆内存）中。<br>然后从js从上到下逐行执行，遇到变量就去内存地址查找是否存在这个变量，如果有就用，没有就继续向父级作用域查找知道window下结束，这种查找机制就是作用域链。</p>
<p>this：js的一个关键字，指定一个对象然后去替代它。<br>看在什么情景下使用它。<br>函数内的this指向行为发生的主体。<br>函数外的this指向window，没有意义。</p>
<p>改变this的值：<br>call()、apply()、bind()</p>
<h4 id="2-call-Apply-Bind"><a href="#2-call-Apply-Bind" class="headerlink" title="2. call Apply Bind"></a>2. call Apply Bind</h4><p>作用是改变函数运行时this的指向。</p>
<p>call：接受逗号分隔的无限多个参数，是修改函数的作用域即this的指向，且立即执行。<br>apply：接受数组作为参数，是修改函数的作用域即this的指向，且立即执行。<br>bind：返回结果是一个新的函数，不会立即执行。</p>
<h4 id="3-原型、原型链"><a href="#3-原型、原型链" class="headerlink" title="3. 原型、原型链"></a>3. 原型、原型链</h4><p>原型指针<br>prototype：是函数独有的，每个函数上面都有一个属性prototype指向了函数的原型对象Person.pertotype；<br>总是被_proto_所指；</p>
<p>prototype对象默认有两个属性：</p>
<ul>
<li>constructor</li>
<li><em>proto</em></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person：构造函数</span><br><span class="line">Person.prototype：Person的原型对象，简称原型。</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">console.log(Person.prototype);</span><br></pre></td></tr></table></figure>

<p>_proto_：每个实例上面都有一个隐式原型proto指向了函数的原型对象。</p>
<ul>
<li>是原型链查询中实际用到的，它总是指向prototype。</li>
<li>所有对象都有_proto_属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;	</span><br><span class="line">Person.prototype.showName &#x3D; function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">console.log(p1.showName());</span><br></pre></td></tr></table></figure>

<p>实例访问属性或方法的时候，遵循以下原则：</p>
<ul>
<li>如果实例上面存在，就用实例本身的属性和方法；</li>
<li>如果实例上面不存在，就顺着_proto_的指向一直往上查找，查找就停止；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">&#125;	</span><br><span class="line">Person.prototype.showName &#x3D; function() &#123;</span><br><span class="line">    return &quot;你调用的原型上面的方法&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">p1.showName &#x3D; function() &#123;</span><br><span class="line">    return &quot;你调用的是p2对象上面的方法&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(p1.showName()); &#x2F;&#x2F;输出：你调用的是p1对象上面的方法</span><br><span class="line"></span><br><span class="line">var p2 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">console.log(p2.showName()); &#x2F;&#x2F;输出：你调用的原型上面的方法</span><br></pre></td></tr></table></figure>

<p>constructor：每个函数的原型对象上面都有一个constructor属性，指向创建对象的构造函数本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person.prototype.constructor &#x3D;&#x3D; Person</span><br></pre></td></tr></table></figure>

<p>什么是原型链？</p>
<blockquote>
<p>每个对象都可以有一个原型_prop，这个原型可以有它自己的原型，以此类推，形成一个原型链。</p>
</blockquote>
<h4 id="4-JS中的继承方式"><a href="#4-JS中的继承方式" class="headerlink" title="4. JS中的继承方式"></a>4. JS中的继承方式</h4><p>面向对象的基本特征：封闭、继承、多态。</p>
<p>js中实现继承的方法：</p>
<ul>
<li>对象冒充</li>
<li>call()、apply()</li>
<li>原型链</li>
<li>混合方式</li>
</ul>
<h5 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h5><p>JavaScript对象冒充实现继承：本质上是改变this的指向。<br>原理：</p>
<blockquote>
<p>构造函数使用this关键字给所有属性和方法赋值，因为构造函数只是一个函数，所以可使classA的构造方法称为ClassB的方法，然后调用它。<br>ClassA就会收到ClassB的构造方法中定义的属性和方法。<br>对象冒充可以支持多重继承，即一个类可以继承多个类。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ClassA(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.getName&#x3D;function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ClassB(name,password)&#123;</span><br><span class="line">    this.ClassA&#x3D;ClassA;</span><br><span class="line">    this.ClassA(name);</span><br><span class="line">    delete this.ClassA;</span><br><span class="line">    </span><br><span class="line">    this.password&#x3D;password;</span><br><span class="line">    this.getPassword&#x3D;function()&#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b &#x3D;new ClassB(&#39;wwww&#39;,&#39;1123&#39;);</span><br><span class="line">document.write(b.getName());</span><br></pre></td></tr></table></figure>
<h5 id="call实现对象冒充"><a href="#call实现对象冒充" class="headerlink" title="call实现对象冒充"></a>call实现对象冒充</h5><blockquote>
<p>它的第一个参数用做this的对象，其他参数都直接传递给函数自身。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ShowColor(param1,param2)&#123;</span><br><span class="line">    this.getColor&#x3D;function()&#123;</span><br><span class="line">        document.write(this.color+&quot;&lt;br&#x2F;&gt;Two Params : &quot;+param1+&quot; ; &quot;+param2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new Object;</span><br><span class="line">obj.color&#x3D;&#39;Red&#39;;</span><br><span class="line">ShowColor.call(obj,&quot;pm1&quot;,&#39;pm2&#39;);</span><br><span class="line"></span><br><span class="line">obj.getColor();</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Red</span><br><span class="line">Two Params:pm1;pm2</span><br><span class="line"></span><br><span class="line">function ClassA(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.getName&#x3D;function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ClassB(name,password)&#123;</span><br><span class="line">    &#x2F;&#x2F;this.ClassA&#x3D;ClassA;</span><br><span class="line">    &#x2F;&#x2F;this.ClassA(name);</span><br><span class="line">    &#x2F;&#x2F;delete this.ClassA;</span><br><span class="line">    ClassA.call(this,name);</span><br><span class="line">    </span><br><span class="line">    this.password&#x3D;password;</span><br><span class="line">    this.getPassword&#x3D;function()&#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; new ClassB(&#39;www&#39;,&#39;111&#39;);</span><br><span class="line">b.getPassword();</span><br><span class="line">&#x2F;&#x2F; 此处ClassA.call(this, name)，即将ClassA的this指向了CalssB的this，从而实现了对象冒充。</span><br></pre></td></tr></table></figure>
<h5 id="apply方法实现对象冒充"><a href="#apply方法实现对象冒充" class="headerlink" title="apply方法实现对象冒充"></a>apply方法实现对象冒充</h5><blockquote>
<p>apply方法有两个参数，用作this的对象和要传递给函数的参数的数组。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function ShowColor(param1,param2)&#123;</span><br><span class="line">    this.getColor&#x3D;function()&#123;</span><br><span class="line">        document.write(this.color+&quot;&lt;br&#x2F;&gt;Two Params : &quot;+param1+&quot; ; &quot;+param2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new Object;</span><br><span class="line">obj.color&#x3D;&#39;Red&#39;;</span><br><span class="line">ShowColor.apply(obj,new Array(&quot;pm1&quot;,&#39;pm2&#39;));</span><br><span class="line"></span><br><span class="line">obj.getColor();</span><br></pre></td></tr></table></figure>


<h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.GetName&#x3D;function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User(name,password)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.password &#x3D; password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype &#x3D; new Person();</span><br><span class="line">User.prototype.GetPassword&#x3D;function()&#123;</span><br><span class="line">    return this.password;</span><br><span class="line">&#125;</span><br><span class="line">User是对User对象构造函数的引用,new Person()使用person构造函数创建了一个Person对象,然后把Person对象的原型置为这个操作的结果.也就是说,当每次new User()时,得到的新User对象都会带有Person对象的所有方法。</span><br></pre></td></tr></table></figure>


<h4 id="5-事件捕获和冒泡"><a href="#5-事件捕获和冒泡" class="headerlink" title="5. 事件捕获和冒泡"></a>5. 事件捕获和冒泡</h4><p>捕获型事件：事件从最不精确的对象开始触发，然后到最精确（从上到下）。</p>
<p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标的顺序触发（从下到上）。</p>
<p>类似于把一个漂浮的水面上的物品向水里砸下去，下降再上升的过程。</p>
<p>两种方式阻止事件冒泡：</p>
<ul>
<li><p>event.stopPropagation()：只阻止了事件往上冒泡，不阻止事件本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#div1&quot;).mousedown(function(event)&#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>return false：不仅阻止了事件往上冒泡，而且阻止了事件本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(&quot;#div1&quot;).mousedown(function(event)&#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="6-闭包"><a href="#6-闭包" class="headerlink" title="6. 闭包"></a>6. 闭包</h4><p>所有函数都是闭包，闭包就是作用域范围，因为js是函数作用域，所以函数就是闭包。</p>
<p>是一种函数，能够读取其他函数内部变量的函数。<br>用途：可以读取函数内部的变量，并让这些变量的值始终保持在内存中。</p>
<h4 id="7-new的过程"><a href="#7-new的过程" class="headerlink" title="7. new的过程"></a>7. new的过程</h4><p>创建一个对象通常需要：</p>
<ul>
<li>定义构造函数</li>
<li>new创建对象实例</li>
</ul>
<p>当使用new新建一个对象的时候，以new foo为例：</p>
<ul>
<li>一个新的对象被创建，同时继承了对象类型的原型，即foo.prototype；</li>
<li>执行对象类型的构造函数，同时该实例的属性和方法被this引用，即this指向新构造的实例；</li>
<li>如果构造函数return了一个新的对象，那么这个对象就会取代整个new出来的结果。<br>如果没有return对象，返回1所创建的对象，即隐式返回this</li>
</ul>
<h4 id="8-箭头函数和普通函数的区别"><a href="#8-箭头函数和普通函数的区别" class="headerlink" title="8. 箭头函数和普通函数的区别"></a>8. 箭头函数和普通函数的区别</h4><p>箭头函数相当于匿名函数，并且简化了函数意义。</p>
<p>但和匿名函数有个明显的区别：</p>
<blockquote>
<p>箭头函数内部的this是词法作用域，由上下文确定。</p>
</blockquote>
<p>箭头函数和es5的函数有什么区别？</p>
<ul>
<li>箭头函数没有prototype，不绑定this</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; () &#x3D;&gt;&#123;&#125;;</span><br><span class="line">console.log(a.prototype); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            console.log(this, this.age); &#x2F;&#x2F; window undefined</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    age: 1,</span><br><span class="line">    say: function() &#123;</span><br><span class="line">        setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">            &#x2F;&#x2F; this实际是其父级作用域中的this，箭头函数本身的this是不存在的，</span><br><span class="line">            &#x2F;&#x2F; 这就相当于箭头函数的this是在声明的时候就确定了</span><br><span class="line">            console.log(this, this.age); &#x2F;&#x2F; obj1 1</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>不可以作为构造函数来使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Person &#x3D; (name) &#x3D;&gt; &#123; &#x2F;&#x2F; Uncaught TypeError: Person is not a constructor</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person &#x3D; new Person(&#39;Jack&#39;);</span><br></pre></td></tr></table></figure>

<ul>
<li>不绑定arguments（如果要使用arguments的时候可以使用rest参数代替）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; (val) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(arguments); &#x2F;&#x2F; Uncaught ReferenceError: arguments is not defined</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用rest参数代替</span><br><span class="line">var foo &#x3D; (...args) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(args); &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">foo(1, 2, 3);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不可以使用yield命令，因此箭头函数不能用作Generator函数。</p>
</li>
<li><p>箭头函数不支持重命名函数参数，普通函数的函数参数支持重命名</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function func1(a, a) &#123;</span><br><span class="line">    console.log(a, arguments); &#x2F;&#x2F; 2 [1,2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var func2 &#x3D; (a,a) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(a); &#x2F;&#x2F; 报错：在此上下文中不允许重复参数名称</span><br><span class="line">&#125;;</span><br><span class="line">func1(1, 2); func2(1, 2);</span><br></pre></td></tr></table></figure>

<ul>
<li>箭头函数相对于普通函数语法更简洁优雅<br>箭头函数都是匿名函数，并且都不用写function</li>
</ul>
<h4 id="9-普通函数和构造函数的区别"><a href="#9-普通函数和构造函数的区别" class="headerlink" title="9. 普通函数和构造函数的区别"></a>9. 普通函数和构造函数的区别</h4><ul>
<li>构造函数也是一个普通函数，创建方式和普通函数一样，但构造函数习惯上首字母大写</li>
<li>构造函数和普通函数的区别在于：调用方式不一样。作用也不一样（构造函数用来新建实例对象）</li>
<li>调用方式不一样。<br>  a. 普通函数的调用方式：直接调用 person();<br>  b. 构造函数的调用方式：需要使用new关键字来调用 new Person();</li>
<li>构造函数的函数名与类名相同：Person( ) 这个构造函数，Person 既是函数名，也是这个对象的类名</li>
<li>内部用this 来构造属性和方法 </li>
<li>构造函数的执行流程<br>  a. 立刻在堆内存中创建一个新的对象<br>  b. 将新建的对象设置为函数中的this<br>  c. 逐个执行函数中的代码<br>  d. 将新建的对象作为返回值</li>
</ul>
<h4 id="10-JS有没有了解过函数式编程"><a href="#10-JS有没有了解过函数式编程" class="headerlink" title="10. JS有没有了解过函数式编程"></a>10. JS有没有了解过函数式编程</h4><p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>
<h4 id="11-跨域请求？如何允许跨域？"><a href="#11-跨域请求？如何允许跨域？" class="headerlink" title="11. 跨域请求？如何允许跨域？"></a>11. 跨域请求？如何允许跨域？</h4><p>向不同的host的请求被称作跨域请求<br>通过设置Cors headers即Access-Control-Allow系列来允许跨域。</p>
<h4 id="12-跨域问题如何解决"><a href="#12-跨域问题如何解决" class="headerlink" title="12. 跨域问题如何解决"></a>12. 跨域问题如何解决</h4><p>同源策略：浏览器安全策略，同协议、IP、端口的脚本才会执行；<br>只要协议、域名、端口有任何一个不同，都被当做是不同的域。</p>
<p>js跨域是指通过js在不同的域之间进行数据传输或通信。</p>
<ul>
<li>通过jsonp跨域：<br>jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据。<br>  a. 通过script标签引入js文件；<br>  b. js文件载入成功后会执行我们在url参数中指定的参数，并且会把需要的json数据作为参数传入</li>
<li>通过修改document.domain来跨子域；</li>
<li>使用window.name来跨域；</li>
</ul>
<h4 id="13-JSONP"><a href="#13-JSONP" class="headerlink" title="13. JSONP"></a>13. JSONP</h4><p>JSON是一种轻量级的数据传输格式。<br>JSONP（JSON with padding填充式JSON）：</p>
<ul>
<li>是一种非官方跨域数据交互协议，是应用JSON的一种新方法。</li>
<li>是用来解决跨域请求问题的。</li>
<li>由回调函数和数据两部分组成。</li>
</ul>
<p>原理：</p>
<ul>
<li>利用script标签的src属性来实现跨域；</li>
<li>通过将前端方法参数传递到服务端，然后由服务的注入参数之后再返回，实现服务器向客户端通信；</li>
<li>由于使用script标签的src属性，因此只支持get方法；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;GoJSONP&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.8.3.min.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type : &quot;get&quot;,</span><br><span class="line">            async: false,</span><br><span class="line">            url : &quot;http:&#x2F;&#x2F;www.practice-zhao.com&#x2F;student.php?id&#x3D;1&quot;,</span><br><span class="line">            dataType: &quot;jsonp&quot;,</span><br><span class="line">            jsonp:&quot;callback&quot;, &#x2F;&#x2F;请求php的参数名</span><br><span class="line">            jsonpCallback: &quot;jsonhandle&quot;,&#x2F;&#x2F;要执行的回调函数</span><br><span class="line">            success : function(data) &#123;</span><br><span class="line">                alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="14-CORS"><a href="#14-CORS" class="headerlink" title="14. CORS"></a>14. CORS</h4><p>CORS：全称”跨域资源共享”（Cross-origin resource sharing）。</p>
<p>CORS需要浏览器和服务器同时支持，才可以实现跨域请求，目前几乎所有浏览器都支持CORS，IE则不能低于IE10。CORS的整个过程都由浏览器自动完成，前端无需做任何设置，跟平时发送ajax请求并无差异。so，实现CORS的关键在于服务器，只要服务器实现CORS接口，就可以实现跨域通信。</p>
<p>请求类型：</p>
<blockquote>
<p>CORS分为简单请求和非简单请求(需预检请求)两类</p>
</blockquote>
<p>符合以下条件的，为简单请求</p>
<ol>
<li>请求方式使用下列方法之一：</li>
</ol>
<ul>
<li>GET</li>
<li>HEAD</li>
<li>POST</li>
</ul>
<ol start="2">
<li>Content-Type 的值仅限于下列三者之一：</li>
</ol>
<ul>
<li>text/plain</li>
<li>multipart/form-data</li>
<li>application/x-www-form-urlencoded</li>
</ul>
<p>当发生符合非简单请求（预检请求）的条件时，浏览器会自动先发送一个options请求，如果发现服务器支持该请求，则会将真正的请求发送到后端，反之，如果浏览器发现服务端并不支持该请求，则会在控制台抛出错误。</p>
<p>CORS从具体的代码实现上来说比较方便，前端几乎不需要写任何代码就可以支持。主要是靠服务端进行配置。而且是对各种请求方法、各种数据请求类型都是完美支持的。</p>
<p>CORS需要浏览器和服务器同时支持。目前所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<h4 id="15-浏览器的缓存机制"><a href="#15-浏览器的缓存机制" class="headerlink" title="15. 浏览器的缓存机制"></a>15. 浏览器的缓存机制</h4><p>浏览器缓存机制可以极大的提升用户体验。</p>
<p>浏览器缓存就是把一个已经请求过的web资源拷贝一份到浏览器中。<br>缓存会根据进来的请求保存输入内容的副本，当下一个请求到来的时候，如果是相同的url，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。</p>
<p>使用缓存原因：</p>
<ul>
<li>减少网络带宽消耗，降低运营成本；</li>
<li>降低服务器压力；</li>
<li>减少网络延迟；</li>
</ul>
<p>对于浏览器的缓存来讲，这些规则是在http协议头部和html页面的meta标签中定义的。<br>它们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。</p>
<p>过期机制：是缓存副本的有效期。<br>校验值：服务器返回资源的时候，有时在控制头信息带上这个资源的实体标签Etag，它们可以用来作为浏览器再次请求过程中的校验标识，如果不匹配，则资源已被修改或过期，浏览器需要重新获取资源内容。</p>
<h4 id="16-如何实现预加载，懒加载"><a href="#16-如何实现预加载，懒加载" class="headerlink" title="16. 如何实现预加载，懒加载"></a>16. 如何实现预加载，懒加载</h4><h5 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h5><p>懒加载也就是延迟加载; 当访问一个页面时,先将img标签中的src链接设为同一张图片(这样就只需请求一次,俗称占位图), 将其真正的图片地址存储在img标签的自定义属性中(比如data-src); 当js监听到该图片元素进入可视窗口时,即将自定义属性中的地址存储到src属性中,达到懒加载的效果; 这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢页面卡顿或崩溃等问题</p>
<ul>
<li><p>为什么要使用懒加载？<br>  懒加载对于图片较多页面很长的业务场景很适用,可以减少无效资源的加载</p>
</li>
<li><p>懒加载的实现步骤<br>  首先,不要将图片地址放到src属性中,而是放到其它属性(data-src)中<br>  页面加载完成后,根据scrollTop判断图片是否在用户的视野内, 如果在,则将data-original属性中的值取出存放到src属性中<br>  在滚动事件中重复判断图片是否进入视野; 如果进入,则将data-original属性中的值取出存放到src属性中<br>  代码实现</p>
</li>
</ul>
<p>利用懒加载和AJAX,我们还可以实现无限滚动查看时间线/ 在滚动页面一段距离后出现回到顶部按钮的效果</p>
<ul>
<li>懒加载的优点<br>  显著的提高页面加载速度,又不下载多余的资源节省了流量; 同时更少的图片并发请求数也可以减轻服务器的压力</li>
</ul>
<h5 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h5><p>提前加载图片,当用户需要查看时可直接从本地缓存中渲染</p>
<ul>
<li><p>为什么要使用预加载？<br>  图片预先加载到浏览器中,访问者可顺利地在网站上冲浪,并享受到极快的加载速度; 这对图片占据很大比例的网站来说十分有利,保证了图片快速/无缝地发布, 也可帮助用户在浏览网站内容时获得更好的用户体验</p>
</li>
<li><p>预加载的核心要点如下:<br>  图片等静态资源在使用前提前请求; 资源后续使用时可以从缓存中加载,提升用户体验; 页面展示的依赖关系维护(必需的资源加载完才可以展示页面,防止白屏等)</p>
</li>
<li><p>实现预加载主要有三个方法:<br>  用CSS和JavaScript实现预加载<br>  实现预加载图片有很多方法,包括使用CSS/JavaScript/两者的各种组合, 这些技术可根据不同设计场景设计出相应的解决方案,十分高效</p>
</li>
</ul>
<h4 id="17-事件委托"><a href="#17-事件委托" class="headerlink" title="17. 事件委托"></a>17. 事件委托</h4><p>事件代理（Event Delegation），又称之为事件委托。是JavaScript中常用绑定事件的常用技巧。<br>顾名思义，“事件代理”即是把原本需要绑定在子元素的响应事件（click、keydown……）委托给父元素，让父元素担当事件监听的职务。<br>事件代理的原理是DOM元素的事件冒泡。</p>
<ul>
<li><p>作用<br>  支持为同一个DOM元素注册多个同类型事件<br>  可将事件分成事件捕获和事件冒泡机制</p>
</li>
<li><p>优点<br>  可以大量节省内存占用，减少事件注册，比如在ul上代理所有li的click事件就非常棒<br>  可以实现当新增子对象时无需再次对其绑定（动态绑定事件）</p>
</li>
</ul>
<h4 id="18-设计模式有了解吗？（比如观察者模式）？"><a href="#18-设计模式有了解吗？（比如观察者模式）？" class="headerlink" title="18. 设计模式有了解吗？（比如观察者模式）？"></a>18. 设计模式有了解吗？（比如观察者模式）？</h4><p>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己</p>
<h4 id="19-Ajax的工作流程"><a href="#19-Ajax的工作流程" class="headerlink" title="19. Ajax的工作流程"></a>19. Ajax的工作流程</h4><p>实现一个AJAX异步调用和局部刷新,通常需要以下几个步骤:</p>
<ul>
<li>创建XMLHttpRequest对象,也就是创建一个异步调用对象.</li>
<li>创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息.</li>
<li>设置响应HTTP请求状态变化的函数.</li>
<li>发送HTTP请求.</li>
<li>获取异步调用返回的数据.</li>
<li>使用JavaScript和DOM实现局部刷新.</li>
</ul>
<h4 id="20-导致内存泄露的有哪些"><a href="#20-导致内存泄露的有哪些" class="headerlink" title="20. 导致内存泄露的有哪些"></a>20. 导致内存泄露的有哪些</h4><p>内存泄漏是指不再用到的内存，没有及时释放。既不能使用，又不能回收。</p>
<p>程序的运行需要内存。对于持续运行的进程，如果不及时释放不再用到的内存，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。</p>
<p>导致内存泄漏的几种情况：</p>
<ol>
<li>意外的全局变量</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function leaks()&#123; </span><br><span class="line">   leak &#x3D; &#39;xxxxxx&#39;;&#x2F;&#x2F;leak 成为一个全局变量，不会被回收</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用完函数以后，变量仍然存在,导致泄漏.<br>你可以通过加上 ‘use strict’ 启用严格模式来避免这类问题, 严格模式会阻止你创建意外的全局变量.</p>
<ol start="2">
<li>闭包<br>闭包可以维持函数内局部变量，使其得不到释放。<br>解决办法：在函数外部定义事件处理函数，解除闭包。或在闭包中，删除没用的属性以减少对内存的消耗。或在外部函数中删除对DOM的引用</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function bindEvent() </span><br><span class="line">&#123; </span><br><span class="line">    var obj&#x3D;document.createElement(&quot;XXX&quot;); </span><br><span class="line">    obj.onclick&#x3D;function()&#123; </span><br><span class="line">    &#x2F;&#x2F;Even if it&#39;s a empty function </span><br><span class="line">    &#125; </span><br><span class="line">    obj&#x3D;null; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>未清除 dom 元素的引用<br>dom 元素移除，但对dom元素的引用没有解除，会导致内存泄漏。<br>解决办法：手工移除。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var elements &#x3D; &#123;</span><br><span class="line">    button: document.getElementById(&#39;button&#39;),</span><br><span class="line">    image: document.getElementById(&#39;image&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doStuff() &#123;</span><br><span class="line">    image.src &#x3D; &#39;http:&#x2F;&#x2F;some.url&#x2F;image&#39;;</span><br><span class="line">    button.click();</span><br><span class="line">    console.log(text.innerHTML);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeButton() &#123;</span><br><span class="line">    document.body.removeChild(document.getElementById(&#39;button&#39;));</span><br><span class="line">    &#x2F;&#x2F; 虽然我们用removeChild移除了button, 但是还在elements对象里保存着#button的引用</span><br><span class="line">    &#x2F;&#x2F; 换言之, DOM元素还在内存里面.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>循环引用<br>循环引用 在引用计数策略下会导致内存泄漏，标记清除不会。<br>解决办法：手工解除循环引用。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">    var a &#x3D; &#123;&#125;;</span><br><span class="line">    var b &#x3D; &#123;&#125;;</span><br><span class="line">    a.pro &#x3D; b;</span><br><span class="line">    b.pro &#x3D; a;</span><br><span class="line">&#125; </span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p>a和b的引用次数都是2，fn()执行完毕后，两个对象都已经离开环境。<br>在标记清除方式下是没有问题的，但是在引用计数策略下，a和b的引用次数不为0，不会被垃圾回收器回收内存。如果fn函数被大量调用，就会造成内存泄漏。</p>
<p>IE中的BOM和DOM中的对象使用C++以COM（component Object Model，组件对象模型）对象的形式实现而COM对象的垃圾收集机制采用的是引用计数策略。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var element &#x3D; document.getElementById(&quot;some_element&quot;);</span><br><span class="line">var myObject &#x3D; new Object();</span><br><span class="line">myObject.e &#x3D; element;</span><br><span class="line">element.o &#x3D; myObject;</span><br><span class="line">&#x2F;&#x2F;手工断开它们之间的连接</span><br><span class="line">myObject.element&#x3D;null;</span><br><span class="line">element.someObject&#x3D;null;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>被遗忘的计时器或回调</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var someResource &#x3D; getData();</span><br><span class="line">setInterval(function() &#123;</span><br><span class="line">    var node &#x3D; document.getElementById(&#39;Node&#39;);</span><br><span class="line">    if(node) &#123;</span><br><span class="line">        node.innerHTML &#x3D; JSON.stringify(someResource));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<h4 id="21-XSS"><a href="#21-XSS" class="headerlink" title="21. XSS"></a>21. XSS</h4><ol>
<li><p>什么是XSS？<br> 全称是Cross Site Scripting即跨站脚本。<br> XSS是一种经常出现在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中。<br> 当目标网站目标用户浏览器渲染Html文档的过程中，出现了不被预期的脚本指令并执行时，XSS就发生了。</p>
</li>
<li><p>XSS分类</p>
</li>
</ol>
<ul>
<li><p>反射型XSS（非持久型，经过后端，不经过数据库）<br>  发出请求时，XSS代码出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射型XSS。</p>
</li>
<li><p>存储型XSS（持久型，经过后端，经过数据库）<br>  存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），<br>  下次请求目标页面时不用再提交XSS代码。</p>
<p>  最典型的例子是留言板XSS，用户提交一条包含XSS代码的留言存储到数据库，目标用户查看留言板时，<br>  那些留言的内容会从数据库查询出来并显示，浏览器发现有XSS代码，就当做正常的Html与Js解析执行，于是触发了XSS攻击。</p>
</li>
<li><p>DOM XSS（不经过后端，DOM-xss是通过url传入参数去控制触发的）<br>  DOM XSS和反射型XSS、存储型XSS的差别在于DOM XSS的代码并不需要服务器参与，触发XSS靠的是浏览器端的DOM解析，完全是客户端的事情。</p>
</li>
</ul>
<ol start="3">
<li>主要危害</li>
</ol>
<ul>
<li>盗取各类用户账号，如机器登录账号、用户网银账号、各类管理员账号</li>
<li>控制企业数据、包括读取、篡改、添加、删除企业敏感数据能力</li>
<li>盗取企业重要的具有商业价值的资料</li>
<li>非法转账</li>
<li>强制发送电子邮件</li>
<li>网站挂马</li>
<li>控制受害者机器向其它网站发起攻击</li>
</ul>
<ol start="4">
<li>防范手段</li>
</ol>
<ul>
<li>入参字符过滤<br>  在源头控制，把输入的一些不合法的东西都过滤掉，从而保证安全性。<br>  如：移除用户提交的DOM属性onerror，移除用户上传的style节点</li>
<li>出参进行编码<br>  如果源头没控制好，就得后期补救了：像一些常见的符号，如&lt;&gt;在输出的时候要对其进行转换编码，这样浏览器不会对该标签进行解释执行，同时不影响显示效果</li>
<li>入参长度限制<br>  xss攻击要达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过限制长度强制截断来预防。</li>
<li>设置cookie httponly为true</li>
</ul>
<h4 id="22-深浅拷贝"><a href="#22-深浅拷贝" class="headerlink" title="22. 深浅拷贝"></a>22. 深浅拷贝</h4><p>基本类型和引用类型</p>
<p>基本类型：number string boolean undefined null date<br>引用类型：array object function Math（Math和array object function的区别）</p>
<p>基本类型：是保存在栈中的简单数据类型<br>引用类型：是保存在堆内存中的对象，即变量中保存的是指向该对象的指针。</p>
<p>当B复制了A，如果修改A的数据，<br>B的数据发生了变化，就是浅拷贝；<br>否则就是深拷贝。</p>
<p>实现深拷贝：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.slice()</span><br><span class="line">concat()</span><br><span class="line">array.from()</span><br><span class="line">object.assign()</span><br><span class="line">JSON.parse(JSON.stringfy(obj))</span><br></pre></td></tr></table></figure>

<h4 id="23-js实现判断一个变量是否为整数的函数"><a href="#23-js实现判断一个变量是否为整数的函数" class="headerlink" title="23. js实现判断一个变量是否为整数的函数"></a>23. js实现判断一个变量是否为整数的函数</h4><p>先判断是否为Number类型，再判断除以1后是否与原值相等。</p>
<h4 id="24-null和undefined有什么区别？"><a href="#24-null和undefined有什么区别？" class="headerlink" title="24. null和undefined有什么区别？"></a>24. null和undefined有什么区别？</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(null&#x3D;&#x3D;undefined)&#x2F;&#x2F;true</span><br><span class="line">console.log(null&#x3D;&#x3D;&#x3D;undefined)&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
<p>null和undefined 两者相等，但是当两者做全等比较时，两者又不等</p>
<p>null： Null类型，代表“空值”，代表一个空对象指针，使用typeof运算得到 “object”，所以你可以认为它是一个特殊的对象值<br>undefined： Undefined类型，当一个声明了一个变量未初始化时，得到的就是undefined</p>
<p>null表示”没有对象”，即该处不应该有值。典型用法是：<br>    a. 作为函数的参数，表示该函数的参数不是对象。<br>    b. 作为对象原型链的终点。</p>
<p>undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：<br>    a. 变量被声明了，但没有赋值时，就等于undefined。<br>    b. 调用函数时，应该提供的参数没有提供，该参数等于undefined。<br>    c. 对象没有赋值的属性，该属性的值为undefined。<br>    d. 函数没有返回值时，默认返回undefined。</p>
<h4 id="25-NaN-typeof后输出Number"><a href="#25-NaN-typeof后输出Number" class="headerlink" title="25. NaN typeof后输出Number"></a>25. NaN typeof后输出Number</h4><h4 id="26-js的隐形转换和显性转换"><a href="#26-js的隐形转换和显性转换" class="headerlink" title="26. js的隐形转换和显性转换"></a>26. js的隐形转换和显性转换</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">隐性转换为： 1 + &#39;1&#39; &#x3D; &#39;11&#39;</span><br><span class="line"></span><br><span class="line">显性转换</span><br><span class="line">Number(&quot;24 cccc&quot;);&#x2F;&#x2F;结果：NaN</span><br><span class="line">ParseInt(&quot;24 cccc&quot;);&#x2F;&#x2F;结果：24</span><br><span class="line">备注：Number的显性转换比较严格，若无法强转则直接报错</span><br><span class="line"></span><br><span class="line">面试官后引伸了两个问题</span><br><span class="line">1 + -&#39;1&#39; + 1 等于什么</span><br><span class="line">等于 0 ，&#39;1&#39;前面的负号把其数字化，变为-1，则后值为1</span><br><span class="line">&#39;A&#39; - &#39;B&#39; 等于什么</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure>

<h4 id="postMessage原理"><a href="#postMessage原理" class="headerlink" title="postMessage原理"></a>postMessage原理</h4><h4 id="JS模块化的实践"><a href="#JS模块化的实践" class="headerlink" title="JS模块化的实践"></a>JS模块化的实践</h4><h4 id="实现gulp的功能"><a href="#实现gulp的功能" class="headerlink" title="实现gulp的功能"></a>实现gulp的功能</h4>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机原理</title>
    <url>/articles/2020-02-08-interview-httpNet.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-计算机网络的七层"><a href="#1-计算机网络的七层" class="headerlink" title="1. 计算机网络的七层"></a>1. 计算机网络的七层</h4><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p>
<h4 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h4><ul>
<li>TCP：<br>  面向连接、<br>  传输可靠(保证数据正确性，保证数据顺序)、<br>  用于传输大量数据(流模式)、<br>  速度慢、<br>  建立连接需要开销比较多（时间、系统资源）。</li>
</ul>
<p>一般用于文件传输、发送接收邮件、远程登录等。</p>
<ul>
<li>UDP：<br>  面向非连接、<br>  传输不可靠、<br>  用于传输少量数据(数据包模式)、<br>  速度快。</li>
</ul>
<p>用于即时通信。</p>
<h4 id="3-http、https"><a href="#3-http、https" class="headerlink" title="3. http、https"></a>3. http、https</h4><p>http：超文本传输协议，是一个客户端和服务端请求和应答、无状态的、应用层的协议，<br>用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>特点：</p>
<ul>
<li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作；</li>
<li>无连接：每次请求都要通过TCP三次握手四次挥手，和服务器重新建立连接。消耗不必要的时间和流量；</li>
<li>基于请求和响应：客户端发起请求，服务端响应；</li>
<li>简单快速、灵活；</li>
<li>通信使用明文、请求和响应不会对通信方进行确认、无法保证数据的完整性；</li>
</ul>
<p>https：是一种通过计算机网络进行安全通信的传输协议，是以安全为目标的Http通道，简单说是http的安全版，利用SSL/TLS建立全信道，加密数据包。</p>
<p>特点：</p>
<ul>
<li>内容加密：采用混合加密技术，中间者无法直接查看明文内容；</li>
<li>验证身份：通过证书认证客户端访问的是自己的服务器；</li>
<li>保护数据完整性：防止传输的内容被中间人冒充或篡改；</li>
</ul>
<h4 id="4-http和TCP的区别"><a href="#4-http和TCP的区别" class="headerlink" title="4. http和TCP的区别"></a>4. http和TCP的区别</h4><p>http对应于应用层，是在tcp协议之上建立的，http在发起请求时通过tcp协议建立起连接服务器的通道，请求结束后，立即断开tcp连接；</p>
<p>http是无状态的短连接，tcp是有状态的长连接；</p>
<p>tcp对应于传输层；</p>
<h4 id="5-几种常见的状态码"><a href="#5-几种常见的状态码" class="headerlink" title="5. 几种常见的状态码"></a>5. 几种常见的状态码</h4><ul>
<li><p>2XX：请求已成功被服务器接收、理解；</p>
</li>
<li><p>200：请求已成功；</p>
</li>
<li><p>201：请求成功并且服务器创建了新的资源；</p>
</li>
<li><p>3XX：需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址在本次响应的location域中声明；</p>
</li>
<li><p>301：重定向，被请求的资源已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置；</p>
</li>
<li><p>302：请求的资源临时从不同的URL响应请求，但请求者应继续使用原有位置来进行以后的请求；</p>
</li>
<li><p>304：自从上次请求，网页未修改过，服务器返回次响应，不会返回网页内容；</p>
</li>
<li><p>4XX：请求错误。</p>
</li>
<li><p>401：请求要求身份验证；</p>
</li>
<li><p>403：服务器以理解请求，但拒绝执行；</p>
</li>
<li><p>404：请求失败；</p>
</li>
<li><p>5XX：服务器异常；</p>
</li>
<li><p>406</p>
</li>
<li><p>407</p>
</li>
<li><p>301 302 304 区别</p>
</li>
<li><p>206 204</p>
</li>
</ul>
<h4 id="6-进程和线程"><a href="#6-进程和线程" class="headerlink" title="6. 进程和线程"></a>6. 进程和线程</h4><p>线程是最小的执行单元，进程是由线程组成。<br>如何调度线程和进程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
<p>进程是计算机中已运行的程序。<br>线程是操作系统能够运行调度的最小单位。</p>
<h4 id="7-死锁"><a href="#7-死锁" class="headerlink" title="7. 死锁"></a>7. 死锁</h4><p>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但没有一方愿意提前退出，就成为死锁。</p>
<h4 id="8-http、https说一下过程？"><a href="#8-http、https说一下过程？" class="headerlink" title="8. http、https说一下过程？"></a>8. http、https说一下过程？</h4><p>http建立连接过程</p>
<ul>
<li>客户端向服务端发送请求报文</li>
<li>服务端根据请求报文收集对应的资源组合成响应报文</li>
<li>客户端收到响应报文，进行解析</li>
</ul>
<h4 id="9-三次握手与四次挥手"><a href="#9-三次握手与四次挥手" class="headerlink" title="9. 三次握手与四次挥手"></a>9. 三次握手与四次挥手</h4><h4 id="10-OSI七层协议？"><a href="#10-OSI七层协议？" class="headerlink" title="10. OSI七层协议？"></a>10. OSI七层协议？</h4><h4 id="11-描述一下HTTP-协议缓存机制"><a href="#11-描述一下HTTP-协议缓存机制" class="headerlink" title="11. 描述一下HTTP 协议缓存机制"></a>11. 描述一下HTTP 协议缓存机制</h4><p>Http缓存主要分为强缓存和协商环迅</p>
<p>强缓存：所请求的数据在缓存数据库中尚未过期时，不与服务器进行交互，直接使用缓存数据库中的数据。<br>    若缓存未命中时，则重新向服务器请求数据。</p>
<p>协商缓存：当强缓存过期未命中或响应报文Cache-Control中有must-revalidate标识必须每次请求验证资源的状态时，便使用协商缓存的方式去处理缓存文件。<br>    主要原理是从缓存数据中取出缓存的标识，然后向浏览器发送请求验证请求的数据是否已经更新，如果已更新则返回新的数据，若未更新则使用缓存数据库中的数据。</p>
<h4 id="12-URL解析"><a href="#12-URL解析" class="headerlink" title="12. URL解析"></a>12. URL解析</h4><h4 id="13-内存和磁盘的区别"><a href="#13-内存和磁盘的区别" class="headerlink" title="13. 内存和磁盘的区别"></a>13. 内存和磁盘的区别</h4><ul>
<li>内存<br>又称主存，计算机中的程序的运行都是在内存中运行的，只有计算机在运行，计算机CPU就会把需要的计算数据调到内存中进行运算。<br>内存分为随机存储器（RAM）、只读存储器（ROM）、高速缓存（CACHE）。</li>
</ul>
<p>程序运行时，内存和磁盘的作用及相互关系。<br>计算机在运行程序时，必须将磁盘中的内容加载到内存中，不加载是不能运行程序的。<br>在内存中有一部分的数据存的是磁盘的缓存，这样就可以加速磁盘访问速度。就如我们开发程序中使用的缓存作用一样。</p>
<p>虚拟内存：<br>是指把磁盘中的一部分作为假想的内存使用，windows通过分页式虚拟内存机制：即在不考虑程序构造的情况下将程序按照一定大小的页进行划分，并以页为单位在内存和磁盘间进行置换。一般来说自己计算机的实际内存大小即为当前页文件的大小，这个是可以在电脑中进行设定的。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/articles/2020-02-08-interview-vue.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-Vue生命周期"><a href="#1-Vue生命周期" class="headerlink" title="1. Vue生命周期"></a>1. Vue生命周期</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>Vue生命周期是Vue实例从创建到销毁的过程。</p>
<p>从开始创建、初始化数据、编译模板、挂在DOM-&gt;渲染、更新-&gt;渲染、销毁等一系列过程。</p>
<p>创建前/后、载入前/后、更新前/后、销毁前/后。</p>
<h5 id="生命周期线"><a href="#生命周期线" class="headerlink" title="生命周期线"></a>生命周期线</h5><ol>
<li>beforeCreate：创建前。新对象诞生，在对象初始化之前执行；</li>
<li>created：创建后。创建具有默认特性的对象；</li>
<li>beforeMount：载入前。在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html，此时还没有挂载html到页面上；</li>
<li>mounted：载入后。创建vm.$el替换，并挂载到实例上去之后调用，实例已完成：用上面编译好的html内容替换el指向的DOM对象，完成模板中的html渲染到html页面中；</li>
<li>beforeUpdate：更新前。数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步更改状态，不会触发附加的重渲染过程；</li>
<li>updated：更新后。调用时，组件DOM已经更新；</li>
<li>beforeDestory：销毁前。实例仍然完全可用；</li>
<li>destoryed：销毁后。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
</ol>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>控制整个Vue实例过程时更容易形成好的逻辑。</p>
<h5 id="第一次加载页面会触发几个钩子？"><a href="#第一次加载页面会触发几个钩子？" class="headerlink" title="第一次加载页面会触发几个钩子？"></a>第一次加载页面会触发几个钩子？</h5><p>四个，beforeCreated、created、beforeMount、mounted。</p>
<h4 id="2-Vue-router实现原理，包括哪几种导航钩子，如何定义vue-router的动态路由？怎么获取传过来的动态参数"><a href="#2-Vue-router实现原理，包括哪几种导航钩子，如何定义vue-router的动态路由？怎么获取传过来的动态参数" class="headerlink" title="2. Vue-router实现原理，包括哪几种导航钩子，如何定义vue-router的动态路由？怎么获取传过来的动态参数"></a>2. Vue-router实现原理，包括哪几种导航钩子，如何定义vue-router的动态路由？怎么获取传过来的动态参数</h4><p>vue-router通过hash与history两种方式实现前端路由，<strong>更新视图但不重新请求页面</strong>是前端路由原理的核心之一。</p>
<ul>
<li>hash：利用URL中的hash（“#”）,在URL后加#，是url中的锚点，代表网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。</li>
<li>history：是Html5新增的方法，不刷新整个页面实现URL跳转。</li>
<li>abstract：支持所有JavaScript运行环境，不依赖于浏览器的浏览历史虚拟管理后端。</li>
</ul>
<p>vue-router通过mode参数来决定采用哪一种方式，默认是hash</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;routes&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  &#x2F;&#x2F; mode: &#39;history&#39;,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line">mode：hash</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;#&#x2F;recommend</span><br><span class="line">mode：history</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;recommend</span><br></pre></td></tr></table></figure>

<p>包含三种导航钩子：</p>
<ul>
<li>全局导航钩子：router.beforeEach(to, from, next)<br>作用：跳转前进行判断拦截。</li>
<li>组件内的钩子</li>
<li>单独路由独享组件</li>
</ul>
<p>在router目录下的index.js文件中，对path属性加上/:id。<br>使用router对象的params.id，如：this.$route.params.id</p>
<h4 id="3-MVVM框架"><a href="#3-MVVM框架" class="headerlink" title="3. MVVM框架"></a>3. MVVM框架</h4><p>一个model+view+viewModel框架，数据模型model、viewModel连接两个</p>
<ul>
<li>当前台显示的view发生变化，会实时反应到viewModel上，如果需要，viewModel会通过ajax等方法将改变的数据传递给后台model。</li>
<li>同时后台model获取过来的数据，通过vm将值响应到前台UI上。</li>
</ul>
<p>和其他框架(jquery)的区别：vue数据驱动，通过数据来显示视图而不是节点操作。<br>使用场景：数据操作比较多的场景，更加便捷。</p>
<h4 id="4-vue-model双向绑定原理"><a href="#4-vue-model双向绑定原理" class="headerlink" title="4. vue-model双向绑定原理"></a>4. vue-model双向绑定原理</h4><p>透过MVVM模式实现vue的双向绑定数据。<br>通过Object.defineProperty实现的。</p>
<p>当data变化时，通过Object.definePrototype()方法的set进行监控，并调用在此之前已经定义好的data和view，来通知view进行数据的改变。<br>view发生改变则是通过底层的input事件进行data的响应更改。</p>
<p>vue是通过Object.definePrototype()来实现数据劫持的。</p>
<p>实现方法：观察者模式</p>
<ul>
<li>数据监听器Obverser，对data中的数据进行监听，若有变化，通知响应的订阅者；</li>
<li>实现一个指令解析器compile，对于每个元素上的指令进行解析，根据指令替换数据，更新视图；</li>
<li>实现一个watcher，用来连接obverser和compile，并为每个属性绑定相应的订阅者，当数据发生变化，执行响应的回调函数，从而更新视图；</li>
<li>构造函数new Vue</li>
</ul>
<h4 id="5-options预检请求"><a href="#5-options预检请求" class="headerlink" title="5. options预检请求"></a>5. options预检请求</h4><p>cors：cross-origin resource sharing跨域资源共享，是一个系统，由一系列传输的http头组成，这些http头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应。</p>
<p>同源安全策略默认阻止“跨域”获取资源。但cors给了web服务器这样的权限，即服务器可以选择允许跨域请求访问到它们的资源。</p>
<h5 id="6-简单请求和非简单请求"><a href="#6-简单请求和非简单请求" class="headerlink" title="6. 简单请求和非简单请求"></a>6. 简单请求和非简单请求</h5><p>simple request:</p>
<blockquote>
<p>请求方法是以下三种之一：HEAD、GET、POST<br>HTTP头部信息不超出以下几种字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain。</p>
</blockquote>
<p>   not-so-simple request：不满足以上条件的就是非简单请求。<br>   常见的非简单请求有：</p>
<blockquote>
<p>请求方法是put或delete<br>content-type类型为application/json<br>添加额外的http header</p>
</blockquote>
<h5 id="7-浏览器在什么情况下发起options预检请求？"><a href="#7-浏览器在什么情况下发起options预检请求？" class="headerlink" title="7. 浏览器在什么情况下发起options预检请求？"></a>7. 浏览器在什么情况下发起options预检请求？</h5><p>在跨域情况下，非简单请求会先发起一次空body的options请求，成为“预检”请求，用于向服务器请求权限信息，等预检请求被成功响应后，才发起真正的http请求。</p>
<blockquote>
<p>浏览器的预检请求结果可以通过设置Access-Control-Max-Age进行缓存。</p>
</blockquote>
<h4 id="8-babel"><a href="#8-babel" class="headerlink" title="8. babel"></a>8. babel</h4><p>实现ES6编译为ES5代码</p>
<h4 id="9-Vue-router跳转和Location-href区别？vue-router是什么？有哪些组件？"><a href="#9-Vue-router跳转和Location-href区别？vue-router是什么？有哪些组件？" class="headerlink" title="9. Vue router跳转和Location.href区别？vue-router是什么？有哪些组件？"></a>9. Vue router跳转和Location.href区别？vue-router是什么？有哪些组件？</h4><p>router是hash改变<br>href是页面跳转，刷新页面</p>
<p>vue用来写路由一个插件，router-link、router-view</p>
<h4 id="10-npm-webpack的理解"><a href="#10-npm-webpack的理解" class="headerlink" title="10. npm webpack的理解"></a>10. npm webpack的理解</h4><p>webpack官方文档说是一个module bundler(模块打包器)。<br>webpack能够把vue后缀名的文件打包成浏览器能够识别的js，而这个vue文件装换需要打包器vue-loader;<br>vue-loader打包器是可以从npm上下载的，npm下载文件之后，webpack打包文件时需要在node环境去运行；</p>
<p>通过webpack对模块进行打包，既保留了单个模块的可维护性，又减少了页面的http请求，减少了页面加载时间，从而增加了页面的显示速度，让整个应用的体验更好。</p>
<h4 id="11-Vuex整个触发过程（actions，state，view）？"><a href="#11-Vuex整个触发过程（actions，state，view）？" class="headerlink" title="11. Vuex整个触发过程（actions，state，view）？"></a>11. Vuex整个触发过程（actions，state，view）？</h4><p>状态管理三个部分：state、view、actions</p>
<p>整个vuex的核心是store，vuex的状态是响应式的，当Vue组件从store中读取状态的时候，若store中状态发生变化，那么相应的组件也会相应的得到高效更新。<br>不能直接更改store中的状态，改变store中的状态的唯一途径是显式提交commit mutation</p>
<ul>
<li>state：vuex通过store将状态从根组件注入到每个子组件中</li>
<li>Getters：从state派生出的状态</li>
<li>Mutation：提交mutation是更改vuex的store中状态的唯一方式，必须同步</li>
<li>Action：提交的是mutation，而不是直接变更状态，可以包含任意异步操作</li>
<li>Modules：将store分割成模块</li>
</ul>
<h4 id="12-Vue和Vuex有什么差别？"><a href="#12-Vue和Vuex有什么差别？" class="headerlink" title="12. Vue和Vuex有什么差别？"></a>12. Vue和Vuex有什么差别？</h4><p>Vuex是Vue的一个插件，是一个专门为Vue应用程序开发的状态管理模式。<br>开发模式或框架，通过状态（数据源）集中管理驱动组件的变化</p>
<p>在main.js中引入store，注入。<br>新建了一个目录store，export。</p>
<p>应用级的状态集中放在store中，改变状态的方式是提交mutations，这是个同步的事物；<br>异步逻辑应该封装在action中。</p>
<p>采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>场景有：单页应用中、组件之间的状态、音乐播放、登录状态、加入购物车</p>
<h4 id="13-React和Vue有什么区别？"><a href="#13-React和Vue有什么区别？" class="headerlink" title="13. React和Vue有什么区别？"></a>13. React和Vue有什么区别？</h4><h4 id="14-怎么上手的vue，以及为啥用vue而不用其他框架？"><a href="#14-怎么上手的vue，以及为啥用vue而不用其他框架？" class="headerlink" title="14. 怎么上手的vue，以及为啥用vue而不用其他框架？"></a>14. 怎么上手的vue，以及为啥用vue而不用其他框架？</h4><h4 id="15-你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？"><a href="#15-你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？" class="headerlink" title="15. 你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？"></a>15. 你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？</h4><h4 id="16-知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？"><a href="#16-知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？" class="headerlink" title="16. 知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？"></a>16. 知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？</h4><h4 id="17-为什么你们的页面要用到vue-router呢-，如果没有vue-router，你们还会做单页面应用吗？vue等单页面应用及优缺点"><a href="#17-为什么你们的页面要用到vue-router呢-，如果没有vue-router，你们还会做单页面应用吗？vue等单页面应用及优缺点" class="headerlink" title="17. 为什么你们的页面要用到vue-router呢?，如果没有vue-router，你们还会做单页面应用吗？vue等单页面应用及优缺点"></a>17. 为什么你们的页面要用到vue-router呢?，如果没有vue-router，你们还会做单页面应用吗？vue等单页面应用及优缺点</h4><p>单页面应用：将所有的内容放在一个页面上么</p>
<p>优点：</p>
<ul>
<li>具有桌面应用的即时性、网站的可移植性和可访问性；</li>
<li>用户体验好、快、内容的改变不需要重新加载整个页面；</li>
<li>基于上面一点，SPA相对对服务器压力小；</li>
<li>良好的前后端分离。SPA和Restful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化；</li>
<li>同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；</li>
</ul>
<p>缺点：</p>
<ul>
<li>不利于SEO；</li>
<li>初次加载耗时相对增多；</li>
<li>导航不可用，如果一定要自行实现前进、后退；</li>
</ul>
<h4 id="18-传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？"><a href="#18-传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？" class="headerlink" title="18. 传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？"></a>18. 传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？</h4><ul>
<li>DNS解析：将域名解析成IP地址</li>
<li>TCP连接：TCP三次握手</li>
<li>发生Http请求</li>
<li>服务器处理请求并返回Http报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接：TCP四次挥手</li>
</ul>
<h4 id="19-Vue中Compile过程说一下？"><a href="#19-Vue中Compile过程说一下？" class="headerlink" title="19. Vue中Compile过程说一下？"></a>19. Vue中Compile过程说一下？</h4><p>compile作用是解析模板，生成渲染模板的render</p>
<h4 id="20-Vue的设计思路你了解吗"><a href="#20-Vue的设计思路你了解吗" class="headerlink" title="20. Vue的设计思路你了解吗"></a>20. Vue的设计思路你了解吗</h4><p>核心思想是数据驱动和组件化</p>
<ul>
<li><p>数据驱动—双向绑定<br>Vue是MVVM框架，DOM是数据的一种自然映射</p>
</li>
<li><p>组件化<br>组件化就是实现了扩展Html元素，封装可用的代码</p>
</li>
</ul>
<h4 id="21-Vue的响应式是怎么实现的？"><a href="#21-Vue的响应式是怎么实现的？" class="headerlink" title="21. Vue的响应式是怎么实现的？"></a>21. Vue的响应式是怎么实现的？</h4><p>使用Object.defineProperty 这个函数来进行监听</p>
<h4 id="22-proxy数据代理的实现"><a href="#22-proxy数据代理的实现" class="headerlink" title="22. proxy数据代理的实现"></a>22. proxy数据代理的实现</h4><p>Proxy用于修改某些操作的默认行为,等同于在语言层面做出修改.<br>Proxy在目标对象前架设一层”拦截”.外界对该对象的访问都必须通过这一层拦截,对外界的访问进行过滤和改写</p>
<p>ES6原生提供了Proxy构造函数,用来生成Proxy实例</p>
<p>在之前的 Vue2.x 版本中，由于 Object.defineProperty 的限制，所以 我们在使用中遇到了无法监听 属性的添加和删除、数组索引和长度的变更等一系列问题，<br>在最新的  Proxy 属性中很好的解决了这一问题。而且支持 Map、Set、WeakMap 和 WeakSet</p>
<p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）<br>Proxy 就是在操作目标对象之前进行了”代理（或者说劫持）”，可以对外界的操作进行过滤和改写，修改操作的默认行为</p>
<h5 id="23-封装组件"><a href="#23-封装组件" class="headerlink" title="23. 封装组件"></a>23. 封装组件</h5><p>性能提高</p>
<h5 id="24-vue中key的作用"><a href="#24-vue中key的作用" class="headerlink" title="24. vue中key的作用"></a>24. vue中key的作用</h5><p>key的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。<br>如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。<br>使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>
<p>有相同父元素的子元素必须有独特的key。重复的key会造成渲染错误。</p>
<p>最常见的是结合v-for：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li v-for&#x3D;&quot;item in items&quot; :key&#x3D;&quot;item.id&quot;&gt;&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>它也可以用于强制替换元素/组件而不是重复使用它。</p>
<h5 id="25-vue中子组件调用父组件的方法"><a href="#25-vue中子组件调用父组件的方法" class="headerlink" title="25. vue中子组件调用父组件的方法"></a>25. vue中子组件调用父组件的方法</h5><p>this.$emit()</p>
<h5 id="26-vue"><a href="#26-vue" class="headerlink" title="26. vue"></a>26. vue</h5><h5 id="27-v-if和v-show指令的共同和不同点"><a href="#27-v-if和v-show指令的共同和不同点" class="headerlink" title="27. v-if和v-show指令的共同和不同点"></a>27. v-if和v-show指令的共同和不同点</h5><ul>
<li>v-show指令是通过修改元素的displayCSS属性让其显示或隐藏；</li>
<li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果；</li>
</ul>
<h5 id="28-让CSS只在当前组件中起作用"><a href="#28-让CSS只在当前组件中起作用" class="headerlink" title="28. 让CSS只在当前组件中起作用"></a>28. 让CSS只在当前组件中起作用</h5><figure class="highlight plain"><figcaption><span>scoped>```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 29. &lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;的作用是什么</span><br><span class="line">&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;包裹动态组件时，会缓存不活动的组件实例，主要用于保留组件状态或避免重新渲染。</span><br><span class="line">比如有一个列表和一个详情，那么用户就会经常执行打开详情&#x3D;&gt;返回列表&#x3D;&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用&lt;keep-alive&gt;&lt;&#x2F;keep-alive&gt;进行缓存，</span><br><span class="line">这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</span><br><span class="line"></span><br><span class="line">##### 30. Vue中引入组件的步骤</span><br><span class="line">1. 采用ES6的import...from语法</span><br><span class="line">    或CommonJS的require方法引入组件</span><br><span class="line">  </span><br><span class="line">2. 对组件进行注册</span><br></pre></td></tr></table></figure>
<p>Vue.component(‘my-component’, template:’<div>a component</div>‘)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3. 使用组件&lt;my-component&gt;&lt;&#x2F;my-component&gt;</span><br><span class="line"></span><br><span class="line">##### 31. 指令v-el的作用是什么</span><br><span class="line">提供一个在页面上已存在的DOM元素作为Vue实例的挂载目标，可以是CSS选择器，也可以是一个HTMLElement实例。</span><br><span class="line"></span><br><span class="line">##### 32. 在Vue中使用插件的步骤</span><br><span class="line">* 采用ES6的import...from语法</span><br><span class="line">* 使用全局方法Vue.use(plugin)使用插件，可以传入一个选项对象</span><br><span class="line">Vue.use(Myplugin, &#123;someOptions: true&#125;)</span><br><span class="line"></span><br><span class="line">##### 33. vue watch的高级用法--监听对象的属性变化</span><br><span class="line">1. 监听对象需要深度监听，如下可以监听整个msg对象的变化</span><br></pre></td></tr></table></figure>
<p>watch: {<br>  msg: {<br>    handler(newValue, oldValue) {<br>      console.log(newValue)<br>    },<br>    deep: true<br>  }<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2. 监听对象里面某个属性的变化，通过computed做中间层实现</span><br></pre></td></tr></table></figure>
<p>computed: {<br>　　channel() {<br>　　　　return this.msg.channel<br>　　}<br>  },<br>  watch:{<br>    channel(newValue, oldValue) {<br>　　　　console.log(‘new: %s, old: %s’, newval, oldVal)<br>　　　　//这里面可以执行一旦监听的值发生变化你想做的操作<br>　　}<br>  }</p>
<p>  ```</p>
<h5 id="34-active-class是哪个组件的属性？嵌套路由怎么定义"><a href="#34-active-class是哪个组件的属性？嵌套路由怎么定义" class="headerlink" title="34. active-class是哪个组件的属性？嵌套路由怎么定义"></a>34. active-class是哪个组件的属性？嵌套路由怎么定义</h5><p>vue-router模块的router-link组件</p>
<h5 id="35-scss是什么，特性"><a href="#35-scss是什么，特性" class="headerlink" title="35. scss是什么，特性"></a>35. scss是什么，特性</h5><p>预处理css，把css当成函数编写，定义变量、嵌套。<br>先装css-loader, node-loader, sass-loader等加载器模块，<br>在webpack-base.config.js配置文件中加多一个拓展:extenstion，<br>再加多一个模块：module里面test、loader</p>
<p>特性：</p>
<ul>
<li>可以用变量</li>
<li>可以用混合器</li>
<li>可以嵌套</li>
</ul>
<h5 id="36-mint-ui是什么？如何使用？至少三个组件使用方法"><a href="#36-mint-ui是什么？如何使用？至少三个组件使用方法" class="headerlink" title="36. mint-ui是什么？如何使用？至少三个组件使用方法"></a>36. mint-ui是什么？如何使用？至少三个组件使用方法</h5><p>基于vue的前端组件库。<br>npm安装，然后import样式和js，vue.use(mintUi)全局引入。<br>在单个组件局部引入：<code>import {Toast} from &#39;mint-ui&#39;</code></p>
<ul>
<li>Toast(‘登录成功’)</li>
<li>mint-header</li>
<li>mint-swiper</li>
</ul>
<h5 id="37-axios是什么？如何使用？描述使用它实现登录功能的流程"><a href="#37-axios是什么？如何使用？描述使用它实现登录功能的流程" class="headerlink" title="37. axios是什么？如何使用？描述使用它实现登录功能的流程"></a>37. axios是什么？如何使用？描述使用它实现登录功能的流程</h5><p>请求后台资源的模块。<br>npm install axios -s装好，然后发送的是跨域，需要配置文件中config/index.js进行配置。<br>js中使用import进来，然后get或post，返回在then函数中如果成功，失败则在catch函数中。</p>
<h5 id="38-什么是Restful-api？"><a href="#38-什么是Restful-api？" class="headerlink" title="38. 什么是Restful api？"></a>38. 什么是Restful api？</h5><p>一个api的标准，无状态请求。<br>请求的路由地址是固定的，如果是tp5则先路由配置中把资源路由配置好，标准有：post、put、delete</p>
<h5 id="39-自定义指令（v-check、v-focus）的方法有哪些？有哪些钩子函数？"><a href="#39-自定义指令（v-check、v-focus）的方法有哪些？有哪些钩子函数？" class="headerlink" title="39. 自定义指令（v-check、v-focus）的方法有哪些？有哪些钩子函数？"></a>39. 自定义指令（v-check、v-focus）的方法有哪些？有哪些钩子函数？</h5><p>全局定义指令：在vue对象的directive方法里面有两个参数，一个是指令名称，一个是函数。<br>组件内定义指令：directives<br>钩子函数：bind（绑定事件触发）、inserted（节点插入的时候触发）、updated（组件内相关更新）<br>钩子函数参考：el、binding</p>
<h5 id="40-导航钩子有哪些，有哪些参数"><a href="#40-导航钩子有哪些，有哪些参数" class="headerlink" title="40. 导航钩子有哪些，有哪些参数"></a>40. 导航钩子有哪些，有哪些参数</h5><p>导航钩子有：</p>
<ul>
<li>全局钩子和组件内独享的钩子；</li>
<li>beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave<br>参数：to（去的路由）、from（离开的路由）、next（一定要用这个函数才能去到下一个路由）</li>
</ul>
<h5 id="41-封装vue组件的过程"><a href="#41-封装vue组件的过程" class="headerlink" title="41. 封装vue组件的过程"></a>41. 封装vue组件的过程</h5><p>首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。<br>然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件，可以采用emit方法。</p>
<h5 id="42-vue-loader是什么？使用它的用途有哪些？"><a href="#42-vue-loader是什么？使用它的用途有哪些？" class="headerlink" title="42. vue-loader是什么？使用它的用途有哪些？"></a>42. vue-loader是什么？使用它的用途有哪些？</h5><p>解析vue文件的一个加载器，跟template/js/style转换成js模块。<br>用途：js可以写es6、style样式可以scss或less、template可以加jade等。</p>
<h5 id="43-vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#43-vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="43. vue.cli项目中src目录每个文件夹和文件的用法？"></a>43. vue.cli项目中src目录每个文件夹和文件的用法？</h5><p>assets文件夹是放静态资源<br>components是放组件<br>router是定义路由相关的配置<br>view视图<br>app.vue是一个应用主组件<br>main.js是入口文件。</p>
<h5 id="44-vue-cli是如何自定义的组件？"><a href="#44-vue-cli是如何自定义的组件？" class="headerlink" title="44. vue-cli是如何自定义的组件？"></a>44. vue-cli是如何自定义的组件？</h5><ul>
<li>在components目录新建组件文件(smithButton.vue)，script一定要export default</li>
<li>在需要的页面（组件）中导入：import smithButton from ../smithButton.vue</li>
<li>注入到vue的子组件的components属性上面：components: {smithButton}</li>
<li>在template视图view中使用，<code>&lt;smith-button&gt;&lt;/smith-button&gt;</code></li>
</ul>
<h5 id="45-你对Vuejs的template编译的理解"><a href="#45-你对Vuejs的template编译的理解" class="headerlink" title="45. 你对Vuejs的template编译的理解"></a>45. 你对Vuejs的template编译的理解</h5><p>就是先转换成AST树，再得到的render函数返回VNode（Vue的虚拟DOM节点）。</p>
<p>首先：通过compile编译器把template编译成AST语法树（abstract syntax tree即：源代码的抽象语法结构的树状表现形式），compile是createCompiler的返回值，createCompiler是以创建编译器。另外compile还负责合并option。</p>
<p>然后，AST会经过generate（将AST语法树转换成render function字符串的过程）得到render函数，render的返回值是VNode，VNode是Vue的虚拟DOM节点，里面有（标签名、子节点、文本等）</p>
<h5 id="46-webpack打包原理"><a href="#46-webpack打包原理" class="headerlink" title="46. webpack打包原理"></a>46. webpack打包原理</h5><h5 id="47-gulp构建原理"><a href="#47-gulp构建原理" class="headerlink" title="47. gulp构建原理"></a>47. gulp构建原理</h5><h5 id="vue的优点"><a href="#vue的优点" class="headerlink" title="vue的优点"></a>vue的优点</h5><ul>
<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；</li>
<li>简单易学：国人开发，中文文档，不存在语言障碍，易于理解和学习；</li>
<li>双向数据绑定：保留了angular的特点，在数据操作方面更为简单；</li>
<li>组件化：保留了react的优点，实现了html的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>视图、数据、结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom，不过是换了一种方式；</li>
<li>运行速度更快：相比较react，同样操作虚拟dom，就性能而言，vue存在很大的优势；</li>
</ul>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库（MongoDB、Mysql、Redis）</title>
    <url>/articles/2020-02-08-interview-database.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-MongoDB"><a href="#1-MongoDB" class="headerlink" title="1. MongoDB"></a>1. MongoDB</h4><p>什么是MongoDB？<br>是一个数据库，高性能、无模式、文档性、开源性、基于c++开发的、基于分布式文件存储的非关系型数据库。</p>
<p>特点：</p>
<ul>
<li>面向集合文档的存储，适合存储Bson(json)形式的数据；</li>
<li>格式自由，数据格式不固定，生产环境下修改结构都可以不影响程序运行；</li>
<li>强大的查询语句，面向对象的查询语言，基本覆盖sql语言所有能力；</li>
<li>完整的索引支持，支持查询计划；</li>
<li>支持复制和自动故障转移；</li>
<li>支持二进制数据及大型对象的高效存储；</li>
<li>使用分片集群提升系统扩展性；</li>
<li>使用内存映射存储引擎，把磁盘的IO操作转换为内存的操作；</li>
</ul>
<p>缺点：</p>
<ul>
<li>mongodb对事务的支持较弱：高度事务性系统；</li>
<li>不支持join和复杂查询；</li>
<li>磁盘空间占用比较大；</li>
<li>在集群分片中的数据分布不均匀；</li>
<li>单机可靠性比较差；</li>
<li>大数据量持续插入，写入性能有较大波动；</li>
</ul>
<h4 id="2-Mysql"><a href="#2-Mysql" class="headerlink" title="2. Mysql"></a>2. Mysql</h4><p>关系型数据库</p>
<p>优点：</p>
<ul>
<li><p>在不同的引擎上有不同的存储方式。</p>
</li>
<li><p>查询语句使用传统的sql语句，拥有比较成熟的体系，成熟度很高；</p>
<p>缺点：</p>
</li>
<li><p>在海量数据处理的时候效率会显著变慢；</p>
</li>
</ul>
<h5 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h5><p>Mysql索引的建立，可以大大提高Mysql的检索速度。</p>
<p>索引分为单列索引和组合索引。<br>单列索引：即一个索引只包含单个列，一个表可以有多个单列索引；<br>组合索引：即一个索引包含多个列；</p>
<p>索引大大提高了查询速度，同时降低更新表的速度，简历索引会占用磁盘空间的索引文件。</p>
<h6 id="索引是做什么的"><a href="#索引是做什么的" class="headerlink" title="索引是做什么的"></a>索引是做什么的</h6><p>索引用于快速找出在某个列中有一特定值的行。<br>不使用索引，mysql必须从第1条记录开始然后读完整个表直到找出相关的行。表越大，花费的时间越多。<br>如果表中查询的列有一个索引，mysql能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有的数据。<br>大多数mysql索引在B树种存储，只是空间列类型的索引使用R-树，并且Memory表还支持hash索引。<br>、</p>
<h6 id="索引好复杂，该如何理解索引，有无一个更形象点的例子"><a href="#索引好复杂，该如何理解索引，有无一个更形象点的例子" class="headerlink" title="索引好复杂，该如何理解索引，有无一个更形象点的例子"></a>索引好复杂，该如何理解索引，有无一个更形象点的例子</h6><p>假如一本词典，数据就是书的正文内容，你就是cpu，而索引，则是书的目录。</p>
<h6 id="索引越多越好"><a href="#索引越多越好" class="headerlink" title="索引越多越好"></a>索引越多越好</h6><p>大多数情况下索引能大幅度提高查询效率，但：<br>数据的变更都需要维护索引，因此更多的索引意味着更多的维护成本<br>更多的索引意味着也需要更多的空间<br>过小的表，建索引可能会更慢</p>
<h6 id="索引的字段类型问题"><a href="#索引的字段类型问题" class="headerlink" title="索引的字段类型问题"></a>索引的字段类型问题</h6><p>text类型，也可建索引（需要指定长度）<br>myisam存储引擎索引键长度综合不能超过1000字节<br>用来筛选的值尽量保持和索引列同样的数据类型</p>
<h6 id="like不能用索引"><a href="#like不能用索引" class="headerlink" title="like不能用索引"></a>like不能用索引</h6><p>尽量减少like，但不是绝对不可用<br>除了like，以下操作符也可用到索引：<br>&lt;, &lt;=, =, &gt;=, between, in&lt;&gt;, not in, !=则不行</p>
<h6 id="什么样的字段不适合建索引"><a href="#什么样的字段不适合建索引" class="headerlink" title="什么样的字段不适合建索引"></a>什么样的字段不适合建索引</h6><p>一般来说，列的值唯一性太小（如性别、类型等），不适合建索引<br>太长的列，可以选择只建立部分索引<br>更新非常频繁的数据不适宜建索引</p>
<h6 id="一次查询能用多个索引吗"><a href="#一次查询能用多个索引吗" class="headerlink" title="一次查询能用多个索引吗"></a>一次查询能用多个索引吗</h6><p>不能</p>
<h6 id="多列查询该如何建索引"><a href="#多列查询该如何建索引" class="headerlink" title="多列查询该如何建索引"></a>多列查询该如何建索引</h6><p>一次查询只能用到一个索引，所以首先墙壁a，b各建索引方案a还是b？谁的区分度更高，建谁。或者联合索引也可以。</p>
<h6 id="联合索引的问题"><a href="#联合索引的问题" class="headerlink" title="联合索引的问题"></a>联合索引的问题</h6><p>大多数情况下，有AB索引了，就可以不用再建一个A索引了。</p>
<h6 id="哪些常见情况下不能用索引？"><a href="#哪些常见情况下不能用索引？" class="headerlink" title="哪些常见情况下不能用索引？"></a>哪些常见情况下不能用索引？</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">like &quot;%xxx&quot;</span><br><span class="line">not in, !&#x3D;</span><br></pre></td></tr></table></figure>
<p>队列进行函数运算的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">where index&#x3D;1 or a&#x3D;10</span><br></pre></td></tr></table></figure>
<p>存了数值的字符串类型字段（如手机号），查询记得不要丢掉值的引号，否则无法用到该字段相关索引，反之没关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from test where mobile&#x3D;13122930394</span><br></pre></td></tr></table></figure>
<p>可是无法用到mobile字段的索引（如果mobile是char或vachar类型的话）</p>
<h6 id="覆盖索引Covering-Indexes拥有更高效率"><a href="#覆盖索引Covering-Indexes拥有更高效率" class="headerlink" title="覆盖索引Covering Indexes拥有更高效率"></a>覆盖索引Covering Indexes拥有更高效率</h6><p>索引包含了所需的全部值的haul，就只select他们，换言之，只select需要用到的字段，如务必要，可避免select * </p>
<h6 id="NULL的问题"><a href="#NULL的问题" class="headerlink" title="NULL的问题"></a>NULL的问题</h6><p>NULL会导致索引形同虚设，所以在设计表结构时应避免NULL的存在。</p>
<h6 id="如何查看索引信息，如何分析是否正确用到索引？"><a href="#如何查看索引信息，如何分析是否正确用到索引？" class="headerlink" title="如何查看索引信息，如何分析是否正确用到索引？"></a>如何查看索引信息，如何分析是否正确用到索引？</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index from tablename</span><br><span class="line">explain select ...</span><br></pre></td></tr></table></figure>

<h6 id="了解自己的系统，不要过早优化"><a href="#了解自己的系统，不要过早优化" class="headerlink" title="了解自己的系统，不要过早优化"></a>了解自己的系统，不要过早优化</h6><h5 id="left-join-right-join-inner-join"><a href="#left-join-right-join-inner-join" class="headerlink" title="left join /right join/ inner join"></a>left join /right join/ inner join</h5><p>left join：关键字会从左表返回所有的行，即使右表没有匹配的行；<br>right join：关键字会从右表返回所有的行，即使左表没有匹配的行；<br>inner join：在表中存在至少一个匹配时；</p>
<h4 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3. Redis"></a>3. Redis</h4><p>一个完全开源的，遵循BSD协议，内存中的数据结构存储系统，一个高性能的key-value数据库；<br>用作数据库、缓存和消息中间件；</p>
<p>Redis是单进程单线程的，redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。</p>
<p>一个字符串类型的值能存储最大容量是512M。</p>
<p>支持的常见的5种数据结构：   </p>
<ul>
<li>字符串String </li>
<li>散列Hashes</li>
<li>列表List </li>
<li>集合Set </li>
<li>有序集合Sorted set</li>
</ul>
<p>而Redis内置了复制(replication)、LUA脚本、LRU驱动事件、事务和不同级别的磁盘持久化，并通过哨兵和自动分区Cluster提高高可用性，这些才是项目中使用比较多的几个部分。</p>
<h5 id="Redis-特点"><a href="#Redis-特点" class="headerlink" title="Redis 特点"></a>Redis 特点</h5><ul>
<li>Redis支持数据持久化，可以将内存中的数据保存在磁盘，重启的时候可以再次加载进行使用；</li>
<li>Redis不仅仅支持简单的key-value类型的数据，同时还提供list、set、zset、hash等数据结构的存储；</li>
<li>Redis支持数据的备份，即master-slave模式的数据备份。</li>
</ul>
<h5 id="Redis优势"><a href="#Redis优势" class="headerlink" title="Redis优势"></a>Redis优势</h5><ul>
<li>性能极高，速度快 - Redis能读的速度是110000次/s， 写的速度是81000次/s；</li>
<li>丰富的数据类型；</li>
<li>原子 - Redis的所有操作都是原子性的。单个操作是原子性的，多个操作也支持事务，通过MULTI和EXEC指令包起来；</li>
<li>丰富的特性 - 可用于缓存、消息，按key设置过期时间，过期后将会自动删除，Redis还支持publish/subscribe，通知key过期等特性；</li>
</ul>
<h5 id="Redis与其他key-value存储有什么不同？"><a href="#Redis与其他key-value存储有什么不同？" class="headerlink" title="Redis与其他key-value存储有什么不同？"></a>Redis与其他key-value存储有什么不同？</h5><ul>
<li>Redis有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象；</li>
<li>Redis运行在内存中但可以持久化到磁盘，所以在对不同数据集进行高度读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样Redis可以做很多内部复杂性很强的事情。同时在磁盘格式方面他们是紧凑的以追加的方式产生的，需要进行随机访问。</li>
</ul>
<h5 id="Redis与Memecache有哪些优势？"><a href="#Redis与Memecache有哪些优势？" class="headerlink" title="Redis与Memecache有哪些优势？"></a>Redis与Memecache有哪些优势？</h5><ul>
<li>Memecache所有值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类；</li>
<li>Redis的速度比Memecache快；</li>
<li>Redis可以持久化其数据；</li>
</ul>
<h5 id="Memcache与Redis的区别有哪些？"><a href="#Memcache与Redis的区别有哪些？" class="headerlink" title="Memcache与Redis的区别有哪些？"></a>Memcache与Redis的区别有哪些？</h5><ul>
<li>存储方式Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。Redis有部分存在硬盘上，这样能保证数据的持久性；</li>
<li>数据支持类型Memcache对数据类型支持相对简单。Redis有复杂的数据类型；</li>
<li>使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</li>
</ul>
<h5 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h5><p>为什么要缓存呐，其实对于一些频繁访问的数据把它放到缓存中，从而减少了数据库的访问，对于日活比较高的能够很好的达到速度和性能的改善。<br>缓存查询顺序：<br>    在数据获取的时候，一般是先从缓存中取数据；<br>    如果缓存中没有的话，再去数据库取数据。<br>Redis缓存问题：<br>    最主要的几个就是：缓存击穿、缓存穿透和缓存雪崩。</p>
<h5 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h5><pre><code>当访问数据库中的一个不存在的key的时候，发现没有数据，程序会去数据库的查询，当查不到数据的时候，就不会写入redis缓存，从而导致这个不存在的数据每次请求都会去数据库查询，导致缓存穿透。当数据量比较大的时候，可能导致数据库挂掉。</code></pre><p><em>（画这几张图，也是头大，不知道怎么才能把代码用图体现出来）</em><br><img src="https://img-blog.csdnimg.cn/20190724193444697.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vXzI0Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>解决：<br>   采用布隆过滤器。用一个比较大的bitmap，存储可能访问的key，对不存在的key直接过滤掉；<br>    当数据库查询的值为空，也要设置一个默认值，可以把这个有效时间设置短一点；</p>
<h5 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h5><pre><code>是说大量的缓存集中的进行失效，导致了缓存穿透，进而所有的查询都在数据库上，数据库很快就承受不住，甚至宕机，导致了缓存雪崩。</code></pre><p>解决：<br>    过期时间均匀分布，而不是集中到一点；<br>    设置两个缓存的key，而具有不同的失效时间，当key1失效之后，访问key2，然后更新key1和key2；<br>    使用分布式锁(redis的Lock方法)，从而当应用发现缓存失效之后，拿到锁的线程才去更新缓存；<br>    mq消息队列的削峰方式，当应用发现缓存失效之后，发送消息，消费者消费后进行更新数据和缓存，后台线程会检测缓存中是否存在缓存，如果存在就不更新</p>
<p><em>（其实，用户很多很多的哦，大批量）</em><br><img src="https://img-blog.csdnimg.cn/2019072419352042.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vXzI0Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h5><pre><code>是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。</code></pre><p>解决：<br>   和缓存雪崩的方法其实差不多：都可以用分布式锁来处理。</p>
<h5 id="Redis的持久化机制是什么？各自的优缺点？"><a href="#Redis的持久化机制是什么？各自的优缺点？" class="headerlink" title="Redis的持久化机制是什么？各自的优缺点？"></a>Redis的持久化机制是什么？各自的优缺点？</h5><p>Redis提供两种持久化机制RDB和AOF机制：</p>
<ol>
<li>RDB（Redis DataBase）持久化方式：<br>是指用数据集快照的半持久化模式，记录redis数据库的所有键值对，在某个时间点将数据写入一个临时的文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。</li>
</ol>
<p>优点：</p>
<ul>
<li>只有一个文件dump.rdb，方便持久化；</li>
<li>容灾性好，一个文件可以保存到安全的磁盘；</li>
<li>性能最大化，foek子进程来完成写操作，让主进程继续处理命令，所以是IO最大化。使用单独子进程来进行持久化，主进程不会进行任何IO操作，保证了Redis的高性能；</li>
<li>相对于数据集大时，比AOF的启动效率更高；</li>
</ul>
<p>缺点：<br>数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失，所以这种方式更适合数据要求不严谨的时候。</p>
<ol start="2">
<li>AOF（Append-only file）持久化方式<br>是指所有的命令行记录以redis命令请求协议的格式完全持久化存储，保存为aof文件。</li>
</ol>
<p>优点：</p>
<ul>
<li>数据安全，aof持久化可以配置appendfsync属性，有always，每进行一次命令操作就记录到aof文件中一次；</li>
<li>通过append模式写文件，即使中途服务器宕机，可以通过redis-check-aof工具解决数据一致性问题；</li>
<li>aof机制的rewrite模式。aof文件没被rewrite之前（文件过大会对命令进行合并重写），可以删除其中的某些命令；</li>
</ul>
<p>缺点：</p>
<ul>
<li>AOF文件比RDB文件大，且恢复速度慢；</li>
<li>数据集大的时候，比RDB启动效率低；</li>
</ul>
<h5 id="Redis常见性能问题和解决方案"><a href="#Redis常见性能问题和解决方案" class="headerlink" title="Redis常见性能问题和解决方案"></a>Redis常见性能问题和解决方案</h5><ul>
<li>Master最好不要写内存快照，如果Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务；</li>
<li>如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步；</li>
<li>为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网；</li>
<li>尽量避免在压力大的主库上增加从</li>
<li>主从复制不要用图形结构，用单向链表结构更为文档，即Master&lt;-Slave1&lt;-Slave2&lt;-Slave3…这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li>
</ul>
<h5 id="Redis过期键的删除策略"><a href="#Redis过期键的删除策略" class="headerlink" title="Redis过期键的删除策略"></a>Redis过期键的删除策略</h5><ul>
<li>定时删除：在设置键的过期时间的同时，创建一个定时器timer，让定时器在键的过期时间来临时，立即执行对键的删除操作；</li>
<li>惰性删除：放任键过期不管，但每次从键控件中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，否则返回该键；</li>
<li>定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键，至于要删多少过期键，以及要检查多少数据库，由算法决定；</li>
</ul>
<h5 id="Redis的回收策略（淘汰策略）"><a href="#Redis的回收策略（淘汰策略）" class="headerlink" title="Redis的回收策略（淘汰策略）"></a>Redis的回收策略（淘汰策略）</h5><p>Redis有6种淘汰策略：</p>
<ul>
<li>volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰</li>
<li>volatile-random 从已设置过期时间的数据集中任意选择数据淘汰</li>
<li>allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰</li>
<li>allkeys-random 从所有数据集中任意选择数据进行淘汰</li>
<li>noeviction 禁止驱逐数据</li>
</ul>
<p>使用策略规则：</p>
<ul>
<li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru；</li>
<li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random；</li>
</ul>
<h5 id="为什么redis需要把所有数据放到内存中"><a href="#为什么redis需要把所有数据放到内存中" class="headerlink" title="为什么redis需要把所有数据放到内存中"></a>为什么redis需要把所有数据放到内存中</h5><p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限制后不能继续插入新值。</p>
<h5 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h5><p>Redis可以使用主从同步、从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</p>
<h5 id="Pipeline有什么好处，为什么要有Pipeline"><a href="#Pipeline有什么好处，为什么要有Pipeline" class="headerlink" title="Pipeline有什么好处，为什么要有Pipeline"></a>Pipeline有什么好处，为什么要有Pipeline</h5><p>可以将多次IO往返的事件缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p>
<h5 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h5><ul>
<li>Redis Sentinal着眼于高可用，在master宕机时就会自动将slave提升为master，继续提供服务；</li>
<li>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储；</li>
</ul>
<h5 id="Redis集群方案什么情况下会导致整个集群不可用？"><a href="#Redis集群方案什么情况下会导致整个集群不可用？" class="headerlink" title="Redis集群方案什么情况下会导致整个集群不可用？"></a>Redis集群方案什么情况下会导致整个集群不可用？</h5><p>有ABC三个节点的集群，在没有复制模型的情况下，如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p>
<h5 id="Redis如何设置密码及验证密码"><a href="#Redis如何设置密码及验证密码" class="headerlink" title="Redis如何设置密码及验证密码"></a>Redis如何设置密码及验证密码</h5><p>设置密码：config set requirepass 123456<br>授权密码：auth 123456</p>
<h5 id="说说Redis哈希槽的概念"><a href="#说说Redis哈希槽的概念" class="headerlink" title="说说Redis哈希槽的概念"></a>说说Redis哈希槽的概念</h5><p>Redis集群没有使用一致性hash，而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p>
<h5 id="Redis集群的主从复制模型是怎样的"><a href="#Redis集群的主从复制模型是怎样的" class="headerlink" title="Redis集群的主从复制模型是怎样的"></a>Redis集群的主从复制模型是怎样的</h5><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型，每个节点都会有N-1个复制品。</p>
<h5 id="Redis集群会有写操作丢失吗？为什么？"><a href="#Redis集群会有写操作丢失吗？为什么？" class="headerlink" title="Redis集群会有写操作丢失吗？为什么？"></a>Redis集群会有写操作丢失吗？为什么？</h5><p>Redis并不能保证数据的强一致性，这意味着在实际中集群在特定的条件下可能会丢失写操作。</p>
<h5 id="Redis集群之间是如何复制的"><a href="#Redis集群之间是如何复制的" class="headerlink" title="Redis集群之间是如何复制的"></a>Redis集群之间是如何复制的</h5><p>异步复制</p>
<h5 id="Redis集群最大节点个数是多少"><a href="#Redis集群最大节点个数是多少" class="headerlink" title="Redis集群最大节点个数是多少"></a>Redis集群最大节点个数是多少</h5><p>16384个</p>
<h5 id="Redis集群如何选择数据库"><a href="#Redis集群如何选择数据库" class="headerlink" title="Redis集群如何选择数据库"></a>Redis集群如何选择数据库</h5><p>Redis集群目前无法做数据库选择，默认在0数据库</p>
<h5 id="怎么测试Redis的连通性"><a href="#怎么测试Redis的连通性" class="headerlink" title="怎么测试Redis的连通性"></a>怎么测试Redis的连通性</h5><p>使用ping命令</p>
<h5 id="如何理解Redis事务"><a href="#如何理解Redis事务" class="headerlink" title="如何理解Redis事务"></a>如何理解Redis事务</h5><ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、顺序的执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；</li>
<li>事务是一个原子操作：事务中的命令要么全部执行，要么全部都不执行；</li>
</ul>
<h5 id="Redis事务相关的命令有哪几个"><a href="#Redis事务相关的命令有哪几个" class="headerlink" title="Redis事务相关的命令有哪几个"></a>Redis事务相关的命令有哪几个</h5><p>MULTI、EXEC、DISCARD、WATCH</p>
<h5 id="Redis-key过期时间和永久有效分别怎么设置"><a href="#Redis-key过期时间和永久有效分别怎么设置" class="headerlink" title="Redis key过期时间和永久有效分别怎么设置"></a>Redis key过期时间和永久有效分别怎么设置</h5><p>EXPIRE和PERSIST命令</p>
<h5 id="Redis如何做内存优化"><a href="#Redis如何做内存优化" class="headerlink" title="Redis如何做内存优化"></a>Redis如何做内存优化</h5><p>尽可能使用散列表hashes，散列表（是说散列表里面存储的数少）使用的内存非常小，所以应该尽可能将数据模型抽象到一个散列表里面。<br>比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。</p>
<h5 id="Redis回收进程如何工作的"><a href="#Redis回收进程如何工作的" class="headerlink" title="Redis回收进程如何工作的"></a>Redis回收进程如何工作的</h5><p>一个客户端运行了新的命令，添加了新的数据。redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收。一个新的命令被执行等。所以我们不断的穿越内存限制的边界，通过不断达到边界然后不断的回收到边界以下。如果一个命令的结果导致大量内存被使用，不用多久内存限制就会被这个内存使用量超越。</p>
<h5 id="都有哪些办法可以降低Redis的内存使用情况？"><a href="#都有哪些办法可以降低Redis的内存使用情况？" class="headerlink" title="都有哪些办法可以降低Redis的内存使用情况？"></a>都有哪些办法可以降低Redis的内存使用情况？</h5><p>如果你使用的是32位的Redis实例，可以好好利用Hash、list、sorted、set等集合类型数据，因为通常情况下很多小的Key-Value可以用紧凑的方式存放到一起。</p>
<h5 id="Redis的内存用完了会发生什么"><a href="#Redis的内存用完了会发生什么" class="headerlink" title="Redis的内存用完了会发生什么"></a>Redis的内存用完了会发生什么</h5><p>如果达到设置的上限，Redis的写命令会返回错误信息（但读命令可以正常返回）。<br>或者可以将Redis当缓存来使用配置淘汰机制，当Redis达到内存上限时会冲刷掉旧的内容。</p>
<h5 id="一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？"><a href="#一个Redis实例最多能存放多少的keys？List、Set、Sorted-Set他们最多能存放多少元素？" class="headerlink" title="一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？"></a>一个Redis实例最多能存放多少的keys？List、Set、Sorted Set他们最多能存放多少元素？</h5><p>理论上Redis可以处理多达232的keys，并且在实际中进行了测试，每个实例至少存放了2亿5千万的keys。我们正在测试一些较大的值，任何list、set和sorted set都可以放232个元素。换句话说，Redis的存储极限是系统中的可用内存值。</p>
<h5 id="Mysql里有2000w数据，redis中只存20w的数据，如何保证redis数据都是热点数据？"><a href="#Mysql里有2000w数据，redis中只存20w的数据，如何保证redis数据都是热点数据？" class="headerlink" title="Mysql里有2000w数据，redis中只存20w的数据，如何保证redis数据都是热点数据？"></a>Mysql里有2000w数据，redis中只存20w的数据，如何保证redis数据都是热点数据？</h5><p>Redis内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p>
<h5 id="Redis最适合的场景"><a href="#Redis最适合的场景" class="headerlink" title="Redis最适合的场景"></a>Redis最适合的场景</h5><p>1、会话缓存（Session Cache）</p>
<p>最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。</p>
<p>2、全页缓存（FPC）</p>
<p>除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p>
<p>3、队列</p>
<p>Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop 操作。 如果你快速的在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。</p>
<p>4，排行榜/计数器</p>
<p>Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。</p>
<p>5、发布/订阅</p>
<p>最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！</p>
<h5 id="假如Redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h5><p>使用keys指令可以扫出指定模式的key列表。<br>如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？<br>redis的单线程，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p>
<h5 id="如果有大量的key需要设置同一时间过期，一般需要注意什么"><a href="#如果有大量的key需要设置同一时间过期，一般需要注意什么" class="headerlink" title="如果有大量的key需要设置同一时间过期，一般需要注意什么"></a>如果有大量的key需要设置同一时间过期，一般需要注意什么</h5><p>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。</p>
<h5 id="使用过Redis做异步队列么，你是怎么用？"><a href="#使用过Redis做异步队列么，你是怎么用？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用？"></a>使用过Redis做异步队列么，你是怎么用？</h5><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用 pub/sub 主题订阅者模式，可以实现1:N 的消息队列。</p>
<p>如果对方追问 pub/sub 有什么缺点？</p>
<p>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。</p>
<p>如果对方追问 redis 如何实现延时队列？</p>
<p>我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p>
<h5 id="使用过Redis分布式锁，它是什么回事？"><a href="#使用过Redis分布式锁，它是什么回事？" class="headerlink" title="使用过Redis分布式锁，它是什么回事？"></a>使用过Redis分布式锁，它是什么回事？</h5><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p>
<p>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire之前进程意外 crash 或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/articles/2020-02-08-interview-algorithm.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-多路归并"><a href="#1-多路归并" class="headerlink" title="1. 多路归并"></a>1. 多路归并</h4><p>时间复杂度：nlgn，最坏复杂度：O(nlogn)，空间复杂度：O(n)，稳定性：稳定</p>
<ul>
<li>先递归分解数组，再合并数组。</li>
<li>将数组分解成最小之后，然后合并两个有序的数组</li>
<li>基本思路就是比较两个数组最前面的数，谁小就取谁</li>
<li>取了后相应的指针就往后移一位</li>
<li>然后再比较，直至一个数组为空，最后把两个数组的剩余部分渎职过来即可</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def merge_sort(alist):</span><br><span class="line">    &quot;&quot;&quot;归并排序&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    if n &lt;&#x3D; 1:</span><br><span class="line">        return alist</span><br><span class="line">    mid &#x3D; n&#x2F;&#x2F;2</span><br><span class="line">    # left 采用归并排序后形成的有序的新的列表</span><br><span class="line">    left_li &#x3D; merge_sort(alist[:mid])</span><br><span class="line">    # right 采用归并排序后形成的有序的新的列表</span><br><span class="line">    right_li &#x3D; merge_sort(alist[mid:])</span><br><span class="line"> </span><br><span class="line">    # 将两个有序的子序列合并为一个新的整体</span><br><span class="line">    left, right &#x3D; 0, 0</span><br><span class="line">    result &#x3D; []</span><br><span class="line"> </span><br><span class="line">    while left &lt; len(left_li) and right &lt; len(right_li):</span><br><span class="line">        # print(left_li[left], right_li[right])</span><br><span class="line">        if left_li[left] &lt;&#x3D; right_li[right]:</span><br><span class="line">            result.append(left_li[left])</span><br><span class="line">            left +&#x3D; 1</span><br><span class="line">        else:</span><br><span class="line">            # right_li[right] &lt; left_li[left]</span><br><span class="line">            result.append(right_li[right])</span><br><span class="line">            right +&#x3D; 1</span><br><span class="line">    result +&#x3D; left_li[left:]</span><br><span class="line">    result +&#x3D; right_li[right:]</span><br><span class="line"> </span><br><span class="line">    return result</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    li &#x3D; []</span><br><span class="line">    for i in range(10):</span><br><span class="line">        li.append(random.randint(1, 100))</span><br><span class="line">    print(*li)</span><br><span class="line">    result &#x3D; merge_sort(li)</span><br><span class="line">    print(*result)</span><br></pre></td></tr></table></figure>

<h4 id="2-二分排序"><a href="#2-二分排序" class="headerlink" title="2. 二分排序"></a>2. 二分排序</h4><p>关键字的比较次数采用折半查找，时间复杂度为O(n^2)<br>二分插入排序是在插入第i个元素时，对前面的0~i-1进行折半<br>先给他们中间的那个元素比，如果小，则对前半再进行折半，否则对后半进行折半<br>直到left&gt;right，然后再把第i个元素前1位与目标位置之间的所有元素后移<br>直到第i个元素放在目标位置上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unction twoPointLookup(arr,low,high,key)&#123;</span><br><span class="line">　　if(low &gt; high)&#123;</span><br><span class="line">　　　　return -1</span><br><span class="line">　　&#125;</span><br><span class="line">　　var num &#x3D; parseInt((low + high) &#x2F; 2);</span><br><span class="line">　　if(key &#x3D;&#x3D; arr[num])&#123;</span><br><span class="line">　　　　return num </span><br><span class="line">　　&#125;else if(arr[num] &gt; key)&#123;</span><br><span class="line">　　　　high &#x3D; num - 1;</span><br><span class="line">　　　　return  twoPointLookup(arr,low,high,key)</span><br><span class="line"> 　　&#125; else if (arr[num] &lt; key)&#123;</span><br><span class="line">　　　　low &#x3D; num + 1</span><br><span class="line">　　　　return  twoPointLookup(arr,low,high,key)</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3. 快速排序"></a>3. 快速排序</h4><p>平均时间复杂度：O(nlgn/ig2)，最差为：O(n^2)，空间复杂度为：O(logn)，稳定性：不稳定</p>
<ul>
<li>先从数列中取出一个数作为基准数</li>
<li>分区过程，将比这个数大的全放到它的右边，小于或等于的放左边</li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length&lt;&#x3D;1) &#123;</span><br><span class="line">  	return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var s &#x3D; Math.floor(arr.length&#x2F;2);</span><br><span class="line"> </span><br><span class="line">  var temp &#x3D; arr.splice(s,1);</span><br><span class="line">  </span><br><span class="line">  var left&#x3D;[];</span><br><span class="line">  var right&#x3D;[];</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    if(arr[i]&lt;temp) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[i]&gt;&#x3D;temp) &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return quickSort(left).concat(temp,quickSort(right));  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-冒泡排序"><a href="#4-冒泡排序" class="headerlink" title="4. 冒泡排序"></a>4. 冒泡排序</h4><p>最优复杂度：O(n)，最坏复杂度：O(n^2)，稳定性：稳定</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大(升序)，就交换他们两个；</li>
<li>对每一对相邻的元素做同样的工作，从开始到结尾的最后一对，这步做完后，最后的元素会是最大的数；</li>
<li>针对所有的元素重复以上步骤，除了最后一个</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较；</li>
<li>稳定性：数值相同的元素在排序中不交换位置为稳定反之不稳定</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def bubble_sort(alist):</span><br><span class="line">    &quot;&quot;&quot;冒泡排序&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    for j in range(n-1):</span><br><span class="line">        # range(5)的取值范围是从0~4此处要取到n-2（下标从0开始）所以</span><br><span class="line">        # 此处的值为n-1</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        # 如果进行了交换count加一，如果内层循环中发现某次交换一次都没有发生</span><br><span class="line">        # 即count &#x3D;&#x3D; 0,则说明列表已经是有序的了，直接退出外层循环，优化了程序</span><br><span class="line">        for i in range(n-1-j):</span><br><span class="line">            if alist[i] &gt; alist[i+1]:</span><br><span class="line">                alist[i], alist[i+1] &#x3D; alist[i+1], alist[i]</span><br><span class="line">                count +&#x3D; 1</span><br><span class="line">        if count &#x3D;&#x3D; 0:</span><br><span class="line">            break</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    li &#x3D; [56, 88, 12, 62, 54, 79, 32, 11, 96]</span><br><span class="line">    print(*li)</span><br><span class="line">    bubble_sort(li)</span><br><span class="line">    print(*li)</span><br></pre></td></tr></table></figure>

<h4 id="5-插入排序"><a href="#5-插入排序" class="headerlink" title="5.插入排序"></a>5.插入排序</h4><p>最优复杂度：O(n), 最坏复杂度：O(n^2)，稳定性：稳定</p>
<ul>
<li>从第一个元素开始，该元素可以认为已被排序</li>
<li>取出下一个元素，在已经排序的元素序列从后向前的扫描</li>
<li>如果改元素(已排序)大于新元素，将该元素移到下一个位置</li>
<li>重复步骤3，直到找到与排序的元素小于或等于新元素的位置</li>
<li>将新元素插入到下一位置中</li>
<li>重复步骤2~5</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insert_sort(alist):</span><br><span class="line">    &quot;&quot;&quot;插入排序&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line"> </span><br><span class="line">    for j in range(1, n):</span><br><span class="line">        # 1~n-1</span><br><span class="line">        for i in range(j, 0, -1):</span><br><span class="line">            # range(start, stop[, step])</span><br><span class="line">            # stop的值要取前一个，所以此处取值为j~1,</span><br><span class="line">            if alist[i] &lt; alist[i-1]:</span><br><span class="line">                alist[i], alist[i-1] &#x3D; alist[i-1], alist[i]</span><br><span class="line"> </span><br><span class="line">            # 此处为对代码的优化</span><br><span class="line">            # 因为序列的alist[i]之前的序列已经是有序的了</span><br><span class="line">            # 如果alist[i] &gt;&#x3D; alist[i-1]直接放入前面的有序部分的尾部就行</span><br><span class="line">            # 没有必要再和前面的元素依次比较了</span><br><span class="line">            # 此处的优化使代码的最优时间复杂度由O(n^2)变为了O(n)</span><br><span class="line">            else:</span><br><span class="line">                break</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    # li &#x3D; [5, 3, 2, 4, 7, 1, 6]</span><br><span class="line">    li &#x3D; [1, 2, 3, 4, 5, 4, 6, 7]</span><br><span class="line">    print(*li)</span><br><span class="line">    # start_time &#x3D; time.time()</span><br><span class="line">    insert_sort(li)</span><br><span class="line">    # end_time &#x3D; time.time()</span><br><span class="line">    print(*li)</span><br><span class="line">    # print(end_time-start_time)</span><br></pre></td></tr></table></figure>

<h4 id="6-选择排序"><a href="#6-选择排序" class="headerlink" title="6. 选择排序"></a>6. 选择排序</h4><p>最优复杂度：O(n^2)，最坏复杂度O(n^2)，稳定性：不稳定</p>
<ul>
<li>始终从末序列的序列中找到最小的放到最前面；</li>
<li>将第一个元素先作为最小值，用第一个点元素和后面的元素依次比较</li>
<li>首次碰见比第一个元素更小的元素就记录这个“较小元素”的位置</li>
<li>继续比较如果碰见比“较小元素”更小的元素，就将记录的“较小元素”的位置信息，替换成“更小元素”</li>
<li>直到比较完整个序列，最小的元素位置信息就被记录下来了</li>
<li>交换第一个元素和最小元素的位置，序列的头部就变成了最小的元素</li>
<li>再将第二个元素先作为序列剩余元素的最小元素，和剩下的元素重复上述步骤进行比较</li>
<li>将第二小的元素找到，并和第二个元素进行交换</li>
<li>多次重复上述步骤n-1，即可得到升序序列</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def select_sort(alist):</span><br><span class="line">    &quot;&quot;&quot;选择排序&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    for j in range(n-1):</span><br><span class="line">        # 列表的长度为n,从0开始计算一共为n-1个数。</span><br><span class="line">        # 最后一趟只剩最后一个数，一定是最大的不用比较。</span><br><span class="line">        # 所以只需要比较n-2次。</span><br><span class="line">        min_index &#x3D; j</span><br><span class="line">        for i in range(j+1, n):</span><br><span class="line">            if alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index &#x3D; i</span><br><span class="line">        alist[j], alist[min_index] &#x3D; alist[min_index], alist[j]</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    li &#x3D; [56, 26, 77, 6, 54, 38, 96, 43, 99]</span><br><span class="line">    print(*li)</span><br><span class="line">    select_sort(li)</span><br><span class="line">    print(*li)</span><br></pre></td></tr></table></figure>

<h4 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7. 希尔排序"></a>7. 希尔排序</h4><p>最优复杂度：O(n^1.3)，最坏复杂度：O(n^2)，稳定性：不稳定</p>
<ul>
<li>希尔排序是按照不同步长对元素进行插入排序</li>
<li>当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快</li>
<li>当元素基本有序了，步长很小，插入排序对于有序的序列效率很高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def shell_sort(alist):</span><br><span class="line">    &quot;&quot;&quot;希尔排序&quot;&quot;&quot;</span><br><span class="line">    n &#x3D; len(alist)</span><br><span class="line">    step &#x3D; n&#x2F;&#x2F;2</span><br><span class="line"> </span><br><span class="line">    while step &gt; 0:</span><br><span class="line">        for j in range(step, n):</span><br><span class="line">            for i in range(j, 0, -step):</span><br><span class="line">                if alist[i] &lt; alist[i-step]:</span><br><span class="line">                    alist[i], alist[i-1] &#x3D; alist[i-1], alist[i]</span><br><span class="line">                else:</span><br><span class="line">                    break</span><br><span class="line">        step &#x3D; step&#x2F;&#x2F;2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line"> </span><br><span class="line">    li &#x3D; [56, 26, 77, 6, 54, 38, 96, 43, 99]</span><br><span class="line">    print(*li)</span><br><span class="line">    shell_sort(li)</span><br><span class="line">    print(*li)</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cxyxiaowu.com/7072.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/7072.html</a></p>
<p><a href="https://blog.csdn.net/Design407/article/details/103242874" target="_blank" rel="noopener">https://blog.csdn.net/Design407/article/details/103242874</a></p>
<p><a href="https://blog.csdn.net/hebtu666/article/details/103127563" target="_blank" rel="noopener">https://blog.csdn.net/hebtu666/article/details/103127563</a></p>
<p><a href="https://blog.csdn.net/m0_37907797/article/details/103252306" target="_blank" rel="noopener">https://blog.csdn.net/m0_37907797/article/details/103252306</a></p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>KoaExpress</title>
    <url>/articles/2020-02-08-interview-koaExpress.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-Koa和Express的区别和联系"><a href="#1-Koa和Express的区别和联系" class="headerlink" title="1. Koa和Express的区别和联系"></a>1. Koa和Express的区别和联系</h4><p>Koa是由Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的Web框架。<br>使用koa编写web应用，通过组合不同的generator，可以避免重复繁琐的回调函数嵌套，极大的提升错误处理的效率。<br>koa不在内核方法中绑定任何中间件，它仅提供了一个轻量优雅的函数库，使得编写Web应用变得得心应手。<br>koa是比express更精简，使用node新特性的中间件框架，有足够的扩展和中间件。</p>
<h5 id="Koa2和Express中间件的区别"><a href="#Koa2和Express中间件的区别" class="headerlink" title="Koa2和Express中间件的区别"></a>Koa2和Express中间件的区别</h5><ul>
<li><p>Koa2<br>  基于node的一个web开发框架，利用co作为底层运行框架，利用Generator的特性，实现“无回调”的异步处理；<br>  ES7;<br>  更小、更富有表现力、更健壮的基石；<br>  利用async函数、Koa丢弃回调函数，增强错误处理；<br>  很小的体积，因为没有捆绑任何中间件；<br>  类似堆栈的方式组织和执行；<br>  低级中间件层中提供高级“语法糖”，提高了互操性、稳健性；</p>
</li>
<li><p>Express<br>  Node的基础框架，基础Connect中间件，自身封装了路由、视图处理等功能；<br>  线性逻辑，路由和中间件完美融合，清晰明了；<br>  弊端是callback回调方式，不可组合、异常不可捕获；<br>  ES5;<br>  connect的执行流程：<br>  connect的中间件模型是线性的，即一个一个往下执行；</p>
</li>
</ul>
<ol>
<li><p>Handler的处理<br>Express普通回调函数，在同一线程上完成当前进程的所有Http请求；<br>Koa利用Generator Function作为响应器，co作为底层运行框架，利用Generator特性，实现“协程响应”；</p>
</li>
<li><p>路由<br>Express的路由是自身集成的；<br>Koa的需要引入中间件Koa-router；<br>（视图也是）</p>
</li>
<li><p>启动方式<br>koa采用new Koa()，express采用传统的函数形式function；</p>
</li>
<li><p>回调<br>Koa没有回调，express有回调；</p>
</li>
<li><p>Http Request<br>koa1使用this取代Express的req、res；</p>
</li>
<li><p>Context<br>Koa新增了一个Context对象，用来代替Express的Request和Response，作为请求的上下文对象。<br>还有Node原生提供的req、res、socket等对象；</p>
</li>
<li><p>生命周期<br> Express的生命周期不确定：<br> express内部执行异步函数，不能确定什么时候执行完；</p>
<p> Koa的确定：<br> koa是基于await/async，在执行下一步操作的时候，必须等待前端await执行完；</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;);</span><br><span class="line">const app &#x3D; express();</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(1); &#x2F;&#x2F; 1</span><br><span class="line">  next(); &#x2F;&#x2F; 2</span><br><span class="line">  console.log(2); &#x2F;&#x2F; 5</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3); &#x2F;&#x2F; 3</span><br><span class="line">  new Promise((resolve &#x3D;&gt; &#123; &#x2F;&#x2F; 4</span><br><span class="line">    setTimeout(resolve, 300);</span><br><span class="line">  &#125;)).then(() &#x3D;&gt; &#123;</span><br><span class="line">    next(); &#x2F;&#x2F; 6</span><br><span class="line">    console.log(4); &#x2F;&#x2F; 8</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(function(req, res) &#123;&#x2F;&#x2F; 7</span><br><span class="line">  res.send(&#39;Hello World&#39;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 3 2 4 </span><br><span class="line"></span><br><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(1); </span><br><span class="line">  await next(); </span><br><span class="line">  console.log(2); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3); </span><br><span class="line"></span><br><span class="line">  await new Promise(((resolve) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(resolve, 300);</span><br><span class="line">  &#125;)); </span><br><span class="line"></span><br><span class="line">  await next(); </span><br><span class="line">  console.log(4); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(async (ctx, next) &#x3D;&gt; &#123; </span><br><span class="line">  ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1 3 4 2</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><p>异步流程<br>Express采用callback来处理异步(ES5)；<br>Koa1采用generator(ES6)，Koa2采用async/await(ES7)；</p>
</li>
<li><p>错误处理<br>Express使用callback捕获异常，深层次的异常捕获不了；<br>Koa使用try catch，很好的解决异常捕获；</p>
</li>
<li><p>中间件<br>koa2的中间件：<br>通过async await实现的，中间件执行的顺序是“洋葱圈”模型。<br>中间件之间通过next函数联系，当一个中间件调用next()后，会将控制权交给下一个中间件，直到下一个中间件不再执行next()后，会沿路返回，将控制权交给前一个中间件。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; logger</span><br><span class="line">app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;1 - 开始&#39;)</span><br><span class="line">    await next();</span><br><span class="line">    const rt &#x3D; ctx.response.get(&#39;X-Response-Time&#39;);</span><br><span class="line">    console.log(&#39;1 - 结束&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; x-response-time</span><br><span class="line">app.use(async (ctx, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;2 - 开始&#39;)</span><br><span class="line">    const start &#x3D; Date.now();</span><br><span class="line">    await next();</span><br><span class="line">    const ms &#x3D; Date.now() - start;</span><br><span class="line">    ctx.set(&#39;X-Response-Time&#39;, &#96;$&#123;ms&#125;ms&#96;);</span><br><span class="line">    console.log(&#39;2 - 结束&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; response</span><br><span class="line">app.use(async ctx &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;3 - 开始&#39;)</span><br><span class="line">    ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">    console.log(&#39;3 - 结束&#39;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line"></span><br><span class="line">&#x2F;** </span><br><span class="line">1 - 开始</span><br><span class="line">2 - 开始</span><br><span class="line">3 - 开始</span><br><span class="line">3 - 结束</span><br><span class="line">2 - 结束</span><br><span class="line">1 - 结束</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<p>Express中间件：<br>一个接一个顺序执行，response响应写在最后一个中间件中。</p>
<p>特点：<br>app.use用来注册中间件；<br>遇到http请求，根据path和method判断触发哪些中间件；<br>实现next机制，即上一个中间件会通过next触发下一个中间件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const express &#x3D; require(&#39;express&#39;)</span><br><span class="line"></span><br><span class="line">const app &#x3D; express()</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;1 - 开始&#39;)</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    console.log(&#39;1 - 结束&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use((req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;2 - 开始&#39;)</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        next()</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    console.log(&#39;2 - 结束&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use(&#39;&#x2F;api&#39;, (req, res, next) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;3 - 开始&#39;)</span><br><span class="line">    res.json(&#123;</span><br><span class="line">        code: 0</span><br><span class="line">    &#125;)</span><br><span class="line">    console.log(&#39;3 - 结束&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.listen(3000, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;server is running on port 3000&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">    1 - 开始</span><br><span class="line">    1 - 结束</span><br><span class="line">    2 - 开始</span><br><span class="line">    2 - 结束</span><br><span class="line">    3 - 开始</span><br><span class="line">    3 - 结束</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>前端（Css、Html）</title>
    <url>/articles/2020-02-08-interview-cssHtml.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-四种定位的区别"><a href="#1-四种定位的区别" class="headerlink" title="1. 四种定位的区别"></a>1. 四种定位的区别</h4><ul>
<li>static：默认值</li>
<li>relative：相对定位，相对于自身原有位置进行偏移，仍处于标准文档流中</li>
<li>absolute：绝对定位，相对于最近的已定位的祖先元素，有已定位祖先元素，以最近的祖先元素为标准。如果无已定位祖先元素，以body元素为偏移参照基准，完全脱离了标椎文档流</li>
<li>fixed：固定定位的元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原来在页面应有的空隙</li>
</ul>
<h4 id="2-Flex布局用的多吗？"><a href="#2-Flex布局用的多吗？" class="headerlink" title="2. Flex布局用的多吗？"></a>2. Flex布局用的多吗？</h4><p>因为项目考虑兼容IE9 用的不多</p>
<h4 id="3-移动端适配怎么做的？"><a href="#3-移动端适配怎么做的？" class="headerlink" title="3. 移动端适配怎么做的？"></a>3. 移动端适配怎么做的？</h4><p>使用媒体查询做的响应式布局，根据不同屏幕宽度加载不同css</p>
<h4 id="4-浏览器是怎么加载一个HTML的"><a href="#4-浏览器是怎么加载一个HTML的" class="headerlink" title="4. 浏览器是怎么加载一个HTML的"></a>4. 浏览器是怎么加载一个HTML的</h4><ul>
<li>加载HTML</li>
<li>解析器解析html</li>
<li>创建Dom树，加载css</li>
<li>解析器解析css，将css规则集应用于dom树节点</li>
<li>浏览器展示页面</li>
</ul>
<h4 id="5-css2与css3"><a href="#5-css2与css3" class="headerlink" title="5. css2与css3"></a>5. css2与css3</h4><h4 id="6-css2的水平居中与垂直居中"><a href="#6-css2的水平居中与垂直居中" class="headerlink" title="6. css2的水平居中与垂直居中"></a>6. css2的水平居中与垂直居中</h4><p>css2的水平居中：<br>    display为行内元素，text-align:center<br>    或：块级元素定义为一个宽度，再margin:0 auto；</p>
<p>垂直居中：<br>    单行内容的垂直通过设置相同的height和line-height<br>    多行且高度可变通过设置上下相同的padding<br>    行级盒子—-小图标和标题对齐设置vertical-aligh:middle<br>    绝对定位—-top:50%  left:50,需要已知块级的kuangao</p>
<p>css3水平居中：<br>display为flex，justify-content:center</p>
<h4 id="7-BFC"><a href="#7-BFC" class="headerlink" title="7. BFC"></a>7. BFC</h4><p>BFC：Block Formatting Context 块格式化上下文</p>
<p>生成BFC：</p>
<ul>
<li><p>float:left/right</p>
</li>
<li><p>根元素html</p>
</li>
<li><p>overflow:hidden,auto,scoll</p>
</li>
<li><p>display:inline-block</p>
</li>
<li><p>position:fixed,absolute</p>
<p>BFC规则：</p>
</li>
<li><p>垂直方向上的距离由margin决定，属于同一个BFC的两个相邻的标签的margin会发生重叠；</p>
</li>
<li><p>每个标签的左外边距与包含块的左外边界相接触，即使浮动标签也是如此；</p>
</li>
<li><p>BFC的区域不会与浮动的标签区域重叠；</p>
</li>
<li><p>计算BFC高度的时候，浮动子元素也参与计算；</p>
</li>
<li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的标签，反之亦然。</p>
<p>BFC能解决什么问题？</p>
</li>
<li><p>外边距重叠</p>
</li>
<li><p>自适应两栏或三栏布局</p>
</li>
<li><p>防止字体环绕</p>
</li>
<li><p>清除浮动</p>
</li>
</ul>
<h4 id="8-IFC"><a href="#8-IFC" class="headerlink" title="8. IFC"></a>8. IFC</h4><p>Inline Formatting Contexts  内联格式化上下文<br>IFC的line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的padding/margin影响)</p>
<p>IFC有一下特性：</p>
<ul>
<li>IFC中的line box一般左右都贴紧整个IFC，但是会因为float元素而扰乱。float元素会位于IFC与与line box之间，使得line box宽度缩短。 </li>
<li>IFC中时不可能有块级元素的，当插入块级元素时（如p中插入div）会产生两个匿名块与div分隔开，即产生两个IFC，每个IFC对外表现为块级元素，与div垂直排列。</li>
</ul>
<p>那么IFC一般有什么用呢？<br>水平居中：当一个块要在环境中水平居中时，设置其为inline-block则会在外层产生IFC，通过text-align则可以使其水平居中。<br>垂直居中：创建一个IFC，用其中一个元素撑开父元素的高度，然后设置其vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。</p>
<h4 id="9-对栅格的理解"><a href="#9-对栅格的理解" class="headerlink" title="9. 对栅格的理解"></a>9. 对栅格的理解</h4><h4 id="10-1像素边框问题"><a href="#10-1像素边框问题" class="headerlink" title="10. 1像素边框问题"></a>10. 1像素边框问题</h4><p>对于不同的移动设备，其物理像素与逻辑像素间存在不同的比例关系。所以我们仅仅在CSS中为border设置1px时，在手机上看起来会显得比较粗，达不到预期效果。</p>
<p>如何解决1px问题</p>
<ul>
<li>媒体查询利用设备像素比缩放，设置小数像素</li>
<li>viewport + rem 方案</li>
<li>设置 border-image 方案</li>
<li>background-image 渐变实现</li>
<li>box-shadow 方案</li>
<li>transform: scale(0.5) 方案 - 推荐: 很灵活</li>
</ul>
<h4 id="11-rem和em有什么去区别啊？"><a href="#11-rem和em有什么去区别啊？" class="headerlink" title="11. rem和em有什么去区别啊？"></a>11. rem和em有什么去区别啊？</h4><p>css中单位长度用的最多的是px、em、rem，这三个的区别是：<br>　　px是固定的像素，一旦设置了就无法因为适应页面大小而改变。<br>　　em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。</p>
<p>对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。<br>rem中的r意思是root（根源）</p>
<ul>
<li><p>em<br>  子元素字体大小的em是相对于父元素字体大小<br>  元素的width/height/padding/margin用em的话是相对于该元素的font-size</p>
</li>
<li><p>rem<br>  rem是全部的长度都相对于根元素，根元素是谁？<html>元素。<br>  通常做法是给html元素设置一个字体大小，然后其他元素的长度单位就为rem</p>
</li>
</ul>
<h4 id="12-LESS-SASS-PostCSS"><a href="#12-LESS-SASS-PostCSS" class="headerlink" title="12. LESS, SASS, PostCSS"></a>12. LESS, SASS, PostCSS</h4><ul>
<li><p>Sass：<br>一种动态样式语言，Sass语法属于缩排语法，比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。<br>Sass与Scss是什么关系?<br>Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。</p>
</li>
<li><p>Less：<br>Less也是一种动态样式语言. 受Sass影响较大,对CSS赋予了动态语言的特性，如变量，继承，运算， 函数. Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行 (借助 Node.js)。</p>
</li>
</ul>
<h4 id="13-简单介绍下盒模型，以及flexbox-弹性布局"><a href="#13-简单介绍下盒模型，以及flexbox-弹性布局" class="headerlink" title="13. 简单介绍下盒模型，以及flexbox 弹性布局"></a>13. 简单介绍下盒模型，以及flexbox 弹性布局</h4><p>块状只需要display属性规定为flex即可。 行内元素也可以指定为flex布局，将display属性设置为inline-flex</p>
<h4 id="14-position和float的区别？"><a href="#14-position和float的区别？" class="headerlink" title="14. position和float的区别？"></a>14. position和float的区别？</h4><ul>
<li>相同：<br>  设置后，对应的模块都会脱离文档流</li>
<li>不同点：<br>  position相应的块级元素会覆盖下面的内容（文字，），<br>  而float只会覆盖块级元素，里面的文字会脱离出来<br>  float是浮动定位，position是绝对定位</li>
</ul>
<h4 id="15-HTML5-有哪些新特性及API"><a href="#15-HTML5-有哪些新特性及API" class="headerlink" title="15. HTML5 有哪些新特性及API"></a>15. HTML5 有哪些新特性及API</h4><ul>
<li><p>document.querySelector()和document.querySelectorAll()方法<br>document.querySelector()：根据css选择器返回第一个匹配的元素，如果没有匹配返回null；<br>document.querySelectorAll(“selector”)：querySelectorAll和querySelector作用一样的，只是querySelectorAll返回的是元素数组，querySelector返回的是一个元素。如果querySelectorAll没有匹配的内容返回的是一个空数组。</p>
</li>
<li><p>HTML5之classList属性<br>classList属性没有出现之前js操作元素class都是使用className,但是在开发一个网站的时候标签的class不只是一个，有可能有很多</p>
</li>
<li><p>HTML5之全屏<br>为了方便用户的阅读或者观看视频，很多的网站实现了全屏功能。FullScreen API 是一个新的JavaScript API,简单而又强大. FullScreen 让我们可以通过编程的方式来向用户请求全屏显示,如果交互完成,随时可以退出全屏状态.</p>
</li>
<li><p>HTML5之页面可见性(Page Visibility)</p>
</li>
<li><p>HTML5 之预加载<br>网站优化一直是项目开发中的重点之中，常用的优化方式主要有：图片懒加载、图片sprite、css合并、js合并、数据本地存储、数据网络缓存等。这些都是项目中经常使用的，HTML5考虑到了这一点，提出了链接预加载的方法<br>预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。<br>浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中,<br>页面就得以快速呈现。</p>
</li>
<li><p>自定义数据属性<br>HTML5 规定可以为元素添加非标准的属性，但要添加前缀data-，目的是为元素提供与渲染无关的信息，或者提供语义信息。这些属性可以任意添加、随便命名，只要以data-开头即可。</p>
</li>
<li><p>outerHTML 属性<br>在读模式下，outerHTML 返回调用它的元素及所有子节点的HTML 标签。在写模式下，outerHTML会根据指定的HTML 字符串创建新的DOM 子树，然后用这个DOM子树完全替换调用元素。</p>
</li>
<li><p>insertAdjacentHTML()方法<br>插入标记的最后一个新增方式是insertAdjacentHTML()方法。它接收两个参数：插入位置和要插入的HTML 文本。第一个参数必须是下列值之一：<br>  “beforebegin”，在当前元素之前插入一个紧邻的同辈元素；<br>  “afterbegin”，在当前元素之下插入一个新的子元素或在第一个子元素之前再插入新的子元素；<br>  “beforeend”，在当前元素之下插入一个新的子元素或在最后一个子元素之后再插入新的子元素；<br>  “afterend”，在当前元素之后插入一个紧邻的同辈元素。</p>
</li>
</ul>
<h4 id="16-Canvas的实现原理"><a href="#16-Canvas的实现原理" class="headerlink" title="16. Canvas的实现原理"></a>16. Canvas的实现原理</h4><p>canvas本身并不具备绘画能力，它本身只是一个画布，是一个容器。绘图能力是基于html5的getContext(“2d”)返回的CanvasRenderingContext2D对象来完成的。</p>
<p>canvas是一个二维网络，以画布左上角（0,0）为坐标原点，x轴向右延伸，y轴向下延伸。所以canvas画布中的坐标全为正数，没有负数。</p>
<h4 id="17-div居中方式"><a href="#17-div居中方式" class="headerlink" title="17. div居中方式"></a>17. div居中方式</h4><ul>
<li><p>适用于固定宽高的元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">margin-top: 高度的一半;</span><br><span class="line">margin-left: 宽度的一半</span><br></pre></td></tr></table></figure></li>
<li><p>用在居中的元素本身</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 50%;</span><br><span class="line">left: 50%;</span><br><span class="line">transform: translate(-50%, -50%)</span><br></pre></td></tr></table></figure>
</li>
<li><p>绝对定位要注意父级定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">position: absolute;</span><br><span class="line">top: 0;</span><br><span class="line">bottom: 0;</span><br><span class="line">left: 0;</span><br><span class="line">right: 0;</span><br><span class="line">margin: auto;</span><br></pre></td></tr></table></figure></li>
<li><p>放在居中元素的父级元素上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display: flex;</span><br><span class="line">align-items: center;</span><br><span class="line">justify-content: center;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级元素设置两个参数（height = line-height）会让块级元素内部的行级元素垂直水平居中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">height &#x3D; line-height;</span><br><span class="line">text-align: center;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="18-用一个div模拟textarea的实现"><a href="#18-用一个div模拟textarea的实现" class="headerlink" title="18. 用一个div模拟textarea的实现"></a>18. 用一个div模拟textarea的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#textarea &#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    min-height:150px;</span><br><span class="line">    max-height:300px;</span><br><span class="line">    overflow: auto;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    outline: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id&#x3D;&quot;textarea&quot; contenteditable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h4 id="19-左右布局：左边定宽、右边自适应"><a href="#19-左右布局：左边定宽、右边自适应" class="headerlink" title="19. 左右布局：左边定宽、右边自适应"></a>19. 左右布局：左边定宽、右边自适应</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">   &lt;p&gt;左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">   &lt;p&gt;右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>左边左浮动，右边margin-left</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">   float: left;</span><br><span class="line">   width: 200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">   margin-left:200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>左边绝对定位，右边margin-left</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   top: 0;</span><br><span class="line">   left: 0;</span><br><span class="line">   width: 200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    margin-left:200px;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    word-break: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左右两边都用绝对定位</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 200px;</span><br><span class="line">   top:0;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左边左浮动，右边overflow:hidden</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 200px;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">     overflow: hidden;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>弹性布局，左边固定宽度，右边flex</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">     width: 200px;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex:1;</span><br><span class="line">    width: 0;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="20-CSS3有哪些新的特性？"><a href="#20-CSS3有哪些新的特性？" class="headerlink" title="20. CSS3有哪些新的特性？"></a>20. CSS3有哪些新的特性？</h4><ul>
<li><p>css3的新选择器：<br>nth-child(n)选择器匹配其父元素的第n个子元素，不论元素类型，n可以使数字、关键字或公式；<br>nth-of-type(n)选择与之其匹配的父元素的第N个元素<br>first-child相对于父级做参考，所有子元素的第一个子元素，并且位置相对应<br>first-of-type相对于父级做参考，特定类型的第一个子元素<br>empty选择没有子元素的每个E元素<br>target选择当前活动的E元素<br>selection选择被用户选取的元素部分</p>
</li>
<li><p>文本<br>text-shadow:2px 2px 8px #000参数1向右的偏移量，参数2为向左的偏移量，参数3为渐变的像素，4为颜色；<br>text-overflow：规定当文本溢出包含元素时发生的事情，text-overflow:ellipsis(省略)<br>text-wrap：规定文本换行的规则<br>word-break：规定非中日韩文本的换行规则<br>word-wrap：对长的不可分割的单词进行分割并换行到下一行<br>white-space：规定如何处理元素中的空白；</p>
<pre><code>white-space:nowrap规定段落中的文本不进行换行</code></pre></li>
<li><p>边框<br>border-raduis：50%边框的圆角<br>border-image：边框图片<br>.border-image {<br>  border-image-source:url(images/border.png);<br>  boder-image-slice:27;<br>  border-image-width:10px;<br>  border-iamge-repeat:round; (round平铺) 平铺效果不作用于四角，只适应与四边<br>}</p>
</li>
<li><p>背景<br>rgba<br>background-size：cover/contain,其中cover会使最大边进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。<br>  contain会使最小边缩放，另一边同比缩放，不一定铺满容器，会完整显示图片。</p>
</li>
<li><p>渐变<br>liner-gradient<br>background-image:linear-gradient(90deg,yellow 20%,green 80%)<br>radial-gradient<br>background-iamge:radial-gradient(120px at center center,yellow,green)</p>
</li>
<li><p>多列布局<br>column-count<br>column-width<br>column-gap<br>column-rule</p>
</li>
<li><p>过渡<br>transition<br>transition-property:width<br>transition-duration:2s<br>transition-timing-function:ease<br>transition-delay:5s</p>
</li>
<li><p>动画、旋转<br>animation<br>transform: translate(x,y) rotate(deg) scale(x, y)<br>translate<br>scale<br>rotate<br>skew(倾斜)</p>
</li>
</ul>
<h4 id="21-flex布局"><a href="#21-flex布局" class="headerlink" title="21. flex布局"></a>21. flex布局</h4><h4 id="22-media媒体查询"><a href="#22-media媒体查询" class="headerlink" title="22. @media媒体查询"></a>22. @media媒体查询</h4><h4 id="23-Web前端性能优化常见方法"><a href="#23-Web前端性能优化常见方法" class="headerlink" title="23. Web前端性能优化常见方法"></a>23. Web前端性能优化常见方法</h4><ol>
<li><p>内容优化</p>
<ul>
<li>减少http请求数</li>
<li>减少DNS查找</li>
<li>避免重定向</li>
<li>使用Ajax缓存</li>
<li>延迟加载组件，预加载组件</li>
<li>减少DOM元素数量</li>
<li>最小化iframe数量</li>
<li>避免404</li>
</ul>
</li>
<li><p>服务器优化</p>
<ul>
<li>使用内容分发网络：把网站内容分散到多个、处于不同地域位置的服务器上可以加快下载速度</li>
<li>GZIP压缩</li>
<li>设置ETag</li>
<li>提前刷新缓冲区</li>
<li>对Ajax请求使用get方法</li>
<li>避免空的图像src</li>
</ul>
</li>
<li><p>Cookie优化</p>
<ul>
<li>减少Cookie大小</li>
<li>针对web组件使用域名无关的Cookoe</li>
</ul>
</li>
<li><p>CSS优化</p>
<ul>
<li>将css代码放在Html页面的顶部</li>
<li>避免使用css表达式</li>
<li>使用<link>来代替@import</li>
<li>避免使用Filters</li>
</ul>
</li>
<li><p>JavaScript优化</p>
<ul>
<li>将JavaScript脚本放在页面的底部</li>
<li>将JavaScript和Css作为外部文件来引用</li>
<li>缩小JavaScript和Css</li>
<li>删除重复的脚本</li>
<li>最小化DOM的访问</li>
<li>开发智能的事件处理程序</li>
<li>JavaScript代码注意：谨慎使用with，避免使用eval Function函数，减少作用域链查找</li>
</ul>
</li>
<li><p>图像优化</p>
<ul>
<li>优化图片大小</li>
<li>通过CSS Sprites优化图片</li>
<li>不要在Html中使用缩放图片</li>
<li>facicon.ico要小而且可缓存</li>
</ul>
</li>
</ol>
<h4 id="24-DOM加载"><a href="#24-DOM加载" class="headerlink" title="24. DOM加载"></a>24. DOM加载</h4>]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Node</title>
    <url>/articles/2020-02-08-interview-node.html</url>
    <content><![CDATA[<a id="more"></a>

<h4 id="1-node？"><a href="#1-node？" class="headerlink" title="1. node？"></a>1. node？</h4><p>node既是开发平台，也是运行环境，也是新的语言。<br>本身是基于google的JavaScript V8引擎开发的。<br>一个运行在服务端的基于Chrome V8 engine的js运行环境(runtime)。</p>
<p>简单强大、轻量可扩展。</p>
<p>简单：node使用的是JavaScript，json来进行编码，人人都会；<br>强大：非阻塞IO，可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；<br>轻量：node本身既是代码，又是服务器，前后端使用统一语言；<br>可扩展性：轻松应对多实例，多服务架构，同时拥有海量的第三方应用组件；</p>
<h5 id="node单线程支持高并发原理？"><a href="#node单线程支持高并发原理？" class="headerlink" title="node单线程支持高并发原理？"></a>node单线程支持高并发原理？</h5><p>node与操作系统交互，我们再JavaScript中调用的方法，最终都会通过process.binding传递到C/C++层面，最终由他们来执行真正的操作，Nodejs即这样与操作系统进行互动；<br>nodejs所谓的单线程，只是主线程是单线程，所有网络请求或者异步任务都交给了内部的线程池去实现，本身只负责不断的往返调度，由事件循环不断驱动事件执行；<br>nodejs之所以单线程可以处理高并发的原因，得益于libuv层的事件循环机制和底层线程池实现；<br>Event loop就是主线程从主线程的事件队列里面不停循环的读取事件，驱动了所有的异步回调函数的执行，Event loop总共7个阶段，每个阶段都有一个任务队列，当所有阶段被顺序执行一次后，event loop完成了一个tick；</p>
<ul>
<li><ol>
<li>node的优点：I/O密集型处理是node的强项，因为node的I/O请求都是异步的<br>异步–发出操作指令，就可以去做别的事情了（主线程不需要等待），所有操作完成后再执行回调；</li>
</ol>
</li>
<li><ol start="2">
<li>拥有异步I/O的node为什么可以支持高并发？<br>因为I/O操作是由node的工作线程去执行的（nodejs底层的libuv是多线程的线程池来执行io操作），且主线程是不需要等待结果返回的，只要发出指令就可以去忙其他事情了。</li>
</ol>
</li>
<li><ol start="3">
<li>虽然nodejs的I/O操作开启了多线程，但所有线程都是基于node服务进行开启的，并不能充分利用cpu资源<br>pm2进程管理器可以解决这个问题；<br>pm2是一个带有负载均衡功能的Node应用的进程管理器；</li>
</ol>
</li>
<li><ol start="4">
<li>cpu核数与线程之间的关系<br>在过去单cpu时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。而现在多核CPU的情况下，同一时间点可以执行多个任务，具体到这个任务在CPU哪个核上运行，这个就跟操作系统和CPU本身的设计相关了。</li>
</ol>
</li>
</ul>
<h5 id="node可以免费使用吗？"><a href="#node可以免费使用吗？" class="headerlink" title="node可以免费使用吗？"></a>node可以免费使用吗？</h5><p>是，它是在MIT许可下发布的，可以免费使用。</p>
<h5 id="Node是单线程应用程序吗？"><a href="#Node是单线程应用程序吗？" class="headerlink" title="Node是单线程应用程序吗？"></a>Node是单线程应用程序吗？</h5><p>是的，Node是一个带有事件循环的单线程应用程序。</p>
<h4 id="NOde的使用目的是什么"><a href="#NOde的使用目的是什么" class="headerlink" title="NOde的使用目的是什么"></a>NOde的使用目的是什么</h4><ul>
<li>构建实时Web应用程序</li>
<li>网络应用</li>
<li>分布式系统</li>
<li>通用应用程序</li>
</ul>
<h4 id="2-node有哪些特质，与其他服务器端对比"><a href="#2-node有哪些特质，与其他服务器端对比" class="headerlink" title="2. node有哪些特质，与其他服务器端对比"></a>2. node有哪些特质，与其他服务器端对比</h4><p>特征：单线程、事件驱动、非阻塞I/O.<br>适合做一些如：<br>    聊天室、表单提交等不需要大量计算的功能<br>    做一些微信后端开发、或消息系统；</p>
<ul>
<li>node无法直接渲染静态页面，提供静态服务；</li>
<li>node没有根目录的概念；</li>
<li>node必须通过路由程序指定文件才能渲染文件；</li>
<li>node比其他服务端性能更好，速度更快；</li>
</ul>
<h4 id="3-node优点？"><a href="#3-node优点？" class="headerlink" title="3. node优点？"></a>3. node优点？</h4><p>高并发；<br>高效、轻量；<br>node是基于事件驱动和非阻塞的I/O模型，所以比较适合处理并发请求，执行效率非常高；<br>Node非常快，因为它建立在Google Chrome的V8引擎上，它的库在代码执行方面非常快；<br>Node是单线程但高度可扩展的；<br>Node提供了无缓冲的功能，它的应用从不缓冲任何数据，它以块的形式输出数据；</p>
<h5 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h5><p>I/O代表输入和输出，它可以访问应用程序之外的任何内容。<br>一旦应用程序启动，它就会加载到机器内存中以允许程序。</p>
<h5 id="事件循环可以异步完成哪些类型的任务？"><a href="#事件循环可以异步完成哪些类型的任务？" class="headerlink" title="事件循环可以异步完成哪些类型的任务？"></a>事件循环可以异步完成哪些类型的任务？</h5><p>Nodejs中，进程是单线程的，为支持并发，它使用事件和回调。事件循环是一种允许Nodejs执行非阻塞IO操作的机制</p>
<ul>
<li>I/O操作</li>
<li>繁重的计算</li>
<li>任何需要阻止的东西</li>
</ul>
<p>nodejs是单线程single thread运行的，通过一个事件循环event-loop来循环取出消息队列event-queue中的消息进行处理，处理过程基本上就是去调用该消息对应的回调函数，消息队列就是当一个事件状态发生变化时，就将一个消息压入队列中。</p>
<p>nodejs的事件驱动模型要注意：</p>
<ul>
<li>因为是单线程的，所以当顺序执行js文件中代码的时候，事件循环是被暂停的；</li>
<li>当js文件执行完以后，事件循环开始运行，并从消息队列中取出消息，开始执行回调函数；</li>
<li>因为是单线程的，所以当回调函数被执行的时候，事件循环是被暂停的；</li>
<li>当涉及到I/O操作的时候，nodejs会开一个独立的线程来进行一步I/O操作，操作结束以后将消息压入消息队列；</li>
</ul>
<h5 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h5><p>V8是谷歌的开源高性能JavaScript引擎，用C++编写，用于谷歌Chrome，Google的开源浏览器和Nodejs等。<br>它实现了ECMA-262中指定的ECMAScript，并在windows7或更高版本，macOS 10.5+及使用IA-32，ARM或MIPS处理器的Linux系统上运行。V8可以独立运行，也可以嵌入到任何C++应用程序中。<br>【JavaScript引擎是一个将用JavaScript编写的代码转换为计算机处理器可以理解的代码的程序。】</p>
<h4 id="4-node的缺点？"><a href="#4-node的缺点？" class="headerlink" title="4. node的缺点？"></a>4. node的缺点？</h4><ul>
<li>Node是一个相对新的开源项目，不太稳定，总是在变，而且缺少足够的第三方库的支持；</li>
<li>不适合CPU密集型应用，会导致主线程阻塞，阻止后续程序运行<br>（cpu密集型操作：复杂的运算、图片的操作）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 密集型操作</span><br><span class="line">for (let i&#x3D;0; i&lt;10000000000; i++) &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
原因：<br>因为JavaScript单线程原因，如果长时间运行的计算，将会导致cpu时间片不能释放，使得后续I/O无法发起）。<br>node单线程，进行密集型的运算会导致主线程挂起。<br>解决方案：<br>分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；</li>
<li>只支持单核CPU，不能充分利用CPU<br>解决方案：<br>（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；<br>（2）开多个进程监听同一个端口，使用cluster模块；</li>
</ul>
<h4 id="5-node的组成？"><a href="#5-node的组成？" class="headerlink" title="5. node的组成？"></a>5. node的组成？</h4><ul>
<li>v8 engine<br>  两个作用：<br>  一是作为虚拟机，负责js的解释执行；<br>  二是提供c++函数接口，为node提供v8初始化，创建context、scope等；</li>
<li>libuv<br>libuv是基于事件驱动的异步I/O模型库，nodejs中事件、线程、I/O等操作都依赖于libuv实现。</li>
<li>builtiin modules内置模块<br>  内置模块是由c++编写的模块，一般用于native modules调用。</li>
<li>native modules<br>  native modules是由js编写的模块，如http、crypto、zlib、buffer、fs等，同时这些模块又依赖builtin modules等来获取相应的服务支持。</li>
</ul>
<p>运行原理：<br>把nodejs看做一个黑匣子，暴露给开发者的接口则是native modules，当发起请求时，请求自上而下，穿越native modules，通过builtin modules将请求传送至v8，libuv和其它辅助服务，请求结束，则从下回溯到上，最终调用我们的回调函数。</p>
<h4 id="6-node的构架是什么样子的？"><a href="#6-node的构架是什么样子的？" class="headerlink" title="6. node的构架是什么样子的？"></a>6. node的构架是什么样子的？</h4><p>主要分三层：应用app 》》 V8及node内置架构 》》操作系统。<br>V8是node运行环境，可以理解为node虚拟机<br>node内置架构又分为三层：核心模块（JavaScript实现） 》》c++绑定 》》libuv + CAes + http</p>
<h4 id="7-node的同步、异步、阻塞、非阻塞"><a href="#7-node的同步、异步、阻塞、非阻塞" class="headerlink" title="7. node的同步、异步、阻塞、非阻塞"></a>7. node的同步、异步、阻塞、非阻塞</h4><ul>
<li>同步：调用者等待被调用者这个过程，如果被调用者一直不返回结果，调用者就会一直等待。<pre><code>同步有返回值。</code></pre></li>
<li>异步：调用者不等待被调用者是否返回，被调用者执行问了就会通过状态、通知或回调函数给调用者。<pre><code>异步没有返回值。</code></pre></li>
<li>阻塞：指代当前线程在结果返回之前会被挂起，不会继续执行下去。</li>
<li>非阻塞：即当前线程不管返回什么，都会继续往下执行。</li>
</ul>
<h4 id="8-node的进程与线程"><a href="#8-node的进程与线程" class="headerlink" title="8. node的进程与线程"></a>8. node的进程与线程</h4><p>进程是操作系统分配资源和调度任务的基本单位<br>线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。</p>
<h4 id="9-node核心模块"><a href="#9-node核心模块" class="headerlink" title="9. node核心模块"></a>9. node核心模块</h4><p>EventEmitter，Stream，FS，Net和全局对象</p>
<h4 id="10-node全局对象？"><a href="#10-node全局对象？" class="headerlink" title="10. node全局对象？"></a>10. node全局对象？</h4><p>process,console,Buffer,exports</p>
<h4 id="11-process有哪些常用方法？"><a href="#11-process有哪些常用方法？" class="headerlink" title="11. process有哪些常用方法？"></a>11. process有哪些常用方法？</h4><p>process.stdin, process.stdout, process,stderr, process.on, process.env, </p>
<h4 id="12-Stream有什么好处？"><a href="#12-Stream有什么好处？" class="headerlink" title="12. Stream有什么好处？"></a>12. Stream有什么好处？</h4><p>非阻塞式数据处理提升效率，片段处理节省内存，管道处理方便可扩展等。</p>
<h4 id="13-Stream有哪些典型应用？"><a href="#13-Stream有哪些典型应用？" class="headerlink" title="13. Stream有哪些典型应用？"></a>13. Stream有哪些典型应用？</h4><p>文件、网络、数据转换、音频视频等。</p>
<h4 id="14-nodejs中的Stream和Buffer区别？"><a href="#14-nodejs中的Stream和Buffer区别？" class="headerlink" title="14. nodejs中的Stream和Buffer区别？"></a>14. nodejs中的Stream和Buffer区别？</h4><p>Buffer：数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据。<br>Stream：是对buffer对象的高级封装，其操作的底层还是buffer对象，stream可以设置为可读、可写，或可读可写，在nodejs中继承了EventEmitter接口，可以监听读入、写入的过程，具体实现有文件流等。</p>
<h4 id="15-fs-watch和fs-watchFile有什么区别？"><a href="#15-fs-watch和fs-watchFile有什么区别？" class="headerlink" title="15. fs.watch和fs.watchFile有什么区别？"></a>15. fs.watch和fs.watchFile有什么区别？</h4><p>fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统<br>fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不适实时机制；</p>
<h4 id="16-node的网络模块架构是什么样子的？"><a href="#16-node的网络模块架构是什么样子的？" class="headerlink" title="16. node的网络模块架构是什么样子的？"></a>16. node的网络模块架构是什么样子的？</h4><p>node全面支持各种网络服务器和客户端，包括tcp, http/https, tcp, udp, dns, tls/ssl等。</p>
<h4 id="17-node是如何支持https-tls的？"><a href="#17-node是如何支持https-tls的？" class="headerlink" title="17. node是如何支持https, tls的？"></a>17. node是如何支持https, tls的？</h4><ul>
<li>openSSL生成公钥私钥；</li>
<li>服务器或客户端使用https替代http</li>
<li>服务器或客户端加载公钥私钥证书</li>
</ul>
<h4 id="18-为什么需要child-process"><a href="#18-为什么需要child-process" class="headerlink" title="18. 为什么需要child-process?"></a>18. 为什么需要child-process?</h4><p>node是异步非阻塞的，这对高并发非常有效，但有些其他的需求，比如操作系统shell命令交互，调用可执行文件，创建子进程进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的，child-process顾名思义，就是把node阻塞的工作交给子进程去做。</p>
<h4 id="19-exec-execFile-spawn-fork都是做什么的？"><a href="#19-exec-execFile-spawn-fork都是做什么的？" class="headerlink" title="19. exec, execFile, spawn, fork都是做什么的？"></a>19. exec, execFile, spawn, fork都是做什么的？</h4><ul>
<li>exec可以用操作系统原生的方式执行各种命令，如管道cat ab.txt | grep hello</li>
<li>execFile是执行文件</li>
<li>spawn是流式和操作系统进行交互</li>
<li>fork是两个node程序(JavaScript)之间时行交互</li>
</ul>
<h4 id="20-两个node程序之间怎样交互？"><a href="#20-两个node程序之间怎样交互？" class="headerlink" title="20. 两个node程序之间怎样交互？"></a>20. 两个node程序之间怎样交互？</h4><p>fork，原理是：子进程用process.on, process.send，父程序里用child.on, child.send进行交互。</p>
<h4 id="21-怎样充分利用多个CPU？"><a href="#21-怎样充分利用多个CPU？" class="headerlink" title="21. 怎样充分利用多个CPU？"></a>21. 怎样充分利用多个CPU？</h4><p>一个CPU运行一个node实例。</p>
<h4 id="22-有哪些常用方法可以防止程序崩溃？"><a href="#22-有哪些常用方法可以防止程序崩溃？" class="headerlink" title="22. 有哪些常用方法可以防止程序崩溃？"></a>22. 有哪些常用方法可以防止程序崩溃？</h4><ul>
<li>try-catch-finally</li>
<li>EventEmitters/Stream error事件处理</li>
<li>domain统一控制</li>
<li>jshint静态检查</li>
<li>mocha进行单元测试</li>
</ul>
<h4 id="23-调试node程序？"><a href="#23-调试node程序？" class="headerlink" title="23. 调试node程序？"></a>23. 调试node程序？</h4><p>node-inspector<br>node –debug app.js</p>
<h4 id="24-async常用的方法？"><a href="#24-async常用的方法？" class="headerlink" title="24. async常用的方法？"></a>24. async常用的方法？</h4><p>async是一个js类库，目的是解决js中异常流程难以控制问题，async不仅适用nodejs里，浏览器中也可以适用。</p>
<ul>
<li>async.parallel并行执行多个函数后，调用结束函数</li>
<li>async.series串行执行多个函数后，调用结束函数</li>
<li>async.waterfall依次执行多个函数，后一个函数以前面函数的结果作为输入参数</li>
<li>async.map异步执行多个数组，返回结果数组</li>
<li>async.filter异步过滤多个数组，返回结果数组</li>
</ul>
<h4 id="25-async-await内部机制"><a href="#25-async-await内部机制" class="headerlink" title="25. async await内部机制"></a>25. async await内部机制</h4><p>async函数就是generator函数的语法糖；<br>async函数是将generator函数的*换成async，将yield替换成await；<br>async是对generator的改进：</p>
<ul>
<li>内置执行器，不需要使用next()手动执行；</li>
<li>await命令后面可以是Promise对象或原始类型的值；</li>
<li>返回值是promise；</li>
</ul>
<p>作用：异步编程的终极解决方案。</p>
<p>执行顺序：<br>函数执行时，一旦遇到await就会返回。等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>async是对Promise的又一次封装，它有then和catch方法，内部可以有return返回值，返回一个Promise对象，返回值是then的参数。</p>
<h4 id="26-promise"><a href="#26-promise" class="headerlink" title="26. promise"></a>26. promise</h4><p>Promise内部实现机制：<br>    promise用来实现一步操作，解决了回调地域的问题。<br>    相当于一个容器，里面保存了某些未来才结束的事件的结果。<br>    promise对象的状态不受外部的影响。</p>
<p>Promise实例生成以后，可以用then方法指定resolved状态和reject状态的回调函数。</p>
<ul>
<li>promise是一个对象，对象和函数的区别是对象可以保存状态，函数不可以</li>
<li>并未剥夺函数return的能力，因此无需层次传递callback，进行回调获取数据</li>
<li>代码风格，容易理解，便于维护</li>
<li>多个异步等待合并便于解决</li>
</ul>
<p>promise三个状态：</p>
<ul>
<li>pending待定，初始状态</li>
<li>fulfilled实现，操作成功</li>
<li>rejected被否决，操作失败</li>
</ul>
<p>promise的状态改变，两种可能，情况只要发生，状态就凝固了，不会再变了：</p>
<ul>
<li>从pending变为fulfilled</li>
<li>从pending变为rejected</li>
</ul>
<p>Promise.all([])：批量执行；<br>Promise.race()：有任意一个完成就算完成；</p>
<p>.done()：<br>    Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局），因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">asyncFunc()</span><br><span class="line">    .then()</span><br><span class="line">    .catch()</span><br><span class="line">    .then()</span><br><span class="line">    .done()</span><br></pre></td></tr></table></figure>

<p>.finally()：<br>    用于指定不管Promise对象最后状态如何，都会执行的操作。<br>    与done的最大区别是：它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.listen(0)</span><br><span class="line">    .then(function() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    .finally(server.stop)</span><br></pre></td></tr></table></figure>
<h4 id="27-Promise-all、each、map、mapSeries、reduce"><a href="#27-Promise-all、each、map、mapSeries、reduce" class="headerlink" title="27. Promise.all、each、map、mapSeries、reduce"></a>27. Promise.all、each、map、mapSeries、reduce</h4><p>Promise.all:<br>等待所有过程结束；</p>
<p>Promise.map:<br>结合array.map和Promise.all;<br>加入concurrency参数可以控制同时并发的Promise个数；</p>
<p>Promise.reduce:<br>从左到右按顺序执行，只有一个Promise执行；</p>
<p>Promise.mapSeries:<br>和Promise.map类似；<br>但是按顺序执行的；</p>
<p>Promise.each:<br>顺序执行；<br>返回的数组不是所有Promise的结果，而是传入Promise.each的原始数据数组；</p>
<h4 id="28-什么是错误优先的回调函数？"><a href="#28-什么是错误优先的回调函数？" class="headerlink" title="28. 什么是错误优先的回调函数？"></a>28. 什么是错误优先的回调函数？</h4><p>错误优先的回调函数用于同时返回错误和数据。<br>第一个参数始终是一个错误对象，用于检查程序是否发生了错误<br>其余的参数用于传递数据</p>
<h4 id="29-如何避免回调地狱？"><a href="#29-如何避免回调地狱？" class="headerlink" title="29. 如何避免回调地狱？"></a>29. 如何避免回调地狱？</h4><h4 id="30-简述同步和异步的区别，如何避免回调地狱"><a href="#30-简述同步和异步的区别，如何避免回调地狱" class="headerlink" title="30. 简述同步和异步的区别，如何避免回调地狱"></a>30. 简述同步和异步的区别，如何避免回调地狱</h4><p>同步方法调用一旦开始，调用者必须等到方法调用返回之后，才能继续后续的行为；<br>异步方法调用一旦开始，方法调用就会立即返回，调用者就会继续后续的操作，而异步方法通常会在另外一个线程中，整个过程，不会阻碍调用者的工作。<br>避免回调地狱：</p>
<ul>
<li>Promsie</li>
<li>async/await</li>
<li>generator</li>
<li>事件发布/监听模式</li>
</ul>
<p>如何用Node来监听80端口？</p>
<h4 id="31-堆、栈和队列"><a href="#31-堆、栈和队列" class="headerlink" title="31. 堆、栈和队列"></a>31. 堆、栈和队列</h4><ul>
<li>堆heap：堆是存放对象的一个空间（Object，function）；</li>
<li>队列loop：是指存放所有异步请求操作的结果，直到有一个异步操作完成它的使命，<pre><code>就会在loop中添加一个事件，队列是先进先出的；</code></pre></li>
<li>栈stack：栈本身是存储基础的变量。<pre><code>栈里面的存放的引用变量是指向堆里面的引用对象的地址，只是一串地址。
这里栈代表的是执行栈，我们js的主线程。
栈是先进后出的。</code></pre></li>
</ul>
<h4 id="32-什么是事件循环eventloop"><a href="#32-什么是事件循环eventloop" class="headerlink" title="32. 什么是事件循环eventloop"></a>32. 什么是事件循环eventloop</h4><ul>
<li>所有同步任务都是在主线程上执行，形成一个执行栈；</li>
<li>当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；否则，则执行3</li>
<li>取出任务队列的首部，加入执行栈</li>
<li>执行任务</li>
<li>检查执行栈，如果执行栈为空，调回第2步；否则继续检查<br>node中的event loop是在libuv里面的，libuv里面有个事件环机制，他会在启动node时，初始化事件环。<br>Eventloop永远不会断。</li>
</ul>
<h4 id="33-微任务、宏任务"><a href="#33-微任务、宏任务" class="headerlink" title="33. 微任务、宏任务"></a>33. 微任务、宏任务</h4><p>宏任务macro-task：setTimeout、setImmediate、MessageChannnel<br>微任务micro-task：原生的Promise，Object.reserve(已废弃)、MutationObserve<br>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别是它们的执行顺序，Eventloop的走向和取值。</p>
<h4 id="34-哪些工具可以用来保证一致的编程风格？"><a href="#34-哪些工具可以用来保证一致的编程风格？" class="headerlink" title="34. 哪些工具可以用来保证一致的编程风格？"></a>34. 哪些工具可以用来保证一致的编程风格？</h4><ul>
<li>ESLint</li>
</ul>
<h4 id="35-运算错误与程序员错误的区别？"><a href="#35-运算错误与程序员错误的区别？" class="headerlink" title="35. 运算错误与程序员错误的区别？"></a>35. 运算错误与程序员错误的区别？</h4><p>运算错误并不是bug，这是和程序相关的问题，例如请求超时或硬件故障；<br>程序错误就是所谓的bug</p>
<h4 id="36-使用NPM有哪些好处？"><a href="#36-使用NPM有哪些好处？" class="headerlink" title="36. 使用NPM有哪些好处？"></a>36. 使用NPM有哪些好处？</h4><p>通过NPM，可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号，可以通过package.json文件来管理项目信息，配置脚本。</p>
<h4 id="37-什么是stub？举个使用场景？"><a href="#37-什么是stub？举个使用场景？" class="headerlink" title="37. 什么是stub？举个使用场景？"></a>37. 什么是stub？举个使用场景？</h4><p>Stub是用于模拟一个组件或模块的函数或程序。<br>在测试用例中，简单来说，你可以用Stub去模拟一个方法，从而避免调用真实的方法，使用Stub你可以返回虚构的结果。</p>
<h4 id="38-什么是测试金字塔？对于HTTP-API，如何利用测试金字塔？"><a href="#38-什么是测试金字塔？对于HTTP-API，如何利用测试金字塔？" class="headerlink" title="38. 什么是测试金字塔？对于HTTP API，如何利用测试金字塔？"></a>38. 什么是测试金字塔？对于HTTP API，如何利用测试金字塔？</h4><p>是当我们在编写测试用例时，底层的单元测试应该比上层的端到端的测试要多。</p>
<h4 id="39-module-exports与exports的区别？"><a href="#39-module-exports与exports的区别？" class="headerlink" title="39. module.exports与exports的区别？"></a>39. module.exports与exports的区别？</h4><p>exports是一个引用，直接赋值给它，只是让这个变量等于另外一个引用<br>只有通过module.exports才能真正修改到exports本身</p>
<h4 id="40-介绍一下Session和Cookie？服务端如何清除cookie？"><a href="#40-介绍一下Session和Cookie？服务端如何清除cookie？" class="headerlink" title="40. 介绍一下Session和Cookie？服务端如何清除cookie？"></a>40. 介绍一下Session和Cookie？服务端如何清除cookie？</h4><p>主要区别在于session存在服务端，cookie存在客户端，session比cookie更安全。<br>且cookie不一定能能一直用(可能被浏览器关掉)，<br>服务端可以通过设置cookie的值为空并设置一个及时的expires来清除存在客户端上的cookie。</p>
<ul>
<li><p>session：<br>  用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，成功后悔在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从数据库获取session数据，然后进行用户信息查询，查询到，将信息返回，从而保持状态。</p>
</li>
<li><p>session弊端<br>1、服务器压力增大</p>
<p>  通常session是存储在内存中的，当用户量增大时，服务器的压力增大。</p>
</li>
</ul>
<p>2、CSRF跨站伪造请求攻击<br>    session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<p>3、扩展性不强<br>    如果搭建多台服务器，session数据保存在内存中，不能共享，用户访问服务器1，当用户再次请求访问的可能是服务器2，服务器2获取不到session信息，就判断用户没有登录过。</p>
<ul>
<li>token<br>token与session不同在于认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返回客户端，服务器不进行保存。<br>浏览器接收到token的值存储在local storage中<br>再次访问服务器对token值进行解密，解密后进行数据查询，成功则通过认证，实现登录状态保持，即使有多台服务器，服务器也只是做了token的解密和数据的查询，不需要在服务端去保留用户的认证信息或会话信息，为扩展提供了便利，解决了session扩展性的弊端。</li>
</ul>
<h4 id="41-JS和NodeJs区别？"><a href="#41-JS和NodeJs区别？" class="headerlink" title="41. JS和NodeJs区别？"></a>41. JS和NodeJs区别？</h4><p>JS运行在浏览器端，用于用户的交互效果；<br>Nodejs运行在服务端，用于服务器的操作；</p>
<p>JS运行在浏览器端，存在多个JS解释器，存在兼容性的问题；<br>Nodejs只有V8引擎一种解释器，不存在兼容问题；</p>
<p>两者都有内置对象、自定义对象，有不同的宿主对象；</p>
<p>【<br>JavaScript内置对象：<br>    Array Boolean Date Function Global Math Number Object RegExp String及各种错误类对象。</p>
<p>JavaScript宿主对象：<br>    宿主对象就是执行Js脚本的环境提供的对象，对于嵌入到网页中的Js来说，宿主对象就是浏览器提供的对象，即浏览器对象。<br>如：Window和Document，Element，form，image等。</p>
<p>JavaScript自定义对象：即开发人员自己定义的对象。<br> 】</p>
<h4 id="42-如何判断当前脚本运行在浏览器还是在node环境中"><a href="#42-如何判断当前脚本运行在浏览器还是在node环境中" class="headerlink" title="42. 如何判断当前脚本运行在浏览器还是在node环境中"></a>42. 如何判断当前脚本运行在浏览器还是在node环境中</h4><p>通过判断Global对象是否为Window，如果不是，当前脚本没有在浏览器中。</p>
<h4 id="43-app-use和app-get的区别"><a href="#43-app-use和app-get的区别" class="headerlink" title="43. app.use和app.get的区别"></a>43. app.use和app.get的区别</h4><p>app.use(path, callback)中的callback既可以是router对象又可以是函数。<br>app.get(path, callback)中的callback只能是函数。</p>
<h4 id="44-node如何与MongoDB建立连接"><a href="#44-node如何与MongoDB建立连接" class="headerlink" title="44. node如何与MongoDB建立连接"></a>44. node如何与MongoDB建立连接</h4><ul>
<li>引入mongoose</li>
<li>使用mongoose.connect()方法连接到MongoDB数据库</li>
<li>监听连接是否成功</li>
<li>通过node， 书写接口，对数据库进行增删改查</li>
</ul>
<h4 id="45-pm2-forever-模块的工作原理"><a href="#45-pm2-forever-模块的工作原理" class="headerlink" title="45. pm2, forever 模块的工作原理"></a>45. pm2, forever 模块的工作原理</h4><p>forever：<br>    是一个简单的命令式nodejs的守护进程，能够启动，停止，重启App应用。<br>    forever完全基于命令行操作，在forever进程之下，创建node的子进程，通过monitor监控node子进程的运行情况，一旦文件更新，或者进程挂掉，forever会自动重启node服务器，确保应用正常运行。<br>    需要安装到全局环境下<code>npm install forever -g</code><br>forever管理多个站点，每个站访问量不大，不需要监控</p>
<p>pm2网站访问量比较大，需要完整的监控界面<br>pm2的特性</p>
<ul>
<li>内建负载均衡（Node cluster集群模块）</li>
<li>后台运行</li>
<li>0秒停机重载，维护升级时不需要停机</li>
<li>具有Ununtu和CentOS的启动脚本</li>
<li>停止不稳定的进程（避免无限循环）</li>
<li>控制台检测</li>
<li>提供Http API</li>
<li>远程控制和实时的接口API</li>
</ul>
<h4 id="46-import、require的模块系统加载方式是什么"><a href="#46-import、require的模块系统加载方式是什么" class="headerlink" title="46. import、require的模块系统加载方式是什么"></a>46. import、require的模块系统加载方式是什么</h4><p>require方法的加载规则：</p>
<ul>
<li>优先从缓存中加载</li>
<li>核心模块</li>
<li>路径形式的模块</li>
<li>第三方模块</li>
</ul>
<p>ES6标准发布后，module成为标准，标准的使用是以export指令导出接口，以import引入模块，<br>但我们一贯的node模块中，我们采用的是COmmonJS规范，使用requirejs引入模块，export.exports导出接口。</p>
<p>require时代的模块<br>node编程中最重要的就是模块，模块化编程在js界流行，require统治了ES6之前的所有模块化编程，<br>node的module遵循Commonjs规范，requirejs遵循AMD，</p>
<p>default关键字：<br>其实是别名的语法糖</p>
<figure class="highlight plain"><figcaption><span>default function()&#123;&#125;```</span></figcaption><table><tr><td class="code"><pre><span class="line">&#x3D;</span><br></pre></td></tr></table></figure>
<pre><code>function a(){};
export { a as default }</code></pre><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 47. Node.js 多进程部署的原理</span><br><span class="line">cluster模块用于实现和管理多进程的模块</span><br><span class="line"></span><br><span class="line">#### 48. 如何用Node监听80端口</span><br><span class="line">这题有陷阱！在类Unix系统中你不应该去监听80端口，因为这需要超级用户权限。因此不推荐让你的应用直接监听这个端口。</span><br><span class="line">目前，如果你一定要让你的应用80端口的话，你可以有通过在Node应用的前方再添加一层反向代理（例如nginx）来实现，如下图。否则，建议你直接监听大于1024的端口</span><br><span class="line">反向代理指的是以代理服务器来接收Internet上的连接请求，然后将请求转发给内部网络上的服务器， 并且将服务器返回的结果发送给客户端。</span><br><span class="line"></span><br><span class="line">#### 49. node和前端项目怎么解决跨域的？</span><br></pre></td></tr></table></figure>
<p>//解决跨域问题<br>        app.use(async(ctx, next) =#### {</p>
<pre><code>    //指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，必需指定具体的域，不能用通配符
    ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);

    //可选。它的值是一个布尔值，表示是否允许客户端跨域请求时携带身份信息(Cookie或者HTTP认证信息)。默认情况下，Cookie不包括在CORS请求之中。当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;如果没有设置这个值，浏览器会忽略此次响应。
    ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);

    //指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上
    ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);

    //必需。指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上
    ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;);
    // ctx.set(&quot;X-Powered-By&quot;, &apos; 3.2.1&apos;);

    //告诉客户端返回数据的MIME的类型，这只是一个标识信息,并不是真正的数据文件的一部分
    ctx.set(&quot;Content-Type&quot;, &quot;application/json;charset=utf-8&quot;);

    //如果不设置mode，直接设置content-type为application/json，则fetch会默认这是跨域模式（mode:&apos;cors&apos;），在跨域POST之前，客户端会先发一条OPTIONS请求来”探探路”，如果服务器允许，再继续POST数据。对于这种OPTIONS请求，需要在服务器配置允许接受OPTIONS请求，这样写就是直接允许了所有的OPTIONS请求，也可以按照需求来判断OPTIONS请求中更详细的信息
    if (ctx.request.method == &quot;OPTIONS&quot;) {
        ctx.response.status = 200
    }
    await next();
});</code></pre><p>复制代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 50. BDD 和 TDD的区别</span><br><span class="line">TDD：测试驱动开发Test-Driven Development</span><br><span class="line">    测试驱动开发是敏捷开发中的一项核心实践和技术</span><br><span class="line">    原理：在开发功能代码之前，先编写单元测试用例代码</span><br><span class="line"></span><br><span class="line">BDD：行为驱动开发Behavior Driven Development</span><br><span class="line">    是一种敏捷软件开发技术</span><br><span class="line">    主要是从用户的需求出发，强调系统行为\</span><br><span class="line"></span><br><span class="line">#### 控制流函数</span><br><span class="line">控制流函数是在几个异步函数调用之间运行的通用代码；</span><br><span class="line">执行以下工作：</span><br><span class="line">* 控制执行顺序</span><br><span class="line">* 收集数据</span><br><span class="line">* 限制并发</span><br><span class="line">* 调用程序中的下一步</span><br><span class="line"></span><br><span class="line">#### node如何实现多进程？</span><br><span class="line">进程：是计算机系统进行资源分配和调度的基本单位，即计算机每开启一个任务就会创建至少一个进程来处理，有时会创建多个，目的是为了防止一个进程挂掉而应用停止工作。</span><br><span class="line">线程：是程序执行流的最小单元。</span><br><span class="line">Nodejs默认是单进程、单线程的，这个进程称为主进程，可以通过child_process模块创建子进程实现多进程，称这些子进程为“工作进程”。并且归主进程管理，进程之间默认是不能通行的，且所有子进程执行任务都是异步的。</span><br><span class="line"></span><br><span class="line">* spawn实现多进程</span><br><span class="line">根据命令创建子进程，返回子进程对象，可以在子进程对象上注册事件，&#96;&#96;&#96;child_process.spawn(command[, args][, options])&#96;&#96;&#96;。</span><br><span class="line">nodejs中执行一个js文件，如果想在这个文件中再同时（异步）执行另一个js文件，可以使用child_process模块中的spawn来实现，spawn可以帮助我们创建一个子进程：</span><br></pre></td></tr></table></figure>
<p>// 文件：process.js<br>const { spawn } = require(“child_process”);<br>const path = require(“path”);</p>
<p>// 创建子进程<br>let child = spawn(“node”, [“sub_process.js”, “–port”, “3000”], {<br>  cwd: path.join(__dirname, “test”) // 指定子进程的当前工作目录<br>});</p>
<p>// 出现错误触发<br>child.on(“error”, err =&gt; console.log(err));</p>
<p>// 子进程退出触发<br>child.on(“exit”, () =&gt; console.log(“exit”));</p>
<p>// 子进程关闭触发<br>child.on(“close”, () =&gt; console.log(“close”));</p>
<p>// exit<br>// close</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spawn方法可以帮助我们创建一个子进程，这个子进程就是方法的返回值，spawn接收以下参数：</span><br><span class="line">* command：要运行的命令；</span><br><span class="line">* args：类型为数组，数组内第一项为文件名，后面项为执行文件的命令参数和值；</span><br><span class="line">* options：选项，类型为对象，用于指定子进程的当前工作目录和主进程、子进程的通信规则等；</span><br><span class="line"></span><br><span class="line">error事件在子进程出错时触发；</span><br><span class="line">exit事件在子进程退出时触发；</span><br><span class="line">close事件在子进程关闭后触发；</span><br><span class="line">在子进程任务结束后exit一定触发，close不一定触发；</span><br><span class="line"></span><br><span class="line">spawn定义输入输出</span><br></pre></td></tr></table></figure>
<p>// 文件：process.js<br>const { spawn } = require(“child_process”);<br>const path = require(“path”);</p>
<p>// 创建子进程<br>let child = spawn(“node”, [“sub_process.js”, “–port”, “3000”], {<br>  cwd: path.join(__dirname, “test”) // 指定子进程的当前工作目录<br>  // stdin: [process.stdin, process.stdout, process.stderr]<br>  stdio: [0, 1, 2] // 配置0标准输入、1标准输出、2错误输出<br>});<br>// C:\Program Files\nodejs\node.exe,g:\process\test\sub_process.js,–port,3000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// 文件：process.js<br>const { spawn } = require(“child_process”);<br>const path = require(“path”);</p>
<p>// 创建子进程<br>let child1 = spawn(“node”, [“sub_process_1.js”, “–port”, “3000”], {<br>  cwd: path.join(__dirname, “test”),<br>});</p>
<p>let child2 = spawn(“node”, [“sub_process_2.js”], {<br>  cwd: path.join(__dirname, “test”),<br>});</p>
<p>// 读取子进程 1 写入的内容，写入子进程 2<br>child1.stdout.on(“data”, data =&gt; child2.stdout.write(data.toString));</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">标准的进程通信：</span><br></pre></td></tr></table></figure>
<p>// 文件：process.js<br>const { spawn } = require(“spawn”);<br>const path = require(“path”);</p>
<p>// 创建子进程<br>let child = spawn(“node”, [“sub_process.js”], {<br>  cwd: path.join(__dirname, “test”),<br>  stdio: [0, “pipe”, “ignore”, “ipc”]<br>});</p>
<p>child.on(“message”, data =&gt; {<br>  console.log(data);</p>
<p>  // 回复消息给子进程<br>  child.send(“world”);</p>
<p>  // 杀死子进程，在主进程中操作<br>  // 由于一个主进程可能有多个子进程，所以指定要杀死的子进程需要传入子进程的 pid 属性作为 process.kill 的参数<br>  // process.kill(child.pid);<br>});</p>
<p>// hello</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;</span><br><span class="line">&#x2F;&#x2F; 文件：~test&#x2F;sub_process.js</span><br><span class="line">&#x2F;&#x2F; 给主进程发送消息</span><br><span class="line">process.send(&quot;hello&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 接收主进程回复的消息</span><br><span class="line">process.on(&quot;message&quot;, data &#x3D;&gt; &#123;</span><br><span class="line">  console.log(data);</span><br><span class="line"> </span><br><span class="line">  &#x2F;&#x2F; 退出子进程，在子进程中操作</span><br><span class="line">  process.exit();</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; world</span><br></pre></td></tr></table></figure>

<ul>
<li>fork实现多进程<br>fork是在spawn的基础上又做了一层封装<br>创建一个新的 Node.js 进程，并通过建立 IPC 通信通道来调用指定的模块，该通道允许在父进程与子进程之间发送消息。<br>当父进程调用child_process.fork()创建子进程的时候，先创建IPC管道并监听它，创建成功后再创建子进程，并把IPC管道的文件描述符通过环境变量传递给子进程，子进程启动后根据IPC管道的文件描述符去连接IPC通道，连接成功后，父子进程就能通过IPC管道通信了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件：process.js</span><br><span class="line">const fork &#x3D; require(&quot;child_process&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 创建子进程</span><br><span class="line">let child &#x3D; fork(&quot;sub_process.js&quot;, [&quot;--port&quot;, &quot;3000&quot;], &#123;</span><br><span class="line">  cwd: path.join(__dirname, &quot;test&quot;),</span><br><span class="line">  silent: true &#x2F;&#x2F; 代替了stdio，为true时，非标准通信的操作都不会生效，包括标准输入、输出和错误输出。</span><br><span class="line">  &#x2F;&#x2F; 当为false的时候可正常输出，返回值依然为一个子进程。</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">child.send(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件：~test&#x2F;sub_process.js</span><br><span class="line">&#x2F;&#x2F; 接收主进程发来的消息</span><br><span class="line">process.on(&quot;message&quot;, data &#x3D;&gt; console.log(data));</span><br></pre></td></tr></table></figure>

<ul>
<li>execFile和exec实现多进程<br>execFile是基于spawn封装的，可以直接创建子进程进行文件操作，不创建shell直接根据命令创建子进程，<code>child_process.execFile(file[, args][, options][, callback])</code>。<br>exec是基于execFile封装的，可以直接开启子进程执行命令，创建一个shell环境进程并在该shell中运行命令，UNIX上是 ‘/bin/sh’，windows上是’cmd.exe’，可通过options.shell指定程序，<code>child_process.exec(command[, options][, callback])</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; execFile 和 exec</span><br><span class="line">const &#123; execFile, exec &#125; &#x3D; require(&quot;child_process&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; execFile 第一个参数为文件的可执行路径或命令，第二个参数为命令的参数集合（数组），第三个参数为 options，最后一个参数为回调函数，回调函数的形参为错误、标准输出和错误输出</span><br><span class="line">let execFileChild &#x3D; execFile(&quot;node&quot;, [&quot;--version&quot;], (err, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) throw error;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">  console.log(stderr);</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line">let execChild &#x3D; exec(&quot;node --version&quot;, (err, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">  console.log(stderr);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>cluster集群<br>开启进程需要消耗内存，所以开启进程的数量要适合，合理运用多进程可以大大提高效率，用多个进程同时监听一个服务，一般开启进程的数量跟CPU核数相同为好，此时多个进程监听的服务会根据请求压力分流处理，也可以通过设置每个子进程处理请求的数量来实现“负载均衡”。</li>
</ul>
<ol>
<li><p>使用ipc（进程间通信Inter-Process Communication）实现集群<br>ipc标准进程通信使用send方法发送消息时第二个参数支持传入一个服务，必须是http服务或tcp服务，子进程通过message事件进行接收，回调的参数分别对应发送的参数，即第一个参数为消息，第二个参数为服务，我们就可以在子进程创建服务并对主进程的服务进行监听和操作，便实现了集群。<br>（send方法、有服务、接收message、创建服务、监听）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件：server.js</span><br><span class="line">const os &#x3D; require(&quot;os&quot;); &#x2F;&#x2F; os 模块用于获取系统信息</span><br><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const path &#x3D; require(&quot;path&quot;);</span><br><span class="line">const &#123; fork &#125; &#x3D; rquire(&quot;child_process&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 创建服务</span><br><span class="line">const server &#x3D; createServer((res, req) &#x3D;&gt; &#123;</span><br><span class="line">  res.end(&quot;hello&quot;);</span><br><span class="line">&#125;).listen(3000);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 根据 CPU 个数创建子进程</span><br><span class="line">os.cpus().forEach(() &#x3D;&gt; &#123;</span><br><span class="line">  fork(&quot;child_server.js&quot;, &#123;</span><br><span class="line">    cwd: path.join(__dirname);</span><br><span class="line">  &#125;).send(&quot;server&quot;, server);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件：child_server.js</span><br><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 接收来自主进程发来的服务</span><br><span class="line">process.on(&quot;message&quot;, (data, server) &#x3D;&gt; &#123;</span><br><span class="line">  http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.end(&#96;child$&#123;process.pid&#125;&#96;);</span><br><span class="line">  &#125;).listen(server); &#x2F;&#x2F; 子进程共用主进程的服务</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用cluster实现集群<br>cluster模块是Nodejs提供的用来实现集群的，它将child_process创建子进程的方法集成进去，实现方式要比使用ipc简洁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 文件：cluster.js</span><br><span class="line">const cluster &#x3D; require(&quot;cluster&quot;);</span><br><span class="line">const http &#x3D; require(&quot;http&quot;);</span><br><span class="line">const os &#x3D; require(&quot;os&quot;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 判断当前执行的进程是否为主进程，为主进程则创建子进程，否则用子进程监听服务</span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  &#x2F;&#x2F; 主进程通过cluster.fork来创建子进程</span><br><span class="line">  os.cpus().forEach(() &#x3D;&gt; cluster.fork());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 创建并监听服务</span><br><span class="line">  http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.end(&#96;child$&#123;process.pid&#125;&#96;);</span><br><span class="line">  &#125;).listen(3000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="为什么多进程监听同一个端口不报错？"><a href="#为什么多进程监听同一个端口不报错？" class="headerlink" title="为什么多进程监听同一个端口不报错？"></a>为什么多进程监听同一个端口不报错？</h4><p>在TCP端socket套接字监听端口有一个文件描述符，单独启动多个进程时文件描述符不同，导致监听相同端口会报错。<br>Nodejs底层对每个端口监听都设置了标识，在父进程和子进程传递server对象的过程中，将标识传给了对方，因此通过标识他们监听端口用的是同一个文件描述符。<br>在网络请求向服务器发送时，这些进程通过抢占为请求服务。</p>
<h4 id="多进程需要考虑的问题"><a href="#多进程需要考虑的问题" class="headerlink" title="多进程需要考虑的问题"></a>多进程需要考虑的问题</h4><ul>
<li>多进程开发<br>cluster模块让多进程的使用变得很容易</li>
<li>负载均衡<br>多个进程间需要有一个策略来保证资源的合理分配。Node默认机制是采用操作系统的抢占式策略，但也需要根据实际系统的资源使用情况来考虑。</li>
<li>进程管理<br>为了程序的健壮性以及充分利用CPU资源，我们引入多进程，那么多进程的管理也是一个问题，如：某个子进程异常退出需要自动创建一个新的子进程、让所有的子进程去抢占端口请求会造成性能浪费等。目前开源好用的进程管理工具有pm2。</li>
<li>状态共享<br>通常在多个应用间需要有一些共享数据，比如：Im系统中记录当前在线的用户。常见做法是通过第三方数据存储来实现，如redis。</li>
</ul>
<p>你最喜欢的HTTP框架，并说明原因？<br>babel或者coffee Script的这些编译到JS的语言是如何工作的？<br>关于babel的递归引用JS文件处理的东西<br>JavaScript的Async库基本原理是什么？<br>你写的Functional.js中monad, curry, lazy的解释和意义？<br>JS的东西，什么闭包，Node.js的require依赖顺序什么的<br>说一下关于Node.js的文件读写方式和实现<br>说一下JavaScript几种异步方法和原理？<br>说明addEventListener使用？作用域？<br>谈谈冒泡和捕获事件的区别，应用？</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>interview</title>
    <url>/articles/2020-02-08-interview.html</url>
    <content><![CDATA[<a id="more"></a>

<p>Node： <a href="https://www.gpp-note.top/articles/2020-02-08-interview-node.html" target="_blank">[Node]</a> </p>
<p>Vue：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-vue.html" target="_blank">[Vue]</a> </p>
<p>CSS：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-cssHtml.html" target="_blank">[Css]</a> </p>
<p>Html：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-cssHtml.html" target="_blank">[Html]</a> </p>
<p>Http/Net：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-httpNet.html" target="_blank">[Http/Net]</a> </p>
<p>ES6：<a href="https://www.gpp-note.top/articles/2020-02-12-interview-ES6.html" target="_blank">[ES6]</a> </p>
<p>JavaScript：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-javaScript.html" target="_blank">[JavaScript]</a> </p>
<p>Koa/Express：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-koaExpress.html" target="_blank">[Koa/Express]</a> </p>
<p>Database：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-database.html" target="_blank">[Database]</a> </p>
<p>DataStructure：<a href="https://www.gpp-note.top/articles/2020-02-11-interview-dataStructure.html" target="_blank">[DataStructure]</a> </p>
<p>Algorithm：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-algorithm.html" target="_blank">[Algorithm]</a> </p>
<p>Rabbitmq：<a href="https://www.gpp-note.top/articles/2020-02-16-interview-rabbitmq.html" target="_blank">[Rabbitmq]</a> </p>
<p>English：<a href="https://www.gpp-note.top/articles/2020-02-22-interview-english.html" target="_blank">[English]</a> </p>
<p>阿里一面：<br>    Redis、Mongodb、Mysql项目中的使用<br>    数据分析Echarts<br>    基本类型和引用类型<br>    CSS DOM<br>    http Url解析<br>    http状态码及区别<br>    koa与Express区别 好在哪里 解决了哪些问题<br>    项目中遇到的问题 如何解决的<br>    React和Vue有什么区别？<br>    基础类型和map的区别<br>    node进程 cluster child_process 多进程管理<br>    node性能优化？</p>
<p>建议：读源码 深入 github星 阿里开源</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之zlib</title>
    <url>/articles/2020-02-07-node-zlib.html</url>
    <content><![CDATA[<h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>压缩。<br>zlib模块提供通过Gzip</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之worker_threads</title>
    <url>/articles/2020-02-07-node-worker-threads.html</url>
    <content><![CDATA[<h2 id="worker-threads"><a href="#worker-threads" class="headerlink" title="worker_threads"></a>worker_threads</h2><p>工作线程。<br>worker_threads模块允许使用并行的执行JavaScript的线程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const worker &#x3D; require(&#39;worker_threads&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>工作线程对于执行CPU密集型的JavaScript操作非常有用。<br>它们在I/O密集型的工作中用途不大。<br>Nodejs的内置的异步I/O操作比工作线程效率更高。</p>
<p>与child_process或cluster不同，worker_threads可以共享内存，它们通过传输ArrayBuffer实例或共享SharedArrayBuffer实例来实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  Worker, isMainThread, parentPort, workerData</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  module.exports &#x3D; function parseJSAsync(script) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      const worker &#x3D; new Worker(__filename, &#123;</span><br><span class="line">        workerData: script</span><br><span class="line">      &#125;);</span><br><span class="line">      worker.on(&#39;message&#39;, resolve);</span><br><span class="line">      worker.on(&#39;error&#39;, reject);</span><br><span class="line">      worker.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">        if (code !&#x3D;&#x3D; 0)</span><br><span class="line">          reject(new Error(&#96;工作线程使用退出码 $&#123;code&#125; 停止&#96;));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const &#123; parse &#125; &#x3D; require(&#39;一些 js 解析库&#39;);</span><br><span class="line">  const script &#x3D; workerData;</span><br><span class="line">  parentPort.postMessage(parse(script));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的示例为每个parse()调用衍生一个工作进程。在实际的实践中，应使用工作线程池代替这些任务。<br>否则，创建工作线程的开销可能会超出其收益。</p>
<p>当实现工作线程池时，可使用AsyncResource API来通知诊断的工具有关任务极其结果之间的相关性。</p>
<h4 id="worker-isMainThread"><a href="#worker-isMainThread" class="headerlink" title="worker.isMainThread"></a>worker.isMainThread</h4><p>如果代码不在Worker线程内运行，则为True。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; Worker, isMainThread &#125; &#x3D; require(&#39;worker_threads)</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这会在工作线程实例中重新加载当前文件。</span><br><span class="line">    new Worker(__filename)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#39;在工作线程中&#39;)</span><br><span class="line">    console.log(isMainThread)  &#x2F;&#x2F; 打印false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="worker-moveMessagePortToContext-port-contextifiedSandbox"><a href="#worker-moveMessagePortToContext-port-contextifiedSandbox" class="headerlink" title="worker.moveMessagePortToContext(port, contextifiedSandbox)"></a>worker.moveMessagePortToContext(port, contextifiedSandbox)</h4><h4 id="worker-parentPort"><a href="#worker-parentPort" class="headerlink" title="worker.parentPort"></a>worker.parentPort</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  worker.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(message);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">  &#125;);</span><br><span class="line">  worker.postMessage(&#39;Hello, world!&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; When a message from the parent thread is received, send it back:</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    parentPort.postMessage(message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="worker-receiveMessageOnPort-port"><a href="#worker-receiveMessageOnPort-port" class="headerlink" title="worker.receiveMessageOnPort(port)"></a>worker.receiveMessageOnPort(port)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; MessageChannel, receiveMessageOnPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.postMessage(&#123; hello: &#39;world&#39; &#125;);</span><br><span class="line"></span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; message: &#123; hello: &#39;world&#39; &#125; &#125;</span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: undefined</span><br></pre></td></tr></table></figure>

<h4 id="worker-SHARE-ENV"><a href="#worker-SHARE-ENV" class="headerlink" title="worker.SHARE_ENV"></a>worker.SHARE_ENV</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; Worker, SHARE_ENV &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">new Worker(&#39;process.env.SET_IN_WORKER &#x3D; &quot;foo&quot;&#39;, &#123; eval: true, env: SHARE_ENV &#125;)</span><br><span class="line">  .on(&#39;exit&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(process.env.SET_IN_WORKER);  &#x2F;&#x2F; Prints &#39;foo&#39;.</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="worker-workerData"><a href="#worker-workerData" class="headerlink" title="worker.workerData"></a>worker.workerData</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, workerData &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename, &#123; workerData: &#39;Hello, world!&#39; &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(workerData);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="MessageChannel类"><a href="#MessageChannel类" class="headerlink" title="MessageChannel类"></a>MessageChannel类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(&#39;received&#39;, message));</span><br><span class="line">port2.postMessage(&#123; foo: &#39;bar&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; Prints: received &#123; foo: &#39;bar&#39; &#125; from the &#96;port1.on(&#39;message&#39;)&#96; listener</span><br></pre></td></tr></table></figure>

<h4 id="MessagePort类"><a href="#MessagePort类" class="headerlink" title="MessagePort类"></a>MessagePort类</h4><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F;   foobar</span><br><span class="line">&#x2F;&#x2F;   closed!</span><br><span class="line">port2.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line">port2.on(&#39;close&#39;, () &#x3D;&gt; console.log(&#39;closed!&#39;));</span><br><span class="line"></span><br><span class="line">port1.postMessage(&#39;foobar&#39;);</span><br><span class="line">port1.close();</span><br></pre></td></tr></table></figure>

<h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><h5 id="port-close"><a href="#port-close" class="headerlink" title="port.close()"></a>port.close()</h5><h5 id="port-postMessage-value-transferList"><a href="#port-postMessage-value-transferList" class="headerlink" title="port.postMessage(value[, transferList])"></a>port.postMessage(value[, transferList])</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line"></span><br><span class="line">const circularData &#x3D; &#123;&#125;;</span><br><span class="line">circularData.foo &#x3D; circularData;</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; foo: [Circular] &#125;</span><br><span class="line">port2.postMessage(circularData);</span><br></pre></td></tr></table></figure>

<h5 id="port-ref"><a href="#port-ref" class="headerlink" title="port.ref()"></a>port.ref()</h5><h5 id="port-start"><a href="#port-start" class="headerlink" title="port.start()"></a>port.start()</h5><h5 id="port-unref"><a href="#port-unref" class="headerlink" title="port.unref()"></a>port.unref()</h5><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker类代表一个独立的JavaScript执行线程。大多数Nodejs API都在其中可用。</p>
<p>可以在其它Worker实例中创建Worker实例。</p>
<p>与Web工作线程和cluster模块一样，可以通过线程间的消息传递来实现双向通信。<br>在内部，一个Worker具有一对内置的MessagePort，在创建该Worker时他们已经相互关联。<br>虽然父端的MessagePort对象没有直接公开，但其功能是通过父线程的Worker对象上的worker.postMessage()和worker.on(‘message’)事件公开的。</p>
<p>要创建自定义的消息传递通道，用户可以在任一线程上创建一个MessageChannel对象，并将该Messagechannel上的MessagePort中的一个通过预先存在的通道传给另一个线程，例如全局通道。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker, MessageChannel, MessagePort, isMainThread, parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  const subChannel &#x3D; new MessageChannel();</span><br><span class="line">  worker.postMessage(&#123; hereIsYourPort: subChannel.port1 &#125;, [subChannel.port1]);</span><br><span class="line">  subChannel.port2.on(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到:&#39;, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    assert(value.hereIsYourPort instanceof MessagePort);</span><br><span class="line">    value.hereIsYourPort.postMessage(&#39;工作线程正在发送此消息&#39;);</span><br><span class="line">    value.hereIsYourPort.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="new-Worker-filename-options"><a href="#new-Worker-filename-options" class="headerlink" title="new Worker(filename[, options])"></a>new Worker(filename[, options])</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><h5 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h5><h5 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h5><h5 id="worker-postMessage-value-transferList"><a href="#worker-postMessage-value-transferList" class="headerlink" title="worker.postMessage(value[, transferList])"></a>worker.postMessage(value[, transferList])</h5><h5 id="worker-ref"><a href="#worker-ref" class="headerlink" title="worker.ref()"></a>worker.ref()</h5><h5 id="worker-stderr"><a href="#worker-stderr" class="headerlink" title="worker.stderr"></a>worker.stderr</h5><h5 id="worker-stdin"><a href="#worker-stdin" class="headerlink" title="worker.stdin"></a>worker.stdin</h5><h5 id="worker-stdout"><a href="#worker-stdout" class="headerlink" title="worker.stdout"></a>worker.stdout</h5><h5 id="worker-terminate"><a href="#worker-terminate" class="headerlink" title="worker.terminate()"></a>worker.terminate()</h5><h5 id="worker-threadld"><a href="#worker-threadld" class="headerlink" title="worker.threadld"></a>worker.threadld</h5><h5 id="worker-unref"><a href="#worker-unref" class="headerlink" title="worker.unref()"></a>worker.unref()</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之vm</title>
    <url>/articles/2020-02-07-node-vm.html</url>
    <content><![CDATA[<h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>虚拟机。</p>
<p>vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。<br>vm模块不是一个安全的虚拟机。<br>不要用它来运行不受信任的代码。</p>
<p>JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。</p>
<p>一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。</p>
<p>可以通过上下文隔离化一个沙箱对象来提供上下文。<br>沙盒代码将沙盒中的任何属性视为全局对象。<br>由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; x: 2 &#125;;</span><br><span class="line">vm.createContext(sandbox); &#x2F;&#x2F; 上下文隔离化一个沙盒。</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#39;x +&#x3D; 40; var y &#x3D; 17;&#39;;</span><br><span class="line">&#x2F;&#x2F; &#96;x&#96; and &#96;y&#96; 是沙盒环境中的全局变量。</span><br><span class="line">&#x2F;&#x2F; 最初，x 的值为 2，因为这是 sandbox.x 的值。</span><br><span class="line">vm.runInContext(code, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(sandbox.x); &#x2F;&#x2F; 42</span><br><span class="line">console.log(sandbox.y); &#x2F;&#x2F; 17</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; 1; y 没有定义。</span><br></pre></td></tr></table></figure>

<h4 id="vm-Script类"><a href="#vm-Script类" class="headerlink" title="vm.Script类"></a>vm.Script类</h4><p>vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或上下文）中被运行。</p>
<h5 id="new-vm-Script-code-options"><a href="#new-vm-Script-code-options" class="headerlink" title="new vm.Script(code[, options])"></a>new vm.Script(code[, options])</h5><p>如果options是字符串，则它指定文件名。</p>
<p>创建一个新的vm.Script对象只编译code但不会执行它。<br>编译过的vm.Script此后可以被多次执行。<br>code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。</p>
<h5 id="script-createCachedData"><a href="#script-createCachedData" class="headerlink" title="script.createCachedData()"></a>script.createCachedData()</h5><p>创建一个可以被Script构造函数中cachedData选项使用的代码缓存，返回Buffer。<br>可以在任何时候不限次数的调用该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const script &#x3D; new vm.Script(&#96;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x &#x3D; add(1, 2);</span><br><span class="line">&#96;);</span><br><span class="line"></span><br><span class="line">const cacheWithoutX &#x3D; script.createCachedData();</span><br><span class="line"></span><br><span class="line">script.runInThisContext();</span><br><span class="line"></span><br><span class="line">const cacheWithX &#x3D; script.createCachedData();</span><br></pre></td></tr></table></figure>
<h5 id="script-runInContext-contextifiedSandbox-options"><a href="#script-runInContext-contextifiedSandbox-options" class="headerlink" title="script.runInContext(contextifiedSandbox[, options])"></a>script.runInContext(contextifiedSandbox[, options])</h5><p>在指定的contextifiedSandbox中执行vm.Script对象中被编译后的代码并返回结果。<br>被执行的代码无法获取本地作用域。</p>
<h5 id="script-runInNewContext-sandbox-options"><a href="#script-runInNewContext-sandbox-options" class="headerlink" title="script.runInNewContext([sandbox[, options]])"></a>script.runInNewContext([sandbox[, options]])</h5><p>首先给指定的sandbox提供一个隔离的上下文，再在此上下文执行vm.Script中被编译的代码，最后返回结果。运行中的代码无法获取本地作用域。</p>
<h5 id="script-runInThisContext-options"><a href="#script-runInThisContext-options" class="headerlink" title="script.runInThisContext([options])"></a>script.runInThisContext([options])</h5><p>在指定的global对象的上下文中执行vm.Script对象里被编译的代码并返回结果。被执行的代码无法获取本地作用域，但能获取global对象。</p>
<h4 id="vm-SourceTextModule类"><a href="#vm-SourceTextModule类" class="headerlink" title="vm.SourceTextModule类"></a>vm.SourceTextModule类</h4><h5 id="new-vm-SourceTextModule-code-options"><a href="#new-vm-SourceTextModule-code-options" class="headerlink" title="new vm.SourceTextModule(code[, options])"></a>new vm.SourceTextModule(code[, options])</h5><h5 id="module-dependencySpecifiers"><a href="#module-dependencySpecifiers" class="headerlink" title="module.dependencySpecifiers"></a>module.dependencySpecifiers</h5><h5 id="module-error"><a href="#module-error" class="headerlink" title="module.error"></a>module.error</h5><h5 id="module-evaluate-options"><a href="#module-evaluate-options" class="headerlink" title="module.evaluate([options])"></a>module.evaluate([options])</h5><h5 id="module-link-linker"><a href="#module-link-linker" class="headerlink" title="module.link(linker)"></a>module.link(linker)</h5><h5 id="module-namespace"><a href="#module-namespace" class="headerlink" title="module.namespace"></a>module.namespace</h5><h5 id="module-status"><a href="#module-status" class="headerlink" title="module.status"></a>module.status</h5><h5 id="module-identifier"><a href="#module-identifier" class="headerlink" title="module.identifier"></a>module.identifier</h5><h4 id="vm-compileFunction-code-params-options"><a href="#vm-compileFunction-code-params-options" class="headerlink" title="vm.compileFunction(code[, params[, options]])"></a>vm.compileFunction(code[, params[, options]])</h4><p>将给定的代码编译到提供的上下文/沙箱中（如果没有提供上下文，则使用当前上下文），并返回包装了给定params的函数。</p>
<h4 id="vm-createContext-sandbox-options"><a href="#vm-createContext-sandbox-options" class="headerlink" title="vm.createContext([sandbox[, options]])"></a>vm.createContext([sandbox[, options]])</h4><p>给定一个sandbox对象，vm.createContext()会设置此沙盒，从而让它具备在vm.runInContext()或者script.runInContext()中被使用的能力。对于此二方法中所调用的脚本，他们的全局对象不仅拥有我们提供的sandbox对象的所有属性，同时还有任何全局对象所拥有的属性。对于这些脚本之外的所有代码，他们的全局变量将保持不变。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">global.globalVar &#x3D; 3;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(sandbox)); &#x2F;&#x2F; &#123; globalVar: 2 &#125;</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(globalVar)); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<p>如果未提供sanbox或传入undefined，那么会返回一个全新的空的上下文隔离化后的sandbox对象。</p>
<p>vm.createContext()主要是用于创建一个能运行的多个脚本的沙盒。</p>
<h4 id="vm-isContext-sandbox"><a href="#vm-isContext-sandbox" class="headerlink" title="vm.isContext(sandbox)"></a>vm.isContext(sandbox)</h4><p>当给定的sanbox对象已经被vm.createContext()上下文隔离化，则返回true。</p>
<h4 id="vm-runInContext-code-contextifiedSandbox-options"><a href="#vm-runInContext-code-contextifiedSandbox-options" class="headerlink" title="vm.runInContext(code, contextifiedSandbox[, options])"></a>vm.runInContext(code, contextifiedSandbox[, options])</h4><p>vm.runInContext()方法会编译code，然后在指定的contextifiedSandbox的上下文里执行它并返回其结果。被执行的代码无法获取本地作用域。contextifiedSandbox必须是事先被vm.createContext()方法上下文隔离化过得对象。</p>
<p>如果options是字符串，则它指定文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line">&#125;</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; globalVar: 1024 &#125;</span><br></pre></td></tr></table></figure>

<h4 id="vm-runInNewContext-code-sanbox-options"><a href="#vm-runInNewContext-code-sanbox-options" class="headerlink" title="vm.runInNewContext(code[, sanbox[, options]])"></a>vm.runInNewContext(code[, sanbox[, options]])</h4><p>vm.runInNewContext()首先给指定的sanbox（若为undefined，则会新建一个sandbox）提供一个隔离的上下文，再在此上下文中执行编译的code，最后返回结果。<br>运行中的代码无法获取本地作用域。</p>
<p>如果options是字符串，则它指定文件名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123;</span><br><span class="line">  animal: &#39;cat&#39;,</span><br><span class="line">  count: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.runInNewContext(&#39;count +&#x3D; 1; name &#x3D; &quot;kitty&quot;&#39;, sandbox);</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="vm-runInThisContext-code-options"><a href="#vm-runInThisContext-code-options" class="headerlink" title="vm.runInThisContext(code[, options])"></a>vm.runInThisContext(code[, options])</h4><p>vm.runInThisContext()在当前的global对象的上下文中编译并执行code，最后返回结果。<br>运行中的代码无法获取本地作用域，但可以获取当前的global对象。</p>
<p>如果options是字符串，则它指定文件名。</p>
<h4 id="示例：在VM中运行HTTP-Server"><a href="#示例：在VM中运行HTTP-Server" class="headerlink" title="示例：在VM中运行HTTP Server"></a>示例：在VM中运行HTTP Server</h4><p>在私用script.runInThisContext()或者vm.runInThisContext()时，目标代码是在当前的V8quanju对象的上下文中执行的。被传入此虚拟机上下文的目标代码会有自己独立的作用域。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#96;</span><br><span class="line">((require) &#x3D;&gt; &#123;</span><br><span class="line">  const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">  http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">    response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; &#125;);</span><br><span class="line">    response.end(&#39;你好世界\\n&#39;);</span><br><span class="line">  &#125;).listen(8124);</span><br><span class="line"></span><br><span class="line">  console.log(&#39;服务器运行在 http:&#x2F;&#x2F;127.0.0.1:8124&#x2F;&#39;);</span><br><span class="line">&#125;)&#96;;</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(code)(require);</span><br></pre></td></tr></table></figure>

<h4 id="上下文隔离化一个对象意味着什么？"><a href="#上下文隔离化一个对象意味着什么？" class="headerlink" title="上下文隔离化一个对象意味着什么？"></a>上下文隔离化一个对象意味着什么？</h4><p>所有用Nodejs所运行的JavaScript代码都是在一个上下文的作用域中被执行的。根据V8嵌入式指南：</p>
<blockquote>
<p>在V8中，一个上下文是一个执行环境，它允许分离的，无关的JavaScript应用在一个V8的单例中被运行。<br>必须明确的指定用于运行所有JavaScript代码的上下文。</p>
</blockquote>
<p>当调用vm.createContext()时，传入的sanbox对象在底层会和一个新的V8上下文实例联系上。<br>这个V8上下文在一个隔离的全局环境中，使用vm模块的方法运行code。<br>创建V8上下文和使之联系上sanbox的过程在此文档中被称作为“上下文隔离化”sandbox。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之V8</title>
    <url>/articles/2020-02-07-node-V8.html</url>
    <content><![CDATA[<h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>V8引擎。</p>
<p>v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const v8 &#x3D; require(&#39;v8&#39;)</span><br></pre></td></tr></table></figure>
<p>API和实现随时可能发生变化。</p>
<a id="more"></a>

<h4 id="v8-cachedDataVersionTag"><a href="#v8-cachedDataVersionTag" class="headerlink" title="v8.cachedDataVersionTag()"></a>v8.cachedDataVersionTag()</h4><p>返回一个整数，表示从V8版本、命令行标志、以及检测到的CPU特性派生的版本标记。<br>这对于判断vm.Script的cachedData buffer是否与此V8实例兼容非常有用。</p>
<h4 id="v8-getHeapSpaceStatistics"><a href="#v8-getHeapSpaceStatistics" class="headerlink" title="v8.getHeapSpaceStatistics()"></a>v8.getHeapSpaceStatistics()</h4><p>返回有关的V8堆空间的统计信息，即组成V8堆的片段。<br>由于统计信息是通过V8的GetHeapSpaceStatistics函数提供的，因此可以保证堆空间的排序以及堆控件的可用性，并且可以从一个V8版本更改为下一个版本。</p>
<h4 id="v8-getHeapSnapshot"><a href="#v8-getHeapSnapshot" class="headerlink" title="v8.getHeapSnapshot()"></a>v8.getHeapSnapshot()</h4><p>生成当前V8堆的快照，并返回可读流，该可读流用于读取JSON序列化表示。<br>此JSON流格式旨在与Chrome DevTools等工具一起使用。<br>JSON模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const stream &#x3D; v8.getHeapSnapshot();</span><br><span class="line">stream.pipe(process.stdout);</span><br></pre></td></tr></table></figure>

<h4 id="v8-getHeapStatistics"><a href="#v8-getHeapStatistics" class="headerlink" title="v8.getHeapStatistics()"></a>v8.getHeapStatistics()</h4><h4 id="v8-getHeapCodeStatistics"><a href="#v8-getHeapCodeStatistics" class="headerlink" title="v8.getHeapCodeStatistics()"></a>v8.getHeapCodeStatistics()</h4><p>返回一下属性的对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code_and_metadata_size: 212208,</span><br><span class="line">  bytecode_and_metadata_size: 161368,</span><br><span class="line">  external_script_source_size: 1410794</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="v8-setFlagsFromString-flags"><a href="#v8-setFlagsFromString-flags" class="headerlink" title="v8.setFlagsFromString(flags)"></a>v8.setFlagsFromString(flags)</h4><p>该方法可以用于以编程方式设置V8de命令行标志。<br>虚拟机启动后更改设置可能会导致不可预测的行为，包括崩溃和数据丢失，或者它可能根本就什么都不做。</p>
<p>可以通过运行node –v8-options来检查可用于nodejs版本的V8选项。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 GC 事件打印到 stdout 一分钟。</span><br><span class="line">const v8 &#x3D; require(&#39;v8&#39;);</span><br><span class="line">v8.setFlagsFromString(&#39;--trace_gc&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; v8.setFlagsFromString(&#39;--notrace_gc&#39;); &#125;, 60e3);</span><br></pre></td></tr></table></figure>

<h4 id="v8-writeHeapSnapshot-filename"><a href="#v8-writeHeapSnapshot-filename" class="headerlink" title="v8.writeHeapSnapshot([filename])"></a>v8.writeHeapSnapshot([filename])</h4><p>生成当前v8堆的快照并将其写入Json文件。<br>此文件旨在与Chrome DevTools等工具一起使用。<br>Json模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p>
<p>堆快照特定于单个V8隔离。<br>使用工作线程时，从主线程生成的堆快照将不包含有关工作线程的任何信息，反之亦然。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; writeHeapSnapshot &#125; &#x3D; require(&#39;v8&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker,</span><br><span class="line">  isMainThread,</span><br><span class="line">  parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line"></span><br><span class="line">  worker.once(&#39;message&#39;, (filename) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作线程的堆转储: $&#123;filename&#125;&#96;);</span><br><span class="line">    &#x2F;&#x2F; 获取主线程的堆转储。</span><br><span class="line">    console.log(&#96;主线程的堆转储: $&#123;writeHeapSnapshot()&#125;&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知工作线程创建一个堆转储。</span><br><span class="line">  worker.postMessage(&#39;heapdump&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    if (message &#x3D;&#x3D;&#x3D; &#39;heapdump&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 为工作线程生成一个堆转储，并返回文件名到父线程。</span><br><span class="line">      parentPort.postMessage(writeHeapSnapshot());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="序列化的API"><a href="#序列化的API" class="headerlink" title="序列化的API"></a>序列化的API</h4><h5 id="v8-serialize-value"><a href="#v8-serialize-value" class="headerlink" title="v8.serialize(value)"></a>v8.serialize(value)</h5><h5 id="v8-deserialize-buffer"><a href="#v8-deserialize-buffer" class="headerlink" title="v8.deserialize(buffer)"></a>v8.deserialize(buffer)</h5><h5 id="v8-Serializer类"><a href="#v8-Serializer类" class="headerlink" title="v8.Serializer类"></a>v8.Serializer类</h5><h6 id="new-Serializer"><a href="#new-Serializer" class="headerlink" title="new Serializer()"></a>new Serializer()</h6><h6 id="serializer-writeHeader"><a href="#serializer-writeHeader" class="headerlink" title="serializer.writeHeader()"></a>serializer.writeHeader()</h6><h6 id="serializer-releaseBuffer"><a href="#serializer-releaseBuffer" class="headerlink" title="serializer.releaseBuffer()"></a>serializer.releaseBuffer()</h6><h6 id="serializer-transferArrayBuffer-id-arrayBuffer"><a href="#serializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="serializer.transferArrayBuffer(id, arrayBuffer)"></a>serializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="serializer-writeUint32-value"><a href="#serializer-writeUint32-value" class="headerlink" title="serializer.writeUint32(value)"></a>serializer.writeUint32(value)</h6><h6 id="serializer-writeUint64-hi-Io"><a href="#serializer-writeUint64-hi-Io" class="headerlink" title="serializer.writeUint64(hi, Io)"></a>serializer.writeUint64(hi, Io)</h6><h6 id="serializer-writeDouble-value"><a href="#serializer-writeDouble-value" class="headerlink" title="serializer.writeDouble(value)"></a>serializer.writeDouble(value)</h6><h6 id="serializer-writeRawBytes-buffer"><a href="#serializer-writeRawBytes-buffer" class="headerlink" title="serializer.writeRawBytes(buffer)"></a>serializer.writeRawBytes(buffer)</h6><h6 id="serializer-writeHostObject-object"><a href="#serializer-writeHostObject-object" class="headerlink" title="serializer._writeHostObject(object)"></a>serializer._writeHostObject(object)</h6><h6 id="serializer-getDataCloneError-message"><a href="#serializer-getDataCloneError-message" class="headerlink" title="serializer._getDataCloneError(message)"></a>serializer._getDataCloneError(message)</h6><h6 id="serializer-getSharedArrayBufferId-sharedArrayBuffer"><a href="#serializer-getSharedArrayBufferId-sharedArrayBuffer" class="headerlink" title="serializer._getSharedArrayBufferId(sharedArrayBuffer)"></a>serializer._getSharedArrayBufferId(sharedArrayBuffer)</h6><h6 id="serializer-setTreatArrayBufferViewsAsHostObjects-flag"><a href="#serializer-setTreatArrayBufferViewsAsHostObjects-flag" class="headerlink" title="serializer._setTreatArrayBufferViewsAsHostObjects(flag)"></a>serializer._setTreatArrayBufferViewsAsHostObjects(flag)</h6><h5 id="v8-Deserializer类"><a href="#v8-Deserializer类" class="headerlink" title="v8.Deserializer类"></a>v8.Deserializer类</h5><h6 id="new-Deserializer-buffer"><a href="#new-Deserializer-buffer" class="headerlink" title="new Deserializer(buffer)"></a>new Deserializer(buffer)</h6><h6 id="deserializer-readHeader"><a href="#deserializer-readHeader" class="headerlink" title="deserializer.readHeader()"></a>deserializer.readHeader()</h6><h6 id="deserializer-readValue"><a href="#deserializer-readValue" class="headerlink" title="deserializer.readValue()"></a>deserializer.readValue()</h6><h6 id="deserializer-transferArrayBuffer-id-arrayBuffer"><a href="#deserializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="deserializer.transferArrayBuffer(id, arrayBuffer)"></a>deserializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="deserializer-getWriteFormatVersion"><a href="#deserializer-getWriteFormatVersion" class="headerlink" title="deserializer.getWriteFormatVersion()"></a>deserializer.getWriteFormatVersion()</h6><h6 id="deserializer-readUint32"><a href="#deserializer-readUint32" class="headerlink" title="deserializer.readUint32()"></a>deserializer.readUint32()</h6><h6 id="deserializer-readUint64"><a href="#deserializer-readUint64" class="headerlink" title="deserializer.readUint64()"></a>deserializer.readUint64()</h6><h6 id="deserializer-readDouble"><a href="#deserializer-readDouble" class="headerlink" title="deserializer.readDouble()"></a>deserializer.readDouble()</h6><h6 id="deserializer-readRawBytes-length"><a href="#deserializer-readRawBytes-length" class="headerlink" title="deserializer.readRawBytes(length)"></a>deserializer.readRawBytes(length)</h6><h6 id="deserializer-readHostObject"><a href="#deserializer-readHostObject" class="headerlink" title="deserializer._readHostObject()"></a>deserializer._readHostObject()</h6><h5 id="v8-DefaultSerializer类"><a href="#v8-DefaultSerializer类" class="headerlink" title="v8.DefaultSerializer类"></a>v8.DefaultSerializer类</h5><h5 id="v8-DefaultDeserializer类"><a href="#v8-DefaultDeserializer类" class="headerlink" title="v8.DefaultDeserializer类"></a>v8.DefaultDeserializer类</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之util</title>
    <url>/articles/2020-02-07-node-util.html</url>
    <content><![CDATA[<h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><p>实用工具。<br>util模块主要用于支持nodejs内部API的需求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="util-callbackify-original"><a href="#util-callbackify-original" class="headerlink" title="util.callbackify(original)"></a>util.callbackify(original)</h4><p>将async异步函数转换成遵循异常有限的回调风格的函数<br>在回调函数中，第一个参数为拒绝的原因，第二个参数则是解决的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">async function fn() &#123;</span><br><span class="line">  return &#39;hello world&#39;;</span><br><span class="line">&#125;</span><br><span class="line">const callbackFunction &#x3D; util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction((err, ret) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(ret);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hello world</span><br></pre></td></tr></table></figure>

<p>回调函数是异步执行的，并且有异常堆栈错误跟踪。如果回调函数抛出一个异常，进程会触发一个‘uncaughtException’异常，如果没有被捕获，进程将会退出。</p>
<p>null在回调函数中作为一个参数有其特殊意义，如果回调函数的收哥参数为Promise拒绝的原因且带有返回值，且值可以转换成布尔值false，这个值会被封装在Error对象里，可以通过属性reason获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  return Promise.reject(null);</span><br><span class="line">&#125;</span><br><span class="line">const callbackFunction &#x3D; util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction((err, ret) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 当 Promise 被以 &#96;null&#96; 拒绝时，它被包装为 Error 并且原始值存储在 &#96;reason&#96; 中。</span><br><span class="line">  err &amp;&amp; err.hasOwnProperty(&#39;reason&#39;) &amp;&amp; err.reason &#x3D;&#x3D;&#x3D; null;  &#x2F;&#x2F; true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="util-debuglog-section"><a href="#util-debuglog-section" class="headerlink" title="util.debuglog(section)"></a>util.debuglog(section)</h4><p>用于创建一个函数，基于NODE_DEBUG环境变量的存在与否有条件的写入调试信息到stderr。<br>如果section名称在环境变量的值中，则返回的函数类似于console.error()，否则返回的函数是一个空操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const debuglog &#x3D; util.debuglog(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">debuglog(&#39;hello from foo [%d]&#39;, 123);</span><br></pre></td></tr></table></figure>
<p>如果程序在环境中运行时带上NODE_DEBUG=foo，则输出类似如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOO 3245: hello from foo [123]</span><br></pre></td></tr></table></figure>
<p>3245是进程id，如果运行时没带上环境变量集合，则不会打印任何东西。</p>
<p>section还支持通配符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const debuglog &#x3D; util.debuglog(&#39;foo-bar&#39;);</span><br><span class="line"></span><br><span class="line">debuglog(&#39;hi there, it\&#39;s foo-bar [%d]&#39;, 2333);</span><br></pre></td></tr></table></figure>
<p>如果在环境中使用 NODE_DEBUG=foo* 运行，那么它将输出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FOO-BAR 3257: hi there, it&#39;s foo-bar [2333]</span><br></pre></td></tr></table></figure>
<p>NODE_DEBUG 环境变量中可指定多个由逗号分隔的 section 名称。 例如：NODE_DEBUG=fs,net,tls。</p>
<h4 id="util-deprecate-fn-msg-code"><a href="#util-deprecate-fn-msg-code" class="headerlink" title="util.deprecate(fn, msg[, code])"></a>util.deprecate(fn, msg[, code])</h4><p>以一种标记为已废弃的方式包装fn。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">exports.obsoleteFunction &#x3D; util.deprecate(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 一些操作。</span><br><span class="line">&#125;, &#39;obsoleteFunction() 已废弃，使用 newShinyFunction() 代替&#39;);</span><br></pre></td></tr></table></figure>

<p>当被调用时，会返回一个函数，这个函数会使用‘warning’事件触发一个DeprecationWaring。默认情况下，警告只在首次被调用时才会被触发并打印到stderr。警告被触发时，被包装的函数会被调用。</p>
<p>如果在对util.deprecate()的多次调用中提供了相同的可选code，该code仅触发一次警告。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">const fn1 &#x3D; util.deprecate(someFunction, someMessage, &#39;DEP0001&#39;);</span><br><span class="line">const fn2 &#x3D; util.deprecate(someOtherFunction, someOtherMessage, &#39;DEP0001&#39;);</span><br><span class="line">fn1(); &#x2F;&#x2F; 使用代码 DEP0001 触发废弃警告。</span><br><span class="line">fn2(); &#x2F;&#x2F; 不会触发废弃警告，因为它具有相同的代码。</span><br></pre></td></tr></table></figure>

<p>如果使用了 –no-deprecation 或 –no-warnings 命令行标记，或 process.noDeprecation 属性在首次废弃警告之前被设为 true，则 util.deprecate() 方法什么也不做。</p>
<p>如果设置了 –trace-deprecation 或 –trace-warnings 命令行标记，或 process.traceDeprecation 属性被设为 true，则废弃的函数首次被调用时会把警告与堆栈追踪打印到 stderr。</p>
<p>如果设置了 –throw-deprecation 命令行标记，或 process.throwDeprecation 属性被设为 true，则当废弃的函数被调用时会抛出一个异常。</p>
<p>–throw-deprecation 命令行标记和 process.throwDeprecation 属性优先于 –trace-deprecation 和 process.traceDeprecation。</p>
<h4 id="util-format-format-…args"><a href="#util-format-format-…args" class="headerlink" title="util.format(format[, …args])"></a>util.format(format[, …args])</h4><p>如果占位符没有对应的参数，则占位符不被替换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util.format(&#39;%s:%s&#39;, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;foo:%s&#39;</span><br></pre></td></tr></table></figure>

<p>如果类型不是string，则使用util.inspect()格式化不属于格式字符串的值。</p>
<p>如果传入util.format()方法的参数比占位符的数量多，则多出的参数会被强制转换为字符串，然后拼接到返回的字符串，参数之间用一个空格分隔。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;foo:bar baz&#39;</span><br></pre></td></tr></table></figure>

<p>如果第一个参数不是一个字符串，则 util.format() 返回一个所有参数用空格分隔并连在一起的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util.format(1, 2, 3);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;1 2 3&#39;</span><br></pre></td></tr></table></figure>

<p>如果只有一个参数传给 util.format()，它将按原样返回，不带任何格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util.format(&#39;%% %s&#39;);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;%% %s&#39;</span><br></pre></td></tr></table></figure>
<p>util.format() 是一种用作调试工具的同步方法。 某些输入值可能会产生严重的性能开销，从而阻止事件循环。 请谨慎使用此功能，切勿在热代码路径中使用。</p>
<h4 id="util-formatWithOptions-inspectOptions-format-…args"><a href="#util-formatWithOptions-inspectOptions-format-…args" class="headerlink" title="util.formatWithOptions(inspectOptions, format[, …args])"></a>util.formatWithOptions(inspectOptions, format[, …args])</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">util.formatWithOptions(&#123; colors: true &#125;, &#39;See object %O&#39;, &#123; foo: 42 &#125;);</span><br><span class="line">&#x2F;&#x2F; Returns &#39;See object &#123; foo: 42 &#125;&#39;, where &#96;42&#96; is colored as a number</span><br><span class="line">&#x2F;&#x2F; when printed to a terminal.</span><br></pre></td></tr></table></figure>

<h4 id="util-getSystemErrorName-err"><a href="#util-getSystemErrorName-err" class="headerlink" title="util.getSystemErrorName(err)"></a>util.getSystemErrorName(err)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.access(&#39;file&#x2F;that&#x2F;does&#x2F;not&#x2F;exist&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  const name &#x3D; util.getSystemErrorName(err.errno);</span><br><span class="line">  console.error(name);  &#x2F;&#x2F; ENOENT</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="util-inherits-constructor-superConstructor"><a href="#util-inherits-constructor-superConstructor" class="headerlink" title="util.inherits(constructor, superConstructor)"></a>util.inherits(constructor, superConstructor)</h4><p>不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。 这两种方式是语义上不兼容的。</p>
<p>从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。</p>
<p>这主要在 Object.setPrototypeOf(constructor.prototype, superConstructor.prototype) 之上添加了一些输入验证。 作为额外的便利，可以通过 constructor.super_属性访问 superConstructor。</p>
<h4 id="util-inspect-object-options"><a href="#util-inspect-object-options" class="headerlink" title="util.inspect(object[, options])"></a>util.inspect(object[, options])</h4><h4 id="util-inspect-object-showHidden-depth-colors"><a href="#util-inspect-object-showHidden-depth-colors" class="headerlink" title="util.inspect(object[, showHidden[, depth[, colors]]])"></a>util.inspect(object[, showHidden[, depth[, colors]]])</h4><h4 id="自定义util-inspect的颜色"><a href="#自定义util-inspect的颜色" class="headerlink" title="自定义util.inspect的颜色"></a>自定义util.inspect的颜色</h4><p>可以通过util.inspect.styles和util.inspect.colors属性全局的自定义util.inspect的颜色输出。</p>
<p>util.inspect.styles是一个映射，关联一个样式名到一个util.inspect.colors颜色。</p>
<h4 id="util-inspect-custom"><a href="#util-inspect-custom" class="headerlink" title="util.inspect.custom"></a>util.inspect.custom</h4><h4 id="util-inspect-defaultOPTIONS"><a href="#util-inspect-defaultOPTIONS" class="headerlink" title="util.inspect.defaultOPTIONS"></a>util.inspect.defaultOPTIONS</h4><p>defaultOptions值允许对被util.inspect使用的默认选项进行自定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const arr &#x3D; Array(101).fill(0);</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; 打印截断的数组</span><br><span class="line">util.inspect.defaultOptions.maxArrayLength &#x3D; null;</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 打印完整的数组</span><br></pre></td></tr></table></figure>

<h4 id="util-isDeepStrictEqual-val1-val2"><a href="#util-isDeepStrictEqual-val1-val2" class="headerlink" title="util.isDeepStrictEqual(val1, val2)"></a>util.isDeepStrictEqual(val1, val2)</h4><h4 id="util-promisify-original"><a href="#util-promisify-original" class="headerlink" title="util.promisify(original)"></a>util.promisify(original)</h4><p>传入一个遵循常见的错误优先的回调风格的函数，并返回一个promise的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">const stat &#x3D; util.promisify(fs.stat);</span><br><span class="line">stat(&#39;.&#39;).then((stats) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用 &#96;stats&#96;。</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或等效的使用async fnuction</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">const stat &#x3D; util.promisify(fs.stat);</span><br><span class="line"></span><br><span class="line">async function callStat() &#123;</span><br><span class="line">  const stats &#x3D; await stat(&#39;.&#39;);</span><br><span class="line">  console.log(&#96;该目录归 $&#123;stats.uid&#125; 拥有&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果存在 original[util.promisify.custom] 属性，则 promisify 将会返回其值，参阅自定义的 promise 化函数。</p>
<p>promisify() 在所有情况下都会假定 original 是一个以回调作为其最后参数的函数。 如果 original 不是一个函数，则 promisify() 将会抛出错误。 如果 original 是一个函数但其最后一个参数不是一个错误优先的回调，则它将仍会传入一个错误优先的回调作为其最后一个参数。</p>
<p>除非特殊处理，否则在类方法或使用 this 的其他方法上使用 promisify() 可能无法正常工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.a &#x3D; 42;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar(callback) &#123;</span><br><span class="line">    callback(null, this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const foo &#x3D; new Foo();</span><br><span class="line"></span><br><span class="line">const naiveBar &#x3D; util.promisify(foo.bar);</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot read property &#39;a&#39; of undefined</span><br><span class="line">&#x2F;&#x2F; naiveBar().then(a &#x3D;&gt; console.log(a));</span><br><span class="line"></span><br><span class="line">naiveBar.call(foo).then((a) &#x3D;&gt; console.log(a)); &#x2F;&#x2F; &#39;42&#39;</span><br><span class="line"></span><br><span class="line">const bindBar &#x3D; naiveBar.bind(foo);</span><br><span class="line">bindBar().then((a) &#x3D;&gt; console.log(a)); &#x2F;&#x2F; &#39;42&#39;</span><br></pre></td></tr></table></figure>

<h4 id="自定义的Promise化函数"><a href="#自定义的Promise化函数" class="headerlink" title="自定义的Promise化函数"></a>自定义的Promise化函数</h4><p>使用util.promisify.custorm符号可以重写util.promisify()的返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">function doSomething(foo, callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething[util.promisify.custom] &#x3D; (foo) &#x3D;&gt; &#123;</span><br><span class="line">  return getPromiseSomehow();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const promisified &#x3D; util.promisify(doSomething);</span><br><span class="line">console.log(promisified &#x3D;&#x3D;&#x3D; doSomething[util.promisify.custom]);</span><br><span class="line">&#x2F;&#x2F; 打印 &#39;true&#39;</span><br></pre></td></tr></table></figure>

<h4 id="util-promisify-custom"><a href="#util-promisify-custom" class="headerlink" title="util.promisify.custom"></a>util.promisify.custom</h4><h4 id="util-TextDecoder类"><a href="#util-TextDecoder类" class="headerlink" title="util.TextDecoder类"></a>util.TextDecoder类</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const decoder &#x3D; new TextDecoder(&#39;shift_jis&#39;);</span><br><span class="line">let string &#x3D; &#39;&#39;;</span><br><span class="line">let buffer;</span><br><span class="line">while (buffer &#x3D; getNextChunkSomehow()) &#123;</span><br><span class="line">  string +&#x3D; decoder.decode(buffer, &#123; stream: true &#125;);</span><br><span class="line">&#125;</span><br><span class="line">string +&#x3D; decoder.decode(); &#x2F;&#x2F; 流的末尾。</span><br></pre></td></tr></table></figure>

<h5 id="new-TextDecoder-encoding-options"><a href="#new-TextDecoder-encoding-options" class="headerlink" title="new TextDecoder([encoding[, options]])"></a>new TextDecoder([encoding[, options]])</h5><h5 id="textDecoder-decode-input-options"><a href="#textDecoder-decode-input-options" class="headerlink" title="textDecoder.decode([input[, options]])"></a>textDecoder.decode([input[, options]])</h5><h5 id="textDecoder-encoding"><a href="#textDecoder-encoding" class="headerlink" title="textDecoder.encoding"></a>textDecoder.encoding</h5><h5 id="textDecoder-fatal"><a href="#textDecoder-fatal" class="headerlink" title="textDecoder.fatal"></a>textDecoder.fatal</h5><h5 id="textDecoder-ignoreBOM"><a href="#textDecoder-ignoreBOM" class="headerlink" title="textDecoder.ignoreBOM"></a>textDecoder.ignoreBOM</h5><h4 id="util-TextEncoder类"><a href="#util-TextEncoder类" class="headerlink" title="util.TextEncoder类"></a>util.TextEncoder类</h4><p>TextEncoder的所有实例仅支持UTF-8编码。<br>TextEncoder类在全局对象上可用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const encoder &#x3D; new TextEncoder();</span><br><span class="line">const uint8array &#x3D; encoder.encode(&#39;这是一些数据&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="textEncoder-encode-input"><a href="#textEncoder-encode-input" class="headerlink" title="textEncoder.encode([input])"></a>textEncoder.encode([input])</h5><h5 id="textEncoder-encodeInto-src-dest"><a href="#textEncoder-encodeInto-src-dest" class="headerlink" title="textEncoder.encodeInto(src, dest)"></a>textEncoder.encodeInto(src, dest)</h5><h5 id="textEncoder-encoding"><a href="#textEncoder-encoding" class="headerlink" title="textEncoder.encoding"></a>textEncoder.encoding</h5><h4 id="util-types"><a href="#util-types" class="headerlink" title="util.types"></a>util.types</h4><h5 id="util-types-isAnyArrayBuffer-value"><a href="#util-types-isAnyArrayBuffer-value" class="headerlink" title="util.types.isAnyArrayBuffer(value)"></a>util.types.isAnyArrayBuffer(value)</h5><h5 id="util-types-isArgumentsObject-value"><a href="#util-types-isArgumentsObject-value" class="headerlink" title="util.types.isArgumentsObject(value)"></a>util.types.isArgumentsObject(value)</h5><h5 id="util-types-isArrayBuffer-value"><a href="#util-types-isArrayBuffer-value" class="headerlink" title="util.types.isArrayBuffer(value)"></a>util.types.isArrayBuffer(value)</h5><h5 id="util-types-isAsyncFunction-value"><a href="#util-types-isAsyncFunction-value" class="headerlink" title="util.types.isAsyncFunction(value)"></a>util.types.isAsyncFunction(value)</h5><h5 id="util-types-isBigInt64Array-value"><a href="#util-types-isBigInt64Array-value" class="headerlink" title="util.types.isBigInt64Array(value)"></a>util.types.isBigInt64Array(value)</h5><h5 id="util-types-isBigUint64Array-value"><a href="#util-types-isBigUint64Array-value" class="headerlink" title="util.types.isBigUint64Array(value)"></a>util.types.isBigUint64Array(value)</h5><h5 id="util-types-isBooleanObject-value"><a href="#util-types-isBooleanObject-value" class="headerlink" title="util.types.isBooleanObject(value)"></a>util.types.isBooleanObject(value)</h5><h5 id="util-types-isDataView-value"><a href="#util-types-isDataView-value" class="headerlink" title="util.types.isDataView(value)"></a>util.types.isDataView(value)</h5><h5 id="util-types-isData-value"><a href="#util-types-isData-value" class="headerlink" title="util.types.isData(value)"></a>util.types.isData(value)</h5><h5 id="util-types-isExternal-value"><a href="#util-types-isExternal-value" class="headerlink" title="util.types.isExternal(value)"></a>util.types.isExternal(value)</h5><h5 id="util-types-isFloat32Array-value"><a href="#util-types-isFloat32Array-value" class="headerlink" title="util.types.isFloat32Array(value)"></a>util.types.isFloat32Array(value)</h5><h5 id="util-types-isFloat64Array-value"><a href="#util-types-isFloat64Array-value" class="headerlink" title="util.types.isFloat64Array(value)"></a>util.types.isFloat64Array(value)</h5><h5 id="util-types-isGeneratorFunction-value"><a href="#util-types-isGeneratorFunction-value" class="headerlink" title="util.types.isGeneratorFunction(value)"></a>util.types.isGeneratorFunction(value)</h5><h5 id="util-types-isGeneratorObject-value"><a href="#util-types-isGeneratorObject-value" class="headerlink" title="util.types.isGeneratorObject(value)"></a>util.types.isGeneratorObject(value)</h5><h5 id="util-types-isInt8Array-value"><a href="#util-types-isInt8Array-value" class="headerlink" title="util.types.isInt8Array(value)"></a>util.types.isInt8Array(value)</h5><h5 id="util-types-isInt16Array-value"><a href="#util-types-isInt16Array-value" class="headerlink" title="util.types.isInt16Array(value)"></a>util.types.isInt16Array(value)</h5><h5 id="util-types-isInt32Array-value"><a href="#util-types-isInt32Array-value" class="headerlink" title="util.types.isInt32Array(value)"></a>util.types.isInt32Array(value)</h5><h5 id="util-types-isMap-value"><a href="#util-types-isMap-value" class="headerlink" title="util.types.isMap(value)"></a>util.types.isMap(value)</h5><h5 id="util-types-isMapIterator-value"><a href="#util-types-isMapIterator-value" class="headerlink" title="util.types.isMapIterator(value)"></a>util.types.isMapIterator(value)</h5><h5 id="util-types-isModuleNamespaceObject-value"><a href="#util-types-isModuleNamespaceObject-value" class="headerlink" title="util.types.isModuleNamespaceObject(value)"></a>util.types.isModuleNamespaceObject(value)</h5><h5 id="util-types-isNativeError-value"><a href="#util-types-isNativeError-value" class="headerlink" title="util.types.isNativeError(value)"></a>util.types.isNativeError(value)</h5><h5 id="util-types-isNumberObjext-value"><a href="#util-types-isNumberObjext-value" class="headerlink" title="util.types.isNumberObjext(value)"></a>util.types.isNumberObjext(value)</h5><h5 id="util-types-isPromise-value"><a href="#util-types-isPromise-value" class="headerlink" title="util.types.isPromise(value)"></a>util.types.isPromise(value)</h5><h5 id="util-types-isProxy-value"><a href="#util-types-isProxy-value" class="headerlink" title="util.types.isProxy(value)"></a>util.types.isProxy(value)</h5><h5 id="util-types-isRegExp-value"><a href="#util-types-isRegExp-value" class="headerlink" title="util.types.isRegExp(value)"></a>util.types.isRegExp(value)</h5><h5 id="util-types-isSet-value"><a href="#util-types-isSet-value" class="headerlink" title="util.types.isSet(value)"></a>util.types.isSet(value)</h5><h5 id="util-types-isSetIterator-value"><a href="#util-types-isSetIterator-value" class="headerlink" title="util.types.isSetIterator(value)"></a>util.types.isSetIterator(value)</h5><h5 id="util-types-isSharedArrayBuffer-value"><a href="#util-types-isSharedArrayBuffer-value" class="headerlink" title="util.types.isSharedArrayBuffer(value)"></a>util.types.isSharedArrayBuffer(value)</h5><h5 id="util-types-isStringObject-value"><a href="#util-types-isStringObject-value" class="headerlink" title="util.types.isStringObject(value)"></a>util.types.isStringObject(value)</h5><h5 id="util-types-isSymbolObject-value"><a href="#util-types-isSymbolObject-value" class="headerlink" title="util.types.isSymbolObject(value)"></a>util.types.isSymbolObject(value)</h5><h5 id="util-types-isTypedArray-value"><a href="#util-types-isTypedArray-value" class="headerlink" title="util.types.isTypedArray(value)"></a>util.types.isTypedArray(value)</h5><h5 id="util-types-isUint8Array-value"><a href="#util-types-isUint8Array-value" class="headerlink" title="util.types.isUint8Array(value)"></a>util.types.isUint8Array(value)</h5><h5 id="util-types-isUint8ClampedArray-value"><a href="#util-types-isUint8ClampedArray-value" class="headerlink" title="util.types.isUint8ClampedArray(value)"></a>util.types.isUint8ClampedArray(value)</h5><h5 id="util-types-isUint16Array-value"><a href="#util-types-isUint16Array-value" class="headerlink" title="util.types.isUint16Array(value)"></a>util.types.isUint16Array(value)</h5><h5 id="util-types-isUint32Array-value"><a href="#util-types-isUint32Array-value" class="headerlink" title="util.types.isUint32Array(value)"></a>util.types.isUint32Array(value)</h5><h5 id="util-types-isWeakMap-value"><a href="#util-types-isWeakMap-value" class="headerlink" title="util.types.isWeakMap(value)"></a>util.types.isWeakMap(value)</h5><h5 id="util-types-isWeakSet-value"><a href="#util-types-isWeakSet-value" class="headerlink" title="util.types.isWeakSet(value)"></a>util.types.isWeakSet(value)</h5><h5 id="util-types-isWebAssemblyCompiledModule-value"><a href="#util-types-isWebAssemblyCompiledModule-value" class="headerlink" title="util.types.isWebAssemblyCompiledModule(value)"></a>util.types.isWebAssemblyCompiledModule(value)</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之url</title>
    <url>/articles/2020-02-07-node-url.html</url>
    <content><![CDATA[<h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>url模块用于处理与解析URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url &#x3D; require(&#39;url&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="URL字符串与URL对象"><a href="#URL字符串与URL对象" class="headerlink" title="URL字符串与URL对象"></a>URL字符串与URL对象</h4><p>URL字符串是结构化的字符串，包含多个含义不同的组成部分。<br>解析字符串后返回的URL对象，每个属性对应字符串各个组成部分。</p>
<p>url模块提供了两套API来处理URL：一个是旧版本遗留的API，一个是实现了WHATWG标准的新API。</p>
<p>下图中上方是遗留的url.parse()，下方是WHATWG的url对象的属性.</p>
<p>WHATWG的origin属性包括protocol和host，但不包括userName或password。<br><img src="./../images/url.jpg" alt="Image text"></p>
<p>使用WHATWG的API解析URL字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D;</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;user:pass@sub.host.com:8080&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string#hash&#39;);</span><br></pre></td></tr></table></figure>

<p>使用遗留的API解析URL字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line">const myURL &#x3D;</span><br><span class="line">  url.parse(&#39;https:&#x2F;&#x2F;user:pass@sub.host.com:8080&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string#hash&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="WHATWG的URL接口"><a href="#WHATWG的URL接口" class="headerlink" title="WHATWG的URL接口"></a>WHATWG的URL接口</h4><h5 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h5><p>浏览器兼容的URL类，根据WHATWG URL标准实现。</p>
<h5 id="new-URL-input-base"><a href="#new-URL-input-base" class="headerlink" title="new URL(input[, base])"></a>new URL(input[, base])</h5><p>通过将input相对于base进行解析，创建一个新的URL对象。如果base是一个字符串，则解析方法与new URL(base)相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;&#x2F;foo&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;foo</span><br></pre></td></tr></table></figure>

<p>如果input和base是无效的URL，则将抛出TypeError。<br>注意，给定值将会被强制转换为字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#123; toString: () &#x3D;&gt; &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>存在于input主机名中的Unicode字符将被使用Punycode算法转换为ASCII。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;測試&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;xn--g6w251d&#x2F;</span><br></pre></td></tr></table></figure>

<p>只有在启用ICU的情况下编译node可执行文件时，此功能才可用。如果没有，则域名将保持不变。<br>如果input是绝对的URL并提供了base，则实现不知道它，建议验证URL对象的origin是否是预期的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myURL &#x3D; new URL(&#39;http:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;foo:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; foo:&#x2F;&#x2F;Example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;http:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;https:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;Example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;foo:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; foo:Example.com&#x2F;</span><br></pre></td></tr></table></figure>

<h5 id="url-hash"><a href="#url-hash" class="headerlink" title="url.hash"></a>url.hash</h5><p>获取及设置Url的片段部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo#bar&#39;);</span><br><span class="line">console.log(myURL.hash);</span><br><span class="line">  &#x2F;&#x2F; 打印 #bar</span><br><span class="line"></span><br><span class="line">myURL.hash &#x3D; &#39;baz&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;foo#baz</span><br></pre></td></tr></table></figure>
<p>分配给hash属性的值中包含的无效URL字符是百分比编码的。<br>选择哪些字符进行百分比编码可能与 url.parse() 和 url.format() 方法产生的内容有所不同。</p>
<h5 id="url-host"><a href="#url-host" class="headerlink" title="url.host"></a>url.host</h5><p>获取及设置URL的主机部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org:81&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.host);</span><br><span class="line">  &#x2F;&#x2F; 打印 example.org:81</span><br><span class="line"></span><br><span class="line">myURL.host &#x3D; &#39;example.com:82&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com:82&#x2F;foo</span><br></pre></td></tr></table></figure>
<p>分配给host属性的无效主机值将会被忽略。</p>
<h5 id="url-hostname"><a href="#url-hostname" class="headerlink" title="url.hostname"></a>url.hostname</h5><p>获取及设置URL的主机名部分。<br>url.host和url.hostname之间的区别是url.hostname不包含端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org:81&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.hostname);</span><br><span class="line">  &#x2F;&#x2F; 打印 example.org</span><br><span class="line"></span><br><span class="line">myURL.hostname &#x3D; &#39;example.com:82&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com:81&#x2F;foo</span><br></pre></td></tr></table></figure>

<h5 id="url-href"><a href="#url-href" class="headerlink" title="url.href"></a>url.href</h5><p>获取及设置序列化的URL.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;foo</span><br><span class="line"></span><br><span class="line">myURL.href &#x3D; &#39;https:&#x2F;&#x2F;example.com&#x2F;bar&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com&#x2F;bar</span><br></pre></td></tr></table></figure>

<p>获取href属性的值等同于调用url.toString()</p>
<p>将此属性的值设置为新值等同于使用new URL(value) 创建新的URL对象。 URL对象的每个属性都将被修改。</p>
<p>如果给href属性设置的值是无效的URL，则将会抛出TypeError。</p>
<h5 id="url-origin"><a href="#url-origin" class="headerlink" title="url.origin"></a>url.origin</h5><p>获取只读的序列化的URL的origin。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onst myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo&#x2F;bar?baz&#39;);</span><br><span class="line">console.log(myURL.origin);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const idnURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;測試&#39;);</span><br><span class="line">console.log(idnURL.origin);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;xn--g6w251d</span><br><span class="line"></span><br><span class="line">console.log(idnURL.hostname);</span><br><span class="line">&#x2F;&#x2F; 打印 xn--g6w251d</span><br></pre></td></tr></table></figure>

<h5 id="url-password"><a href="#url-password" class="headerlink" title="url.password"></a>url.password</h5><p>获取及设置的URL的密码部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;abc:xyz@example.com&#39;);</span><br><span class="line">console.log(myURL.password);</span><br><span class="line">  &#x2F;&#x2F; 打印 xyz</span><br><span class="line"></span><br><span class="line">myURL.password &#x3D; &#39;123&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;abc:123@example.com</span><br></pre></td></tr></table></figure>

<h5 id="url-pathname"><a href="#url-pathname" class="headerlink" title="url.pathname"></a>url.pathname</h5><p>获取及设置URL的路径部分。</p>
<h5 id="url-port"><a href="#url-port" class="headerlink" title="url.port"></a>url.port</h5><p>获取及设置URL的端口部分。<br>端口值可以是数字或包含0到65535范围内的数字字符串。<br>端口值可以是空字符串，这种情况下，端口取决于协议/规范：<br>| 协议 | 端口 |<br>| ftp |  21  |<br>| file |     |<br>| gopher | 70 |<br>| http | 80 |<br>| https | 443 |<br>| ws | 80  |<br>| wss | 443 |</p>
<p>在为端口分配值后，将首先使用.toString()将值转换为字符串。</p>
<p>如果该字符串无效但以数字开头，则将前导代码分配给port。如果数字位于上述范围之外，则忽略它。</p>
<h5 id="url-protocol"><a href="#url-protocol" class="headerlink" title="url.protocol"></a>url.protocol</h5><p>获取及设置URL的协议部分。</p>
<h5 id="特殊协议"><a href="#特殊协议" class="headerlink" title="特殊协议"></a>特殊协议</h5><h5 id="url-search"><a href="#url-search" class="headerlink" title="url.search"></a>url.search</h5><p>获取及设置URL的序列化查询部分</p>
<h5 id="url-searchParams"><a href="#url-searchParams" class="headerlink" title="url.searchParams"></a>url.searchParams</h5><p>获取表示URL查询参数的URLSearchParams对象。该属性是只读的。</p>
<h5 id="url-username"><a href="#url-username" class="headerlink" title="url.username"></a>url.username</h5><p>获取及设置URL的用户名部分。</p>
<h5 id="url-toString"><a href="#url-toString" class="headerlink" title="url.toString()"></a>url.toString()</h5><p>在Url对象上调用toString()方法返回序列化的URL。<br>返回值与url.href和url.toJSON()的相同。</p>
<h5 id="url-toJSON"><a href="#url-toJSON" class="headerlink" title="url.toJSON()"></a>url.toJSON()</h5><p>在URL对象上调用toJSON()方法返回序列化的URL。<br>返回值与url.href和url.toString()的相同。</p>
<p>当URL对象使用JSON.stringify()序列化时将自动调用该方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURLs &#x3D; [</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;www.example.com&#39;),</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;test.example.org&#39;)</span><br><span class="line">];</span><br><span class="line">console.log(JSON.stringify(myURLs));</span><br><span class="line">&#x2F;&#x2F; 打印 [&quot;https:&#x2F;&#x2F;www.example.com&#x2F;&quot;,&quot;https:&#x2F;&#x2F;test.example.org&#x2F;&quot;]</span><br></pre></td></tr></table></figure>

<h4 id="URLSearchParams类"><a href="#URLSearchParams类" class="headerlink" title="URLSearchParams类"></a>URLSearchParams类</h4><p>URLSearchParams API提供对URL查询部分的读写权限。<br>URLSearchParams 类也能够与以下四个构造函数中的任意一个单独使用。<br>URLSearchParams 类也可在全局对象上使用。</p>
<p>WHATWG URLSearchParams 接口和 querystring 模块有相似的目的，<br>但是 querystring 模块的目的更加通用，因为它可以定制分隔符（＆ 和 =）。<br>但另一方面，这个 API 是专门为 URL 查询字符串而设计的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;?abc&#x3D;123&#39;);</span><br><span class="line">console.log(myURL.searchParams.get(&#39;abc&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印 123</span><br><span class="line"></span><br><span class="line">myURL.searchParams.append(&#39;abc&#39;, &#39;xyz&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?abc&#x3D;123&amp;abc&#x3D;xyz</span><br><span class="line"></span><br><span class="line">myURL.searchParams.delete(&#39;abc&#39;);</span><br><span class="line">myURL.searchParams.set(&#39;a&#39;, &#39;b&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b</span><br><span class="line"></span><br><span class="line">const newSearchParams &#x3D; new URLSearchParams(myURL.searchParams);</span><br><span class="line">&#x2F;&#x2F; 上面的代码等同于：</span><br><span class="line">&#x2F;&#x2F; const newSearchParams &#x3D; new URLSearchParams(myURL.search);</span><br><span class="line"></span><br><span class="line">newSearchParams.append(&#39;a&#39;, &#39;c&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b</span><br><span class="line">console.log(newSearchParams.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 a&#x3D;b&amp;a&#x3D;c</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; newSearchParams.toString() 会被隐式调用。</span><br><span class="line">myURL.search &#x3D; newSearchParams;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b&amp;a&#x3D;c</span><br><span class="line">newSearchParams.delete(&#39;a&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b&amp;a&#x3D;c</span><br></pre></td></tr></table></figure>

<h5 id="new-URLSearchParams"><a href="#new-URLSearchParams" class="headerlink" title="new URLSearchParams()"></a>new URLSearchParams()</h5><p>实例化一个新的空的URLSearchParams对象。</p>
<h5 id="new-URLSearchParams-string"><a href="#new-URLSearchParams-string" class="headerlink" title="new URLSearchParams(string)"></a>new URLSearchParams(string)</h5><p>将string解析成一个查询字符串，并用它来实例化一个新的URLSearchParams对象。<br>如果以“？”开头，则忽略。</p>
<h5 id="new-URLSearchParams-obj"><a href="#new-URLSearchParams-obj" class="headerlink" title="new URLSearchParams(obj)"></a>new URLSearchParams(obj)</h5><p>obj:表示键值对集合的对象。</p>
<p>通过使用查询哈希映射实例化一个新的URLSearchParams对象。<br>obj的每一个属性的键值都将强制转换为字符串。</p>
<p>和 querystring 模块不同的是，在数组的形式中，重复的键是不允许的。<br>数组使用 array.toString() 进行字符串化时，只需用逗号连接所有的数组元素即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const params &#x3D; new URLSearchParams(&#123;</span><br><span class="line">  user: &#39;abc&#39;,</span><br><span class="line">  query: [&#39;first&#39;, &#39;second&#39;]</span><br><span class="line">&#125;);</span><br><span class="line">console.log(params.getAll(&#39;query&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印 [ &#39;first,second&#39; ]</span><br><span class="line">console.log(params.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 &#39;user&#x3D;abc&amp;query&#x3D;first%2Csecond&#39;</span><br></pre></td></tr></table></figure>

<h5 id="urlSearchParams-append-name-value"><a href="#urlSearchParams-append-name-value" class="headerlink" title="urlSearchParams.append(name, value)"></a>urlSearchParams.append(name, value)</h5><p>在查询字符串中附加一个新的键值对。</p>
<h5 id="urlSearchParams-delete-name"><a href="#urlSearchParams-delete-name" class="headerlink" title="urlSearchParams.delete(name)"></a>urlSearchParams.delete(name)</h5><p>删除所有键为name的键值对。</p>
<h5 id="urlSearchParams-entries"><a href="#urlSearchParams-entries" class="headerlink" title="urlSearchParams.entries()"></a>urlSearchParams.entries()</h5><p>在查询中的每个键值对上返回一个ES6 Iterator。<br>迭代器的每一项都是一个JavaScript Array。<br>Array的第一个项是键name，第二个项是值value。</p>
<h5 id="urlSearchParams-forEach-fn-thisArg"><a href="#urlSearchParams-forEach-fn-thisArg" class="headerlink" title="urlSearchParams.forEach(fn[, thisArg])"></a>urlSearchParams.forEach(fn[, thisArg])</h5><p>在查询字符串中迭代每个键值对，并调用给定的函数。</p>
<h5 id="urlSearchParams-get-name"><a href="#urlSearchParams-get-name" class="headerlink" title="urlSearchParams.get(name)"></a>urlSearchParams.get(name)</h5><p>返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null。</p>
<h5 id="urlSearchParams-getAll-name"><a href="#urlSearchParams-getAll-name" class="headerlink" title="urlSearchParams.getAll(name)"></a>urlSearchParams.getAll(name)</h5><p>返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空数组。</p>
<h5 id="urlSearchParams-has-name"><a href="#urlSearchParams-has-name" class="headerlink" title="urlSearchParams.has(name)"></a>urlSearchParams.has(name)</h5><p>如果存在至少一对键是name的键值对则返回true。</p>
<h5 id="urlSearchParams-keys"><a href="#urlSearchParams-keys" class="headerlink" title="urlSearchParams.keys()"></a>urlSearchParams.keys()</h5><p>在每一个键值对上返回一个键的ES6 Iterator。</p>
<h5 id="urlSearchParams-set-name-value"><a href="#urlSearchParams-set-name-value" class="headerlink" title="urlSearchParams.set(name, value)"></a>urlSearchParams.set(name, value)</h5><p>将URLSearchParams对象中与name对象的值设置为value。<br>如果已经存在键为name的键值对，则将第一对的值设为value并删除其他队。<br>如果不存在，则将此键值对附加在查询字符串后。</p>
<h5 id="urlSearchParams-sort"><a href="#urlSearchParams-sort" class="headerlink" title="urlSearchParams.sort()"></a>urlSearchParams.sort()</h5><p>按现有名称就地排列所有的名称-值对。<br>使用稳定排序算法完成排序，因此保留具有相同名称的名称-值对之间的相对顺序。</p>
<p>该方法可以用来增加缓存命中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const params &#x3D; new URLSearchParams(&#39;query[]&#x3D;abc&amp;type&#x3D;search&amp;query[]&#x3D;123&#39;);</span><br><span class="line">params.sort();</span><br><span class="line">console.log(params.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 query%5B%5D&#x3D;abc&amp;query%5B%5D&#x3D;123&amp;type&#x3D;search</span><br></pre></td></tr></table></figure>

<h5 id="urlSearchParams-toString"><a href="#urlSearchParams-toString" class="headerlink" title="urlSearchParams.toString()"></a>urlSearchParams.toString()</h5><p>返回查询参数序列化后的字符串，必要时存在百分号编码字符。</p>
<h5 id="urlSearchParams-values"><a href="#urlSearchParams-values" class="headerlink" title="urlSearchParams.values()"></a>urlSearchParams.values()</h5><p>在每一个键值对上返回一个值的ES6 Iterator。</p>
<h5 id="urlSearchParams-Symbol-iterator"><a href="#urlSearchParams-Symbol-iterator" class="headerlink" title="urlSearchParams[Symbol.iterator]"></a>urlSearchParams[Symbol.iterator]</h5><p>根据查询字符串，返回一个键值对形式的ES6 Iterator。<br>每个迭代器的项是一个JavaScript Array。<br>其中，Array的第一项是name，第二个是value。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之tty</title>
    <url>/articles/2020-02-07-node-tty.html</url>
    <content><![CDATA[<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h2><p>终端。</p>
<p>tty模块提供tty.ReadStream和tty.WriteStream类。<br>大多数情况下，没有必要或可能直接使用此模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tty &#x3D; require(&#39;tty&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>当Nodejs检测到它附加了文本终端TTY时，默认，process.stdin将被初始化为tty.ReadStream的一个示例，process.stdout和process.stderr将被初始化为tty.WriteStream的实例。<br>判断Nodejs是否在TTY上下文中运行的首选方法是检查process.stdout.isTTY属性的值是否为true。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;</span><br><span class="line">true</span><br><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat</span><br><span class="line">false</span><br></pre></td></tr></table></figure>

<h4 id="tty-ReadStream类"><a href="#tty-ReadStream类" class="headerlink" title="tty.ReadStream类"></a>tty.ReadStream类</h4><p>代表TTY的可读端。<br>正常情况中，processs.stdin将会使Nodejs进程中唯一的tty.ReadStream实例，并且没有理由创建其他的实例。</p>
<h5 id="readStream-isRaw"><a href="#readStream-isRaw" class="headerlink" title="readStream.isRaw"></a>readStream.isRaw</h5><p>布尔值，如果TTY当前配置为作为原始设备运行，则为true，默认false</p>
<h5 id="readStream-isTTY"><a href="#readStream-isTTY" class="headerlink" title="readStream.isTTY"></a>readStream.isTTY</h5><p>布尔值，对于tty.readStream实例始终为true。</p>
<h5 id="readStream-setRawMode-mode"><a href="#readStream-setRawMode-mode" class="headerlink" title="readStream.setRawMode(mode)"></a>readStream.setRawMode(mode)</h5><p>允许配置tty.ReadStream，使其作为原始设备运行。</p>
<h4 id="tty-WriteStream类"><a href="#tty-WriteStream类" class="headerlink" title="tty.WriteStream类"></a>tty.WriteStream类</h4><p>代表TTY的可写端。<br>在正常情况中，process.stdout和process.stdder将会是为nodejs进程创建的唯一的tty.WriteStream实例，并且没有理由创建其他的实例。</p>
<h5 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h5><p>只要writeStream.colums或writeStream.rows属性发生更改，就会触发resize事件。<br>调用时，没有参数传递给监听器回调。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.stdout.on(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;屏幕大小已经改变&#39;);</span><br><span class="line">  console.log(&#96;$&#123;process.stdout.columns&#125;x$&#123;process.stdout.rows&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="writeStream-clearLine-dir-callback"><a href="#writeStream-clearLine-dir-callback" class="headerlink" title="writeStream.clearLine(dir[,callback])"></a>writeStream.clearLine(dir[,callback])</h5><p>在dir标识的方向上清除此WriteStream的当前行。</p>
<h5 id="writeStream-clearScreenDown-callback"><a href="#writeStream-clearScreenDown-callback" class="headerlink" title="writeStream.clearScreenDown([callback])"></a>writeStream.clearScreenDown([callback])</h5><p>从当前光标向下清除此WriteStream。</p>
<h5 id="writeStream-columns"><a href="#writeStream-columns" class="headerlink" title="writeStream.columns"></a>writeStream.columns</h5><p>一个数字，指定TTY当前具有的列数。每当触发resize事件时，此属性都会更新。</p>
<h5 id="writeStream-cursorTo-x-y-callback"><a href="#writeStream-cursorTo-x-y-callback" class="headerlink" title="writeStream.cursorTo(x[,y][,callback])"></a>writeStream.cursorTo(x[,y][,callback])</h5><p>将writeStream的光标移动到指定的位置。</p>
<h5 id="writeStream-getColorDepth-env"><a href="#writeStream-getColorDepth-env" class="headerlink" title="writeStream.getColorDepth([env])"></a>writeStream.getColorDepth([env])</h5><p>使用此函数可检测终端支持的颜色。</p>
<h5 id="writeStream-getWindowSize"><a href="#writeStream-getWindowSize" class="headerlink" title="writeStream.getWindowSize()"></a>writeStream.getWindowSize()</h5><p>返回此writeStream对应的TTY的大小。</p>
<h5 id="writeStream-hasColors-count-env"><a href="#writeStream-hasColors-count-env" class="headerlink" title="writeStream.hasColors([count][,env])"></a>writeStream.hasColors([count][,env])</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.stdout.hasColors();</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 16 种颜色。</span><br><span class="line">process.stdout.hasColors(256);</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 256 种颜色。</span><br><span class="line">process.stdout.hasColors(&#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 true。</span><br><span class="line">process.stdout.hasColors(2 ** 24, &#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 false (环境设置假设支持 2 ** 8 种颜色)。</span><br></pre></td></tr></table></figure>

<h5 id="writeStream-isTTY"><a href="#writeStream-isTTY" class="headerlink" title="writeStream.isTTY"></a>writeStream.isTTY</h5><p>布尔值，始终未true。</p>
<h5 id="writeStream-moveCursor-dx-dy-callback"><a href="#writeStream-moveCursor-dx-dy-callback" class="headerlink" title="writeStream.moveCursor(dx, dy[, callback])"></a>writeStream.moveCursor(dx, dy[, callback])</h5><p>将writeStream的光标相当于其当前位置移动。</p>
<h5 id="writeStream-rows"><a href="#writeStream-rows" class="headerlink" title="writeStream.rows"></a>writeStream.rows</h5><p>一个数字，指定TTY当前具有的行数。<br>每当触发resize事件时，此属性都会更新。</p>
<h4 id="tty-isatty-fd"><a href="#tty-isatty-fd" class="headerlink" title="tty.isatty(fd)"></a>tty.isatty(fd)</h4><p>如果给定的fd与TTY相关联，则tty.isatty(fd)返回true，否则返回false，包括fd不是非负整数时。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之trace_events</title>
    <url>/articles/2020-02-07-node-trace-events.html</url>
    <content><![CDATA[<h2 id="trace-events"><a href="#trace-events" class="headerlink" title="trace_events"></a>trace_events</h2><p>跟踪事件。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const trace_events &#x3D; require(&#39;trace_events&#39;);</span><br><span class="line">const t1 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node&#39;, &#39;v8&#39;] &#125;);</span><br><span class="line">const t2 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node.perf&#39;, &#39;node&#39;] &#125;);</span><br><span class="line">t1.enable();</span><br><span class="line">t2.enable();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,node.perf,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br><span class="line"></span><br><span class="line">t2.disable(); &#x2F;&#x2F; Will only disable emission of the &#39;node.perf&#39; category</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之tls</title>
    <url>/articles/2020-02-07-node-tls.html</url>
    <content><![CDATA[<h2 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h2><p>安全传输层。<br>tls模块是对安全传输层(TLS)及安全套接层(SSL)协议的实现，建立在OpenSSL的基础上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tls &#x3D; require(&#39;tls&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="TLS-SSL概念"><a href="#TLS-SSL概念" class="headerlink" title="TLS/SSL概念"></a>TLS/SSL概念</h4><p>TLS/SSL是公共/私人的密钥基础设施(PKI)。<br>大部分情况下，每个服务器和客户端都应该有一个私钥。</p>
<p>私钥有多种生成方式。<br>通过TLS/SSL，所有的服务器必须要一个证书。证书是相似于私钥的公钥，它由CA或者私钥签名，特别地，私钥拥有者所签名的被称为自签名。获取证书的第一步是生成一个证书申请文件(CSR)。</p>
<p>用OpenSSL能生成一个私钥的CSR文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</span><br></pre></td></tr></table></figure>

<p>CSR文件被生成以后，它既能被CA签名也能被用户自签名。用OpenSSL生成一个自签名证书的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</span><br></pre></td></tr></table></figure>
<p>证书被生成以后，它又能用来生成一个.pfx或.p12文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \</span><br><span class="line">      -certfile ca-cert.pem -out ryans.pfx</span><br></pre></td></tr></table></figure>

<p>命令行参数：</p>
<ul>
<li>in：被签名的证书</li>
<li>inkey：有关的私钥</li>
<li>certifile：签入文件的证书串。</li>
</ul>
<h4 id="完全前向保密"><a href="#完全前向保密" class="headerlink" title="完全前向保密"></a>完全前向保密</h4><p>术语“前向保密”或“完全前向保密”是一中密钥协商方法。<br>通过这种方法，客户端与服务端在当前会话中，协商一个临时生成的密钥进行对称加密的密钥交换，<br>这意味着即使服务器端私钥发生泄漏，窃密者与攻击者也无法解密通信内容，除非他们能得到当前会话的临时密钥。</p>
<p>TLS/SSL握手时，使用完全前向即每次会话都会随机生成一个临时密钥对用于对称加密密钥协商(区别于每次会话都是用相同的密钥)。<br>实现这个技术的密钥交换算法称为“ephemeral”。</p>
<p>当前最常用的两种实现完全前向保密的算法：</p>
<ul>
<li>DHE - 使用临时密钥的Diffie Hellman密钥交换算法</li>
<li>ECDHE - 使用临时密钥的椭圆曲线Diffie Hellman密钥交换算法<br>使用临时密钥可能带来性能损失，因为密钥生成的过程十分消耗CPU计算性能。</li>
</ul>
<p>如需使用完全前向加密，例如使用tls模块的DHC算法，使用之前需要生成一个Diffie-Hellman参数并将其用dhparam声明在tls.createSecureContext()中。<br>如下展示如何用OpenSSL命令生成参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">openssl dhparam -outform PEM -out dhparam.pem 2048</span><br></pre></td></tr></table></figure>

<p>如需使用ECDHE算法，则不需要生成Diffie-Hellman参数，因为可以使用默认的ECDHE曲线。</p>
<p>完全向前保密在TLSv1.2之前是可选的，但不是TLSv1.3的可选项，因为所有的TLSv1.3密码套件都使用ECDHE。</p>
<h4 id="ALPN和SNI"><a href="#ALPN和SNI" class="headerlink" title="ALPN和SNI"></a>ALPN和SNI</h4><h4 id="客户端发起的重协商攻击缓解"><a href="#客户端发起的重协商攻击缓解" class="headerlink" title="客户端发起的重协商攻击缓解"></a>客户端发起的重协商攻击缓解</h4><p>TLS协议允许客户端在TLS会话中进行协商，用于安全因素的考量。<br>不幸的是，会话重协商需要消耗大量的服务器端资源，这将导致服务器存在潜在的被DDoS攻击的可能。</p>
<p>为了减轻这个风险，限制每十分钟只能使用三次重协商，超过这个限制将会在tls.TLSSocket实例中产生一个error事件。这个限制是可配置的：</p>
<ul>
<li>tls.CLIENT_RENEG_LIMIT<number>指定重协商请求的次数限制，默认3</li>
<li>tls.CLIENT_RENEG_WINDOW<number>指定限制次数的生效时间段，默认600s<br>不应在末未充分理解其含义与影响的情况下修改上述参数。</li>
</ul>
<p>TLSv1.3不支持重协商。</p>
<h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><h4 id="修改默认的TLS加密组件"><a href="#修改默认的TLS加密组件" class="headerlink" title="修改默认的TLS加密组件"></a>修改默认的TLS加密组件</h4><p>NodeJs构造时包含了默认的TLS开启和关闭的加密组件。</p>
<h4 id="tls-Server类"><a href="#tls-Server类" class="headerlink" title="tls.Server类"></a>tls.Server类</h4><p>接受使用TLS或SSL的加密连接。</p>
<h5 id="keylog事件"><a href="#keylog事件" class="headerlink" title="keylog事件"></a>keylog事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const logFile &#x3D; fs.createWriteStream(&#39;&#x2F;tmp&#x2F;ssl-keys.log&#39;, &#123; flags: &#39;a&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">server.on(&#39;keylog&#39;, (line, tlsSocket) &#x3D;&gt; &#123;</span><br><span class="line">  if (tlsSocket.remoteAddress !&#x3D;&#x3D; &#39;...&#39;)</span><br><span class="line">    return; &#x2F;&#x2F; Only log keys for a particular IP</span><br><span class="line">  logFile.write(line);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="newSession事件"><a href="#newSession事件" class="headerlink" title="newSession事件"></a>newSession事件</h5><p>添加监听器后，监听器只在连接建立后生效。</p>
<h5 id="OCSPRequest事件"><a href="#OCSPRequest事件" class="headerlink" title="OCSPRequest事件"></a>OCSPRequest事件</h5><h5 id="resumeSession事件"><a href="#resumeSession事件" class="headerlink" title="resumeSession事件"></a>resumeSession事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const tlsSessionStore &#x3D; &#123;&#125;;</span><br><span class="line">server.on(&#39;newSession&#39;, (id, data, cb) &#x3D;&gt; &#123;</span><br><span class="line">  tlsSessionStore[id.toString(&#39;hex&#39;)] &#x3D; data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line">server.on(&#39;resumeSession&#39;, (id, cb) &#x3D;&gt; &#123;</span><br><span class="line">  cb(null, tlsSessionStore[id.toString(&#39;hex&#39;)] || null);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="secureConnection事件"><a href="#secureConnection事件" class="headerlink" title="secureConnection事件"></a>secureConnection事件</h5><h5 id="tlsClientError事件"><a href="#tlsClientError事件" class="headerlink" title="tlsClientError事件"></a>tlsClientError事件</h5><h5 id="server-addContext-hostname-context"><a href="#server-addContext-hostname-context" class="headerlink" title="server.addContext(hostname, context)"></a>server.addContext(hostname, context)</h5><h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h4 id="tls-TLSSocket类"><a href="#tls-TLSSocket类" class="headerlink" title="tls.TLSSocket类"></a>tls.TLSSocket类</h4><h5 id="new-tls-TLSSocket-socket-options"><a href="#new-tls-TLSSocket-socket-options" class="headerlink" title="new tls.TLSSocket(socket[, options])"></a>new tls.TLSSocket(socket[, options])</h5><h5 id="keylog事件-1"><a href="#keylog事件-1" class="headerlink" title="keylog事件"></a>keylog事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const logFile &#x3D; fs.createWriteStream(&#39;&#x2F;tmp&#x2F;ssl-keys.log&#39;, &#123; flags: &#39;a&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">tlsSocket.on(&#39;keylog&#39;, (line) &#x3D;&gt; logFile.write(line));</span><br></pre></td></tr></table></figure>

<h5 id="OCSPResponse事件"><a href="#OCSPResponse事件" class="headerlink" title="OCSPResponse事件"></a>OCSPResponse事件</h5><h5 id="secureConnect事件"><a href="#secureConnect事件" class="headerlink" title="secureConnect事件"></a>secureConnect事件</h5><h5 id="session事件"><a href="#session事件" class="headerlink" title="session事件"></a>session事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tlsSocket.once(&#39;session&#39;, (session) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; The session can be used immediately or later.</span><br><span class="line">  tls.connect(&#123;</span><br><span class="line">    session: session,</span><br><span class="line">    &#x2F;&#x2F; Other connect options...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="tlsSocket-address"><a href="#tlsSocket-address" class="headerlink" title="tlsSocket.address()"></a>tlsSocket.address()</h5><h5 id="tlsSocket-authorizationError"><a href="#tlsSocket-authorizationError" class="headerlink" title="tlsSocket.authorizationError"></a>tlsSocket.authorizationError</h5><h5 id="tlsSocket-authorized"><a href="#tlsSocket-authorized" class="headerlink" title="tlsSocket.authorized"></a>tlsSocket.authorized</h5><h5 id="tlsSocket-disableRenegotiation"><a href="#tlsSocket-disableRenegotiation" class="headerlink" title="tlsSocket.disableRenegotiation()"></a>tlsSocket.disableRenegotiation()</h5><h5 id="tlsSocket-enableTrace"><a href="#tlsSocket-enableTrace" class="headerlink" title="tlsSocket.enableTrace()"></a>tlsSocket.enableTrace()</h5><h5 id="tlsSocket-encrypted"><a href="#tlsSocket-encrypted" class="headerlink" title="tlsSocket.encrypted"></a>tlsSocket.encrypted</h5><h5 id="tlsSocket-getCertificate"><a href="#tlsSocket-getCertificate" class="headerlink" title="tlsSocket.getCertificate()"></a>tlsSocket.getCertificate()</h5><h5 id="tlsSocket-getCipher"><a href="#tlsSocket-getCipher" class="headerlink" title="tlsSocket.getCipher()"></a>tlsSocket.getCipher()</h5><h5 id="tlsSocket-getephemeralKeyInfo"><a href="#tlsSocket-getephemeralKeyInfo" class="headerlink" title="tlsSocket.getephemeralKeyInfo()"></a>tlsSocket.getephemeralKeyInfo()</h5><h5 id="tlsSocket-getFinished"><a href="#tlsSocket-getFinished" class="headerlink" title="tlsSocket.getFinished()"></a>tlsSocket.getFinished()</h5><h5 id="tlsSocket-getPeerCertificate-detailed"><a href="#tlsSocket-getPeerCertificate-detailed" class="headerlink" title="tlsSocket.getPeerCertificate([detailed])"></a>tlsSocket.getPeerCertificate([detailed])</h5><h5 id="tlsSocket-getPeerFinished"><a href="#tlsSocket-getPeerFinished" class="headerlink" title="tlsSocket.getPeerFinished()"></a>tlsSocket.getPeerFinished()</h5><h5 id="tlsSocket-getProtocol"><a href="#tlsSocket-getProtocol" class="headerlink" title="tlsSocket.getProtocol()"></a>tlsSocket.getProtocol()</h5><h5 id="tlsSocket-getSession"><a href="#tlsSocket-getSession" class="headerlink" title="tlsSocket.getSession()"></a>tlsSocket.getSession()</h5><h5 id="tlsSocket-getSharedSigalgs"><a href="#tlsSocket-getSharedSigalgs" class="headerlink" title="tlsSocket.getSharedSigalgs()"></a>tlsSocket.getSharedSigalgs()</h5><h5 id="tlsSocket-getTLSTicket"><a href="#tlsSocket-getTLSTicket" class="headerlink" title="tlsSocket.getTLSTicket()"></a>tlsSocket.getTLSTicket()</h5><h5 id="tlsSocket-isSessionReused"><a href="#tlsSocket-isSessionReused" class="headerlink" title="tlsSocket.isSessionReused()"></a>tlsSocket.isSessionReused()</h5><h5 id="tlsSocket-localAddress"><a href="#tlsSocket-localAddress" class="headerlink" title="tlsSocket.localAddress"></a>tlsSocket.localAddress</h5><h5 id="tlsSocket-localPort"><a href="#tlsSocket-localPort" class="headerlink" title="tlsSocket.localPort"></a>tlsSocket.localPort</h5><h5 id="tlsSocket-remoteAddress"><a href="#tlsSocket-remoteAddress" class="headerlink" title="tlsSocket.remoteAddress"></a>tlsSocket.remoteAddress</h5><h5 id="tlsSocket-remotefamily"><a href="#tlsSocket-remotefamily" class="headerlink" title="tlsSocket.remotefamily"></a>tlsSocket.remotefamily</h5><h5 id="tlsSocket-remotePort"><a href="#tlsSocket-remotePort" class="headerlink" title="tlsSocket.remotePort"></a>tlsSocket.remotePort</h5><h5 id="tlsSocket-renegotiate-options-callback"><a href="#tlsSocket-renegotiate-options-callback" class="headerlink" title="tlsSocket.renegotiate(options, callback)"></a>tlsSocket.renegotiate(options, callback)</h5><h5 id="tlsSocket-setMaxSendFragment-size"><a href="#tlsSocket-setMaxSendFragment-size" class="headerlink" title="tlsSocket.setMaxSendFragment(size)"></a>tlsSocket.setMaxSendFragment(size)</h5><h5 id="tls-checkServerdentity-hostname-cert"><a href="#tls-checkServerdentity-hostname-cert" class="headerlink" title="tls.checkServerdentity(hostname, cert)"></a>tls.checkServerdentity(hostname, cert)</h5><h5 id="tls-connect-options-callback"><a href="#tls-connect-options-callback" class="headerlink" title="tls.connect(options[, callback])"></a>tls.connect(options[, callback])</h5><h5 id="tls-connect-path-options-callback"><a href="#tls-connect-path-options-callback" class="headerlink" title="tls.connect(path[, options][, callback])"></a>tls.connect(path[, options][, callback])</h5><h5 id="tls-connect-port-host-options-callback"><a href="#tls-connect-port-host-options-callback" class="headerlink" title="tls.connect(port[, host][, options][, callback])"></a>tls.connect(port[, host][, options][, callback])</h5><h5 id="tls-createSecureContext-options"><a href="#tls-createSecureContext-options" class="headerlink" title="tls.createSecureContext([options])"></a>tls.createSecureContext([options])</h5><h5 id="tls-createServer-options-secureConnectionListener"><a href="#tls-createServer-options-secureConnectionListener" class="headerlink" title="tls.createServer([options][, secureConnectionListener])"></a>tls.createServer([options][, secureConnectionListener])</h5><h5 id="tls-getCophers"><a href="#tls-getCophers" class="headerlink" title="tls.getCophers()"></a>tls.getCophers()</h5><h5 id="tls-rootCertificates"><a href="#tls-rootCertificates" class="headerlink" title="tls.rootCertificates"></a>tls.rootCertificates</h5><h5 id="tls-DEFAULT-ECDH-CURVE"><a href="#tls-DEFAULT-ECDH-CURVE" class="headerlink" title="tls.DEFAULT_ECDH_CURVE"></a>tls.DEFAULT_ECDH_CURVE</h5><h5 id="tls-DEFAULT-MAX-VERSION"><a href="#tls-DEFAULT-MAX-VERSION" class="headerlink" title="tls.DEFAULT_MAX_VERSION"></a>tls.DEFAULT_MAX_VERSION</h5><h5 id="tls-DEFAULT-MIN-VERSION"><a href="#tls-DEFAULT-MIN-VERSION" class="headerlink" title="tls.DEFAULT_MIN_VERSION"></a>tls.DEFAULT_MIN_VERSION</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之timer</title>
    <url>/articles/2020-02-06-node-timer.html</url>
    <content><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>定时器。</p>
<p>timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。<br>因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。</p>
<p>Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。</p>
<a id="more"></a>

<h4 id="Immediate类"><a href="#Immediate类" class="headerlink" title="Immediate类"></a>Immediate类</h4><p>此对象在内部创建，并从setImmediate()返回。可以传给clearImmediate()以取消计划的操作。</p>
<p>默认，当预定immediate时，只要immediate激活，Nodejs事件循环将继续运行。<br>setImmediate()返回的Immediate对象导出immediate.ref()和immediate.unref()函数，这些函数可用于控制此默认行为。</p>
<h5 id="immediate-hasRef"><a href="#immediate-hasRef" class="headerlink" title="immediate.hasRef()"></a>immediate.hasRef()</h5><p>如果未true，则Immediate对象将会使Nodejs事件循环保持活动状态。</p>
<h5 id="immediate-ref"><a href="#immediate-ref" class="headerlink" title="immediate.ref()"></a>immediate.ref()</h5><p>调用时，只要immediate处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用immediate.ref()将无效。</p>
<p>默认，所有Immediate对象都是ref的，通常不需要调用Immediate.ref()，除非之前调用了Immediate.unref()</p>
<h5 id="immediate-unref"><a href="#immediate-unref" class="headerlink" title="immediate.unref()"></a>immediate.unref()</h5><p>调用时，活动的Immediate对象不需要Nodejs事件循环保持活动状态。如果没有其他活动保持事件循环运行，<br>则进程可以在调用Immediate对象的回调之前推出。多次调用Immediate.unref()将无效。</p>
<h4 id="Timeout类"><a href="#Timeout类" class="headerlink" title="Timeout类"></a>Timeout类</h4><p>此对象在内部创建，并从setTimeout()和setInterval()返回。<br>它可以传给clearTimeout()或clearInterval()以取消计划的操作。</p>
<p>默认情况，当使用setTimeout()或setInterval()预定定时器时，只要定时器处于活动状态，<br>Nodejs事件循环将继续运行。这些函数返回的每个Timeout对象都会导出timeout.ref()和timeout.unref()函数，<br>这些函数可用于控制此默认行为。</p>
<h5 id="timeout-hasRef"><a href="#timeout-hasRef" class="headerlink" title="timeout.hasRef()"></a>timeout.hasRef()</h5><p>如果为true，则timeout对象将会使Nodejs事件循环保持活动状态。</p>
<h5 id="timeout-ref"><a href="#timeout-ref" class="headerlink" title="timeout.ref()"></a>timeout.ref()</h5><p>调用时，只要timeout处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用timeout.ref()将无效。</p>
<p>默认，所有Timeout对象都是ref的，通常不需要调用timeout.ref()，除非之前调用了timeout.unref()</p>
<h5 id="timeout-refresh"><a href="#timeout-refresh" class="headerlink" title="timeout.refresh()"></a>timeout.refresh()</h5><p>将定时器的开始时间设置为当前时间，并重新安排定时器以在之前指定的持续时间内调用其回调，<br>并将其调整为当前时间，这对于在不分配新JavaScript对象的情况下刷新定时器非常有用。</p>
<h5 id="timeout-unref"><a href="#timeout-unref" class="headerlink" title="timeout.unref()"></a>timeout.unref()</h5><p>调用时，活动的Timeout对象不需要Nodejs事件循环保持活动状态。<br>如果没有其他活动保持事件循环运行，则进程可以在调用Timeout对象的回调之前退出。<br>多次调用timeout.unref()将无效。</p>
<p>调用timeout.unref()会创建一个内部定时器，它将唤醒Nodejs事件循环。<br>创建太多这些定时器可能会对Nodejs应用程序的性能产生负面影响。</p>
<h4 id="预定定时器"><a href="#预定定时器" class="headerlink" title="预定定时器"></a>预定定时器</h4><h5 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h5><p>预定在I/O事件的回调之后立即执行的callback。</p>
<p>当多次调用setImmediate()时，callback函数将按照创建它们的顺序排队等待执行。<br>每次事件循环迭代都会处理整个回调队列。<br>如果立即定时器是从正在执行的回调排入队列，则直到下一次事件循环迭代才会触发。</p>
<p>如果callback不是函数，则抛出TypeError</p>
<h5 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h5><p>预定每隔delay毫秒重复执行callback。</p>
<p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p>
<p>如果callback不是函数，则抛出TypeError。</p>
<h5 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h5><p>预定在delay毫秒之后执行一次性的callback。</p>
<p>可能不会精确的在delay毫秒时调用callback。<br>Nodejs不保证回调被触发的确切时间，也不保证他们的顺序。<br>回调会在尽可能接近指定的时间调用。</p>
<p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p>
<p>如果callback不是函数，则抛出TypeError。</p>
<h4 id="取消定时器"><a href="#取消定时器" class="headerlink" title="取消定时器"></a>取消定时器</h4><p>setImmediate()/setInterval()/setTimeout()方法各自返回表示预定的定时器的对象。<br>它们可用于取消定时器并防止其触发。</p>
<p>无法取消使用setImmediate()/setTimeout()的Promise化的变体创建的定时器。</p>
<h5 id="clearImmediate-immediate"><a href="#clearImmediate-immediate" class="headerlink" title="clearImmediate(immediate)"></a>clearImmediate(immediate)</h5><p>取消由setImmediate()创建的Immediate对象。</p>
<h5 id="clearInterval-timeout"><a href="#clearInterval-timeout" class="headerlink" title="clearInterval(timeout)"></a>clearInterval(timeout)</h5><p>取消由setInterval()创建的Timeout对象。</p>
<h5 id="clearTimeout-timeout"><a href="#clearTimeout-timeout" class="headerlink" title="clearTimeout(timeout)"></a>clearTimeout(timeout)</h5><p>取消由setTimeout()创建的Timeout对象。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之string_decoder</title>
    <url>/articles/2020-02-06-node-string-decoder.html</url>
    <content><![CDATA[<h2 id="string-decoder"><a href="#string-decoder" class="headerlink" title="string_decoder"></a>string_decoder</h2><p>字符串解码器。</p>
<p>提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);</span><br><span class="line">const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);</span><br><span class="line"></span><br><span class="line">const cent &#x3D; Buffer.from([0xC2, 0xA2]);</span><br><span class="line">console.log(decoder.write(cent));</span><br><span class="line"></span><br><span class="line">const euro &#x3D; Buffer.from([0xE2, 0x82, 0xAC]);</span><br><span class="line">console.log(decoder.write(euro));</span><br></pre></td></tr></table></figure>

<p>将Buffer实例写入StringDecoder实例时，将使用内部缓冲区来确保已解码的字符串不包含任何不完整的多字节字符。它们保存在缓冲区中，直到下一次调用stringDecoder.write()或调用stringDecoder.end()为止。</p>
<h4 id="StringDecoder类"><a href="#StringDecoder类" class="headerlink" title="StringDecoder类"></a>StringDecoder类</h4><h5 id="new-StringDecoder-encoding"><a href="#new-StringDecoder-encoding" class="headerlink" title="new StringDecoder([encoding])"></a>new StringDecoder([encoding])</h5><p>创建一个新的StringDecoder实例。</p>
<h5 id="stringDecoder-end-buffer"><a href="#stringDecoder-end-buffer" class="headerlink" title="stringDecoder.end([buffer])"></a>stringDecoder.end([buffer])</h5><p>以字符串形式返回存储在内部缓冲区中的任何剩余输入。 表示不完整的 UTF-8 和 UTF-16 字符的字节将替换为适合字符编码的替换字符。</p>
<p>如果提供了 buffer 参数，则在返回剩余的输入之前再最后一次调用 stringDecoder.write()</p>
<h5 id="stringDecoder-write-buffer"><a href="#stringDecoder-write-buffer" class="headerlink" title="stringDecoder.write(buffer)"></a>stringDecoder.write(buffer)</h5><p>返回一个已解码的字符串，确保在返回的字符串不包含 Buffer、 TypedArray 或 DataView 末尾的任何不完整的多字节字符，并将其存储在内部缓冲区中，以便下次调用 stringDecoder.write() 或 stringDecoder.end()。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之stream</title>
    <url>/articles/2020-02-06-node-stream.html</url>
    <content><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之repl</title>
    <url>/articles/2020-02-06-node-repl.html</url>
    <content><![CDATA[<h2 id="repl"><a href="#repl" class="headerlink" title="repl"></a>repl</h2><p>交互式解释器</p>
<p>repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="设计与特性"><a href="#设计与特性" class="headerlink" title="设计与特性"></a>设计与特性</h4><p>repl模块导出了repl.REPLServer类。当repl.REPLServer实例运行时，它接收用户输入的每一行，根据用户定义的解释函数解释这些输入，然后输出结果。<br>repl.REPLServer实例支持输入的自动补全、精简Emacs风格的行编辑、多行输入、ANSI风格的输出、当前REPL会话状态的保存于恢复、错误校正、以及可定制的解释函数。</p>
<h4 id="命令与特殊键"><a href="#命令与特殊键" class="headerlink" title="命令与特殊键"></a>命令与特殊键</h4><ul>
<li>.break - 在输入一个多行表达式的过程中，输入 .break 命令（或按下 <ctrl>-C 组合键）将终止表达式的继续输入。</li>
<li>.clear - 重置 REPL 的 context 为一个空对象，并清除当前正输入的所有多行表达式。</li>
<li>.exit - 关闭输入输出流，退出 REPL。</li>
<li>.help - 显示特定命令的帮助列表。</li>
<li>.save - 保存当前 REPL 会话到一个文件： &gt; .save ./file/to/save.js</li>
<li>.load - 读取一个文件到当前 REPL 会话。 &gt; .load ./file/to/load.js</li>
<li>.editor 进入编辑模式（<ctrl>-D 完成， <ctrl>-C 取消）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; .editor</span><br><span class="line">&#x2F;&#x2F; 进入编辑模式（^D 完成，^C 取消）</span><br><span class="line">function welcome(name) &#123;</span><br><span class="line">  return &#96;你好 $&#123;name&#125;！&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">welcome(&#39;Node.js 用户&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ^D</span><br><span class="line">&#39;你好 Node.js 用户！&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>

<h4 id="默认的解释器"><a href="#默认的解释器" class="headerlink" title="默认的解释器"></a>默认的解释器</h4><p>默认情况下，所有repl.REPLServer实例使用了一个解释函数，它可以解释JavaScript表达式、提供对Nodejs内置模块的访问。当repl.REPLServer实例被创建时可以传入一个替换的解释函数，覆盖其默认的功能。</p>
<h5 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 1 + 1</span><br><span class="line">2</span><br><span class="line">&gt; const m &#x3D; 2</span><br><span class="line">undefined</span><br><span class="line">&gt; m + 1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h5 id="全局作用域与局部作用域"><a href="#全局作用域与局部作用域" class="headerlink" title="全局作用域与局部作用域"></a>全局作用域与局部作用域</h5><p>默认的解释器提供了获取存在于全局作用域中的任何变量的途径。 可以通过给每个 REPLServer 绑定的 context 对象指定变量，来显式地把变量暴露给 REPL。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">repl.start(&#39;&gt; &#39;).context.m &#x3D; msg;</span><br></pre></td></tr></table></figure>

<p>context 对象的属性表现为 REPL 中的局部变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node repl_test.js</span><br><span class="line">&gt; m</span><br><span class="line">&#39;message&#39;</span><br></pre></td></tr></table></figure>

<p>默认情况下 context 的属性不是只读的。 要指定只读的全局变量， context 的属性必须使用 Object.defineProperty() 来定义:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">const r &#x3D; repl.start(&#39;&gt; &#39;);</span><br><span class="line">Object.defineProperty(r.context, &#39;m&#39;, &#123;</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  value: msg</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="访问Nodejs核心模块"><a href="#访问Nodejs核心模块" class="headerlink" title="访问Nodejs核心模块"></a>访问Nodejs核心模块</h5><p>默认的解释器会自动加载被调用的 Node.js 核心模块到 REPL 环境中。 例如，除非被声明为一个全局变量或一个有限范围的变量，否则输入 fs 会被解释为 global.fs = require(‘fs’)。</p>
<figure class="highlight plain"><figcaption><span>fs.createReadStream('./some/file');```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 全局的未捕获异常</span><br><span class="line">REPL 使用 domain 模块来捕获该 REPL 会话的所有未捕获的异常。</span><br><span class="line"></span><br><span class="line">在 REPL 中对 domain 模块的这种使用具有以下的副作用：</span><br><span class="line"></span><br><span class="line">* 未捕获的异常仅在独立的 REPL 中触发 &#39;uncaughtException&#39; 事件。 在另一个 Node.js 程序的 REPL 中添加此事件的监听器会抛出 ERR_INVALID_REPL_INPUT。</span><br><span class="line"></span><br><span class="line">* 尝试使用 process.setUncaughtExceptionCaptureCallback() 会抛出 ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE 错误。</span><br><span class="line"></span><br><span class="line">作为独立程序：</span><br></pre></td></tr></table></figure>
<p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));</p>
<p>throw new Error(‘foobar’);<br>// 未捕获的异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当在另一个应用程序中使用时：</span><br></pre></td></tr></table></figure>
<p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));<br>// TypeError [ERR_INVALID_REPL_INPUT]: Listeners for <code>uncaughtException</code><br>// cannot be used in the REPL</p>
<p>throw new Error(‘foobar’);<br>// 抛出:<br>// Error: foobar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### _ 变量的赋值</span><br><span class="line"></span><br><span class="line">默认的解释器会把最近一次解释的表达式的结果赋值给变量 _ （下划线）。 显式地设置 _ 为某个值能禁用该特性。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>[ ‘a’, ‘b’, ‘c’ ]<br>[ ‘a’, ‘b’, ‘c’ ]<br>_.length<br>3<br>_ += 1<br>Expression assignment to _ now disabled.<br>4<br>1 + 1<br>2<br>_<br>4</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">同样， _error 将指向最后一次看到的错误（如果有的话）。 将 _error 显式设置为值将禁用此行为</span><br></pre></td></tr></table></figure>
<blockquote>
<p>throw new Error(‘foo’);<br>Error: foo<br>_error.message<br>‘foo’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### await关键词</span><br><span class="line">使用 --experimental-repl-await 命令行选项，将启用对 await 关键字的实验性支持。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>await Promise.resolve(123)<br>123<br>await Promise.reject(new Error(‘REPL await’))<br>Error: REPL await<br>    at repl:1:45<br>const timeout = util.promisify(setTimeout);<br>undefined<br>const old = Date.now(); await timeout(1000); console.log(Date.now() - old);<br>1002<br>undefined</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义的解释函数</span><br><span class="line">当创建一个新的 repl.REPLServer 时，可以提供一个自定义的解释函数。 这可以用于实现完全定制化的 REPL 应用。</span><br><span class="line"></span><br><span class="line">以下是 REPL 的一个假设的示例，执行从一种语言到另一种语言的文本转换：</span><br></pre></td></tr></table></figure>
<p>const repl = require(‘repl’);<br>const { Translator } = require(‘translator’);</p>
<p>const myTranslator = new Translator(‘en’, ‘fr’);</p>
<p>function myEval(cmd, context, filename, callback) {<br>  callback(null, myTranslator.translate(cmd));<br>}</p>
<p>repl.start({ prompt: ‘&gt; ‘, eval: myEval });</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 可恢复的错误</span><br><span class="line">当用户正在 REPL 中输入时，按下 &lt;enter&gt; 键会把当前行的输入发送到 eval 函数。 为了支持多行输入， eval 函数可以返回一个 repl.Recoverable 实例给提供的回调函数：</span><br></pre></td></tr></table></figure>
<p>function myEval(cmd, context, filename, callback) {<br>  let result;<br>  try {<br>    result = vm.runInThisContext(cmd);<br>  } catch (e) {<br>    if (isRecoverableError(e)) {<br>      return callback(new repl.Recoverable(e));<br>    }<br>  }<br>  callback(null, result);<br>}</p>
<p>function isRecoverableError(error) {<br>  if (error.name === ‘SyntaxError’) {<br>    return /^(Unexpected end of input|Unexpected token)/.test(error.message);<br>  }<br>  return false;<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义REPL输出</span><br><span class="line">默认情况下，在把输出写入到提供的可写流（默认为 process.stdout）之前，repl.REPLServer 实例会使用 util.inspect() 方法对输出进行格式化。 showProxy 检查选项会默认设置为 true， colors 选项会设置为 true，具体取决于 REPL 的 useColors 选项。</span><br><span class="line"></span><br><span class="line">可以在构造时指定 useColors 布尔值选项，以指示默认的编写器使用 ANSI 样式代码来着色来自 util.inspect() 方法的输出。</span><br><span class="line"></span><br><span class="line">如果 REPL 作为独立程序运行，则还可以使用 inspect.replDefaults 属性从 REPL 内部更改 REPL 的检查默认值util.inspect()，该属性是 util.inspect() 中的 defaultOptions 的镜像。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>util.inspect.replDefaults.compact = false;<br>false<br>[1]<br>[<br>  1<br>]</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在构造时，通过在 writer 选项传入一个新的函数，可以完全地自定义一个 repl.REPLServer 实例的输出。 例子，把输入的任何文本转换为大写：</span><br></pre></td></tr></table></figure>
<p>const repl = require(‘repl’);</p>
<p>const r = repl.start({ prompt: ‘&gt; ‘, eval: myEval, writer: myWriter });</p>
<p>function myEval(cmd, context, filename, callback) {<br>  callback(null, cmd);<br>}</p>
<p>function myWriter(output) {<br>  return output.toUpperCase();<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### REPLServer类</span><br><span class="line">repl.REPLServer 的实例是使用 repl.start() 方法创建的，不能直接地使用 JavaScript 的 new 关键字创建。</span><br><span class="line"></span><br><span class="line">##### exit事件</span><br><span class="line">当接收到 .exit 命令、或按下两次 &lt;ctrl&gt;-C 发出 SIGINT 信号、或按下 &lt;ctrl&gt;-D 发出 &#39;end&#39; 信号而使 REPL 被退出时，触发 &#39;exit&#39; 事件。 监听器的回调函数被调用时不带任何参数。</span><br></pre></td></tr></table></figure>
<p>replServer.on(‘exit’, () =&gt; {<br>  console.log(‘从 REPL 接收到 “exit” 事件！’);<br>  process.exit();<br>});</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### reset事件</span><br><span class="line">当 REPL 的上下文被重置时，触发 &#39;reset&#39; 事件。 每当接收到 .clear 命令时会触发该事件，除非 REPL 正在使用默认的解释器并且 repl.REPLServer 实例被创建时 useGlobal 选项被设为 true。 监听器的回调函数被调用时会带上 context 对象作为惟一的参数。</span><br><span class="line"></span><br><span class="line">这主要被用于重新初始化 REPL 上下文，使之达到某些预定义的状态，如下面的例子：</span><br></pre></td></tr></table></figure>
<p>const repl = require(‘repl’);</p>
<p>function initializeContext(context) {<br>  context.m = ‘test’;<br>}</p>
<p>const r = repl.start({ prompt: ‘&gt; ‘ });<br>initializeContext(r.context);</p>
<p>r.on(‘reset’, initializeContext);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">当代码被执行时，全局的 &#39;m&#39; 变量可以被修改，但随后的 .clear 命令会把它重置回初始值：</span><br></pre></td></tr></table></figure>
<p>$ ./node example.js</p>
<blockquote>
<p>m<br>‘test’<br>m = 1<br>1<br>m<br>1<br>.clear<br>Clearing context…<br>m<br>‘test’</p>
</blockquote>
<p>```</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之readline</title>
    <url>/articles/2020-02-06-node-readline.html</url>
    <content><![CDATA[<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>逐行读取。<br>提供了一个接口，用于一次一行的读取可读流中的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;);</span><br><span class="line"></span><br><span class="line">const rl &#x3D; readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.question(&#39;你如何看待 Node.js 中文网？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO：将答案记录在数据库中。</span><br><span class="line">  console.log(&#96;感谢您的宝贵意见：$&#123;answer&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  rl.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>一旦调用此代码，Nodejs应用程序将不会终止，直到readline.Interface关闭，<br>因为接口在Input流上等待接收数据。</p>
<h4 id="Interface类"><a href="#Interface类" class="headerlink" title="Interface类"></a>Interface类</h4><p>readline.Interface类的实例是使用readline.createInterface()方法构造的。<br>每个实例都关联一个input可读流和一个output可写流。<br>output流用于为到达的用户输入打印提示，并从input流读取。</p>
<h4 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h4><p>当发生以下任一情况时会触发close事件：</p>
<ul>
<li>调用rl.close()方法，且readline.Interface实例放弃对input流和output流的控制；</li>
<li>input流接收到其end事件；</li>
<li>input流接收到<ctrl>-D以发信号传输结束；</li>
<li>input流接收到<ctrl>-C以发信号SIGINT，并且readline.Interface实例上没有注册SIGINT事件监听器。<br>调用监听器函数不传入任何参数。</li>
</ul>
<p>一旦触发close事件，则readline.Interface实例就完成了。</p>
<h5 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h5><p>每当input流接收到行尾输入（\n, \r, \r\n）时会触发line事件。</p>
<h5 id="pause事件"><a href="#pause事件" class="headerlink" title="pause事件"></a>pause事件</h5><p>当发生以下任一情况时会触发pause事件：</p>
<ul>
<li>input流被暂停</li>
<li>input流未暂停，且接收到SIGCONT事件</li>
</ul>
<p>调用监听器函数时不传入任何参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.on(&#39;pause&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 暂停&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="resume事件"><a href="#resume事件" class="headerlink" title="resume事件"></a>resume事件</h5><p>每当input流恢复时，就会触发resume事件。<br>调用监听器函数时不传入任何参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.on(&#39;resume&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 恢复&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="SIGCONT事件"><a href="#SIGCONT事件" class="headerlink" title="SIGCONT事件"></a>SIGCONT事件</h5><p>当先前使用<ctrl>-Z移入后台的Nodejs进程使用fg返回到前台时，就会触发SIGCONT事件。<br>如果input流在SIGTSTP请求之前被暂停，则不会触发此事件。</p>
<p>调用监听器函数时不传入任何参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.on(&#39;SIGCONT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;prompt&#96; 将自动恢复流。</span><br><span class="line">  rl.prompt();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Windows上不支持SIGCONT事件。</p>
<h5 id="SIGINT事件"><a href="#SIGINT事件" class="headerlink" title="SIGINT事件"></a>SIGINT事件</h5><p>每当input流接收到<ctrl>-C输入时，就会触发SIGINT事件。<br>如果当input流接收到SIGINT时没有注册SIGINT事件监听器，则会触发pause事件。</p>
<p>调用监听器函数时不传入任何参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  rl.question(&#39;确定要退出吗？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">    if (answer.match(&#x2F;^y(es)?$&#x2F;i)) rl.pause();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="SIGTSTP事件"><a href="#SIGTSTP事件" class="headerlink" title="SIGTSTP事件"></a>SIGTSTP事件</h5><p>每当input流接收到<ctrl>-Z输入时，就会触发SIGTSTP事件。<br>如果当input流接收SIGTSTP时没有注册SIGTSTP事件监听器，则Nodejs进程将被发送到后台。</p>
<p>当使用fg(1p)恢复程序时，将触发pause和SIGCONT事件，这可用于恢复input流。</p>
<p>如果在将进程发送到后台之前暂停input，则不会触发pause和SIGCONT事件。</p>
<p>调用监听器函数时不传入任何参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.on(&#39;SIGTSTP&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这将覆盖 SIGTSTP 并阻止程序进入后台。</span><br><span class="line">  console.log(&#39;捕获 SIGTSTP&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Windows上不支持SIGTSTP事件。</p>
<h5 id="rl-close"><a href="#rl-close" class="headerlink" title="rl.close()"></a>rl.close()</h5><p>会关闭readline.Interface实例，并放弃对input和output流的控制。<br>当调用时，将触发close事件。</p>
<p>调用rl.close()不会立即停止readline.Interface实例触发的其他事件。</p>
<h5 id="rl-pause"><a href="#rl-pause" class="headerlink" title="rl.pause()"></a>rl.pause()</h5><p>会暂停input流，允许稍后在必要时恢复它。<br>调用rl.pause()不会立刻暂停readline.Interfac实例触发的其他事件。</p>
<h5 id="rl-prompt-preserveCursor"><a href="#rl-prompt-preserveCursor" class="headerlink" title="rl.prompt([preserveCursor])"></a>rl.prompt([preserveCursor])</h5><p>将readline.Interface实例配置的提示写入putput中的新一行，以便为用户提供一个可供输入位置。</p>
<p>当调用时，如果input流已暂停，则rl.prompt()将恢复它。</p>
<p>如果readline.Interface创建时output被设置为null或undefined，则不会写入提示。</p>
<h5 id="rl-question-query-callback"><a href="#rl-question-query-callback" class="headerlink" title="rl.question(query, callback)"></a>rl.question(query, callback)</h5><p>通过将query写入output来显示它，并等待用户在input上提供输入，然后调用callback函数将提供的输入作为第一个参数传入。</p>
<p>当调用时，如果input流已暂停，则rl.question()将恢复input流。</p>
<p>如果readline.Interface创建时output将被设置为null或undefined，则不会写入query。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.question(&#39;你最喜欢的食物是什么？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;你最喜欢的食物是 $&#123;answer&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="rl-resume"><a href="#rl-resume" class="headerlink" title="rl.resume()"></a>rl.resume()</h5><p>如果input流已暂停，则rl.resume方法将恢复它。</p>
<h5 id="rl-setPrompt-prompt"><a href="#rl-setPrompt-prompt" class="headerlink" title="rl.setPrompt(prompt)"></a>rl.setPrompt(prompt)</h5><p>设置每当调用rl.prompt()时将写入output的提示。</p>
<h5 id="rl-write-data-key"><a href="#rl-write-data-key" class="headerlink" title="rl.write(data[, key])"></a>rl.write(data[, key])</h5><p>将data或key标识的按键序列写入output。<br>仅当output是TTY文本终端时才支持key参数。<br>如果指定了key，则忽略data。<br>当调用时，如果input流已暂停，则rl.write()将恢复它。</p>
<p>如果readline.Interface创建时output被设置为null或undefined，则不会写入data和key。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rl.write(&#39;删除这个！&#39;);</span><br><span class="line">&#x2F;&#x2F; 模拟 Ctrl+u 删除先前写入的行。</span><br><span class="line">rl.write(null, &#123; ctrl: true, name: &#39;u&#39; &#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之querystring</title>
    <url>/articles/2020-02-06-node-querystring.html</url>
    <content><![CDATA[<h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><p>查询字符串。<br>querystring模块提供用于解析和格式化URL查询字符串的实用工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const querystring &#x3D; require(&#39;querystring&#39;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="querystring-decode"><a href="#querystring-decode" class="headerlink" title="querystring.decode()"></a>querystring.decode()</h4><p>是querystring.parse()的别名。</p>
<h4 id="querystring-encode"><a href="#querystring-encode" class="headerlink" title="querystring.encode()"></a>querystring.encode()</h4><p>是querystring.stringify()的别名。</p>
<h4 id="querystring-escape-str"><a href="#querystring-escape-str" class="headerlink" title="querystring.escape(str)"></a>querystring.escape(str)</h4><p>以对URL查询字符串的特定要求进行了优化的方式对给定的str执行URL百分比编码。</p>
<h4 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[,sep[,eq[, options]]])"></a>querystring.parse(str[,sep[,eq[, options]]])</h4><p>将URL查询字符串str解析为键值对的集合。</p>
<h4 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[,sep[,eq[, options]]])"></a>querystring.stringify(obj[,sep[,eq[, options]]])</h4><p>通过迭代对象的自身属性从给定的obj生成URL查询字符串。</p>
<h4 id="querystring-unescape-str"><a href="#querystring-unescape-str" class="headerlink" title="querystring.unescape(str)"></a>querystring.unescape(str)</h4><p>在给定的str上执行URL百分比编码字符的解码。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之process</title>
    <url>/articles/2020-02-06-node-process.html</url>
    <content><![CDATA[<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>进程。<br>process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。<br>作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const process &#x3D; require(&#39;process&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h4><p>process对象是EventEmitter的实例。</p>
<h5 id="beforeExit事件"><a href="#beforeExit事件" class="headerlink" title="beforeExit事件"></a>beforeExit事件</h5><p>当Nodejs清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。<br>通常，Nodejs进程将在没有调度工作时退出，但在beforeExit事件上注册的监听器可以进行异步调用，从而导致Nodejs进程继续。</p>
<p>调用监听器回调函数时会将process.exitCode的值作为唯一参数传入。</p>
<p>对于导致显示终止的条件，不会触发beforeExit事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&#39;beforeExit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 beforeExit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 exit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;此消息最新显示&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印:</span><br><span class="line">&#x2F;&#x2F; 此消息最新显示</span><br><span class="line">&#x2F;&#x2F; 进程 beforeExit 事件的代码: 0</span><br><span class="line">&#x2F;&#x2F; 进程 exit 事件的代码: 0</span><br></pre></td></tr></table></figure>

<h5 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h5><p>如果使用IPC通道衍生Nodejs进程，则在IPC通道关闭时将触发disconnect事件。</p>
<h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><p>当Nodejs进程因以下原因之一即将退出时，则会触发exit事件：</p>
<ul>
<li>显示调用process.exit()方法</li>
<li>Nodejs事件循环不再需要执行任何其他工作<br>此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，nodejs进程将终止。</li>
</ul>
<p>用process.exitCode属性指定的退出码或传给process.exit()方法的exitCode参数调用监听器回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;退出码: $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>监听器函数必须只执行同步操作。<br>在调用exit事件监听器之后，Nodejs进程将立即退出，从而导致在事件循环中仍排队的任何其他工作被放弃。</p>
<h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><p>如果使用IPC通道衍生Nodejs进程，则只要子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件。</p>
<p>消息会进行序列化和解析。生成的消息可能与最初发送的消息不同。</p>
<h5 id="multipleResolves事件"><a href="#multipleResolves事件" class="headerlink" title="multipleResolves事件"></a>multipleResolves事件</h5><p>只要Promise有以下情况，将会触发multipleResolves事件：</p>
<ul>
<li>解决不止一次</li>
<li>拒绝不止一次</li>
<li>解决后拒绝</li>
<li>拒绝后解决</li>
</ul>
<h5 id="rejectionHandled事件"><a href="#rejectionHandled事件" class="headerlink" title="rejectionHandled事件"></a>rejectionHandled事件</h5><p>每当Promise被拒绝且错误处理函数附加到它晚于一个Nodejs事件循环时，就会触发rejectHandled事件。</p>
<p>Promise对象之前已经在unhandledRejection事件中触发，但在处理过程中获得了拒绝处理函数。</p>
<p>Promise链中没有顶层的概念，总是可以处理拒绝。本质上自身是异步的，可以在未来的某个时间点处理Promise拒绝，可能比触发unhandledRejection事件所需的事件循环更晚。</p>
<p>在同步代码中，当未处理的异常列表增长时，会触发uncaughtexption事件。<br>在异步代码中，当未处理的异常列表增长时，会触发unhandledRejection事件，并且当未处理的拒绝列表缩小时会触发rejectionHandled事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const unhandledRejections &#x3D; new Map();</span><br><span class="line">process.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.set(promise, reason);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&#39;rejectionHandled&#39;, (promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.delete(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="uncaughtException事件"><a href="#uncaughtException事件" class="headerlink" title="uncaughtException事件"></a>uncaughtException事件</h5><p>当未捕获的JavaScript异常一直冒泡回到事件循环时，会触发uncaughtExpection事件。</p>
<h5 id="unhandledRejection事件"><a href="#unhandledRejection事件" class="headerlink" title="unhandledRejection事件"></a>unhandledRejection事件</h5><p>如果在事件循环的一次轮询中，一个Promise被拒绝，并且此Promise没有绑定错误处理器，unhandledRejection事件会被触发。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之perf_hooks</title>
    <url>/articles/2020-02-06-node-perf-hooks.html</url>
    <content><![CDATA[<h2 id="perf-hooks"><a href="#perf-hooks" class="headerlink" title="perf_hooks"></a>perf_hooks</h2><p>性能钩子。</p>
<p>性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123; PerformanceObserver, performance &#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((items) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(items.getEntries()[0].duration);</span><br><span class="line">  performance.clearMarks();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;measure&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;A&#39;);</span><br><span class="line">doSomeLongRunningProcess(() &#x3D;&gt; &#123;</span><br><span class="line">  performance.mark(&#39;B&#39;);</span><br><span class="line">  performance.measure(&#39;A to B&#39;, &#39;A&#39;, &#39;B&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Performance类"><a href="#Performance类" class="headerlink" title="Performance类"></a>Performance类</h4><h5 id="performance-clearMarks-name"><a href="#performance-clearMarks-name" class="headerlink" title="performance.clearMarks([name])"></a>performance.clearMarks([name])</h5><h5 id="performance-mark-name"><a href="#performance-mark-name" class="headerlink" title="performance.mark([name])"></a>performance.mark([name])</h5><p>创建一个新的PerformanceMark实体。</p>
<h5 id="performance-measure-name-startMark-endMark"><a href="#performance-measure-name-startMark-endMark" class="headerlink" title="performance.measure(name, startMark, endMark)"></a>performance.measure(name, startMark, endMark)</h5><h5 id="performance-nodeTiming"><a href="#performance-nodeTiming" class="headerlink" title="performance.nodeTiming"></a>performance.nodeTiming</h5><h5 id="performance-now"><a href="#performance-now" class="headerlink" title="performance.now()"></a>performance.now()</h5><h5 id="performance-timeOrigin"><a href="#performance-timeOrigin" class="headerlink" title="performance.timeOrigin"></a>performance.timeOrigin</h5><h5 id="performance-timerify-fn"><a href="#performance-timerify-fn" class="headerlink" title="performance.timerify(fn)"></a>performance.timerify(fn)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">function someFunction() &#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped &#x3D; performance.timerify(someFunction);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries()[0].duration);</span><br><span class="line">  obs.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;function&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A performance timeline entry will be created</span><br><span class="line">wrapped();</span><br></pre></td></tr></table></figure>

<h4 id="PerformanceEntry类"><a href="#PerformanceEntry类" class="headerlink" title="PerformanceEntry类"></a>PerformanceEntry类</h4><h5 id="performanceEntry-duration"><a href="#performanceEntry-duration" class="headerlink" title="performanceEntry.duration"></a>performanceEntry.duration</h5><h5 id="performanceEntry-name"><a href="#performanceEntry-name" class="headerlink" title="performanceEntry.name"></a>performanceEntry.name</h5><h5 id="performanceEntry-startTime"><a href="#performanceEntry-startTime" class="headerlink" title="performanceEntry.startTime"></a>performanceEntry.startTime</h5><h5 id="performanceEntry-entryType"><a href="#performanceEntry-entryType" class="headerlink" title="performanceEntry.entryType"></a>performanceEntry.entryType</h5><h5 id="performanceEntry-kind"><a href="#performanceEntry-kind" class="headerlink" title="performanceEntry.kind"></a>performanceEntry.kind</h5><h4 id="PerformanceObserver类"><a href="#PerformanceObserver类" class="headerlink" title="PerformanceObserver类"></a>PerformanceObserver类</h4><h5 id="new-PerformanceObserver-callback"><a href="#new-PerformanceObserver-callback" class="headerlink" title="new PerformanceObserver(callback)"></a>new PerformanceObserver(callback)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries());</span><br><span class="line">  observer.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;test&#39;);</span><br></pre></td></tr></table></figure>

<h5 id="performanceObserver-disconnect"><a href="#performanceObserver-disconnect" class="headerlink" title="performanceObserver.disconnect()"></a>performanceObserver.disconnect()</h5><h5 id="performanceObserver-observe-options"><a href="#performanceObserver-observe-options" class="headerlink" title="performanceObserver.observe(options)"></a>performanceObserver.observe(options)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called three times synchronously. &#96;list&#96; contains one item.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buffered是false的时候，callback会在每次PerformanceEntry的时候回调。</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called once. &#96;list&#96; contains three items.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br></pre></td></tr></table></figure>

<h5 id="PerformanceObserverEntryList类"><a href="#PerformanceObserverEntryList类" class="headerlink" title="PerformanceObserverEntryList类"></a>PerformanceObserverEntryList类</h5><h5 id="performanceObserverEntryList-getEntries"><a href="#performanceObserverEntryList-getEntries" class="headerlink" title="performanceObserverEntryList.getEntries()"></a>performanceObserverEntryList.getEntries()</h5><h5 id="performanceObserverEntryList-getEntriesByName-name-type"><a href="#performanceObserverEntryList-getEntriesByName-name-type" class="headerlink" title="performanceObserverEntryList.getEntriesByName(name[,type])"></a>performanceObserverEntryList.getEntriesByName(name[,type])</h5><h4 id="Histogram类"><a href="#Histogram类" class="headerlink" title="Histogram类"></a>Histogram类</h4><h5 id="histogram-disable"><a href="#histogram-disable" class="headerlink" title="histogram.disable()"></a>histogram.disable()</h5><h5 id="histogram-enable"><a href="#histogram-enable" class="headerlink" title="histogram.enable()"></a>histogram.enable()</h5><h5 id="histogram-exceeds"><a href="#histogram-exceeds" class="headerlink" title="histogram.exceeds"></a>histogram.exceeds</h5><h5 id="histogram-max"><a href="#histogram-max" class="headerlink" title="histogram.max"></a>histogram.max</h5><h5 id="histogram-mean"><a href="#histogram-mean" class="headerlink" title="histogram.mean"></a>histogram.mean</h5><h5 id="histogram-min"><a href="#histogram-min" class="headerlink" title="histogram.min"></a>histogram.min</h5><h5 id="histogram-reset"><a href="#histogram-reset" class="headerlink" title="histogram.reset()"></a>histogram.reset()</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之path</title>
    <url>/articles/2020-02-06-node-path.html</url>
    <content><![CDATA[<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>路径。<br>path模块提供用于处理文件路径和目录路径的实用工具。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h4><p>返回path的目录名。</p>
<h4 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h4><p>返回path的扩展名。</p>
<h4 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h4><p>从对象返回路径字符串。</p>
<h4 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h4><p>检测path是否为绝对路径。</p>
<h4 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h4><p>使用平台特定的分隔符作为定界符将所有给定的path片段连接在一起，然后规范化生成的路径。</p>
<h4 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h4><p>规范化给定的path，解析’..’和’.’片段。</p>
<h4 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h4><p>返回一个对象，其属性表示path的重要元素。尾部的目录分隔符将被忽略。</p>
<h4 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h4><p>根据当前工作目录返回from到to的相对路径。<br>如果from和to各自解析到相同的路径，则返回零长度的字符串。</p>
<h4 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h4><p>将路径或路径片段的序列解析为绝对路径。</p>
<h4 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h4><p>提供pingt特定的路径片段分隔符。</p>
<h4 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h4><p>提供对特定于Windows的path方法的实现的访问。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之os</title>
    <url>/articles/2020-02-06-node-os.html</url>
    <content><![CDATA[<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>操作系统。</p>
<p>os模块提供了与操作系统相关的实用方法和属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const os &#x3D; require(&#39;os&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="os-EOL"><a href="#os-EOL" class="headerlink" title="os.EOL"></a>os.EOL</h4><p>操作系统特定的行末标志。</p>
<ul>
<li>在POSIX上是\n</li>
<li>在Windows上是\r\n</li>
</ul>
<h4 id="os-constants"><a href="#os-constants" class="headerlink" title="os.constants"></a>os.constants</h4><p>包含错误码、进程信号等常用的操作系统特定的常量。<br>定义的特定常量在os常量中定义。</p>
<h4 id="os-cpus"><a href="#os-cpus" class="headerlink" title="os.cpus()"></a>os.cpus()</h4><p>返回一个对象数组，其中包含有关每个逻辑CPU内核的信息。</p>
<h4 id="os-endianness"><a href="#os-endianness" class="headerlink" title="os.endianness()"></a>os.endianness()</h4><p>返回一个字符串，该字符串标识为其编译Nodejs二进制文件的CPU的字节序。<br>可能的值有，BE用于大端字节序，LE用于小端字节序。</p>
<h4 id="os-freemem"><a href="#os-freemem" class="headerlink" title="os.freemem()"></a>os.freemem()</h4><p>以整数的形式返回空闲的系统内存量。</p>
<h4 id="os-getPriority-pid"><a href="#os-getPriority-pid" class="headerlink" title="os.getPriority([pid])"></a>os.getPriority([pid])</h4><p>返回由pid指定的进程的调度优先级。如果未提供pid或为0，则返回当前进程的优先级。</p>
<h4 id="os-homedir"><a href="#os-homedir" class="headerlink" title="os.homedir()"></a>os.homedir()</h4><p>返回当前用户的主目录的字符串路径。</p>
<h4 id="os-hostname"><a href="#os-hostname" class="headerlink" title="os.hostname()"></a>os.hostname()</h4><p>以字符串的形式返回操作系统的主机名。</p>
<h4 id="os-platform"><a href="#os-platform" class="headerlink" title="os.platform()"></a>os.platform()</h4><p>返回标识操作系统平台的字符串。</p>
<h4 id="os-release"><a href="#os-release" class="headerlink" title="os.release()"></a>os.release()</h4><p>以字符串的形式返回操作系统。</p>
<h4 id="os-tmpdir"><a href="#os-tmpdir" class="headerlink" title="os.tmpdir()"></a>os.tmpdir()</h4><p>以字符串的形式返回操作系统的默认临时文件目录。</p>
<h4 id="os-totalmem"><a href="#os-totalmem" class="headerlink" title="os.totalmem()"></a>os.totalmem()</h4><p>以整数的形式返回系统的内存总量。</p>
<h4 id="os-type"><a href="#os-type" class="headerlink" title="os.type()"></a>os.type()</h4><p>返回与uname(3)返回一样的操作系统名字。</p>
<h4 id="os-uptime"><a href="#os-uptime" class="headerlink" title="os.uptime()"></a>os.uptime()</h4><p>返回系统的正常运行时间</p>
<h4 id="os-userInfo-options"><a href="#os-userInfo-options" class="headerlink" title="os.userInfo([options])"></a>os.userInfo([options])</h4><p>返回关于当前有效的用户信息。</p>
<h4 id="os常量"><a href="#os常量" class="headerlink" title="os常量"></a>os常量</h4><p>并不是所有的常量在每一个操作系统上都是可用的。<br>下面的常量被os.constants所输出。</p>
<h5 id="信号常量"><a href="#信号常量" class="headerlink" title="信号常量"></a>信号常量</h5><p>os.constants.signals</p>
<h5 id="错误常量"><a href="#错误常量" class="headerlink" title="错误常量"></a>错误常量</h5><p>os.constants.errno</p>
<h5 id="POSIX错误常量"><a href="#POSIX错误常量" class="headerlink" title="POSIX错误常量"></a>POSIX错误常量</h5><h5 id="Windows系统特有的错误常量"><a href="#Windows系统特有的错误常量" class="headerlink" title="Windows系统特有的错误常量"></a>Windows系统特有的错误常量</h5><h5 id="dlopen常量"><a href="#dlopen常量" class="headerlink" title="dlopen常量"></a>dlopen常量</h5><h5 id="优先级常量"><a href="#优先级常量" class="headerlink" title="优先级常量"></a>优先级常量</h5><h5 id="libuv常量"><a href="#libuv常量" class="headerlink" title="libuv常量"></a>libuv常量</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之net</title>
    <url>/articles/2020-02-05-node-net.html</url>
    <content><![CDATA[<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络。</p>
<p>net模块用于创建基于流的TCP或IPC的服务器与客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const net &#x3D; require(&#39;net&#39;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="IPC支持"><a href="#IPC支持" class="headerlink" title="IPC支持"></a>IPC支持</h4><p>net模块在windows上支持命名管道IPC，在其他操作系统上支持Unix域套接字。</p>
<h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><p>此类用于创建TCP或IPC服务器。</p>
<h5 id="new-net-Server-options-connectionListener"><a href="#new-net-Server-options-connectionListener" class="headerlink" title="new net.Server([options][,connectionListener])"></a>new net.Server([options][,connectionListener])</h5><p>net.Server是一个EventEmitter，实现了以下事件：</p>
<ul>
<li><p>close事件<br>  当Server关闭的时候触发，如果有连接存在，直到所有的连接结束才会触发这个事件。</p>
</li>
<li><p>connection事件<br>  当一个新的连接建立的时候触发。socket是一个net.Socket实例。</p>
</li>
<li><p>error事件<br>  当错误出现的时候触发。</p>
</li>
<li><p>listening事件<br>  当调用server.listen()绑定服务器之后触发。</p>
</li>
</ul>
<h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><p>如果在IP socket上监听，则返回操作系统报告的绑定的address、地址family名称、以及服务器port（<br>用于查找在获取操作系统分配的地址时分配的端口）：<code>{port:12346, family:&#39;IPv4&#39;, address:&#39;127.0.0.1&#39;}</code></p>
<p>对于在管道或Unix域套接字上监听的server，该名称返回为字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const server &#x3D; net.createServer((socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.end(&#39;再见\n&#39;);</span><br><span class="line">&#125;).on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取任意未使用的端口。</span><br><span class="line">server.listen(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;打开服务器&#39;, server.address());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不要在listening事件触发之前调用server.address()</p>
<h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><p>组织server接受新的连接并保持现有的连接。<br>该函数是异步的，server将在所有连接结束后关闭并触发close事件。<br>可选的callback将在close事件发生时被调用。</p>
<h5 id="server-getConnections-callback"><a href="#server-getConnections-callback" class="headerlink" title="server.getConnections(callback)"></a>server.getConnections(callback)</h5><p>异步获取服务器的当前并发连接数。当socket被传递给子进程时工作。<br>回调函数的两个参数是err和count。</p>
<h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><p>启动一个服务器来监听连接。</p>
<h5 id="server-listening"><a href="#server-listening" class="headerlink" title="server.listening"></a>server.listening</h5><p>表明server是否正在监听连接。</p>
<h5 id="server-maxConnections"><a href="#server-maxConnections" class="headerlink" title="server.maxConnections"></a>server.maxConnections</h5><p>该属性使得server连接数过多时拒绝连接。</p>
<h5 id="server-ref"><a href="#server-ref" class="headerlink" title="server.ref()"></a>server.ref()</h5><p>与unref()相反，在一个已经调用unref的server中调用ref，如果server是仅存的server，<br>则程序不会退出。对一个已经调用ref的server再次调用ref()将不会再有效果。</p>
<h5 id="server-unref"><a href="#server-unref" class="headerlink" title="server.unref()"></a>server.unref()</h5><p>如果这个server在事件系统中是唯一有效的，那么对server调用unref()将允许程序退出。<br>如果这个server已经调用过unref那么再次调用unref()将不会再有效果。</p>
<h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><p>net.Socket可以由用户创建并且直接与服务器进行交互。<br>也可以由Nodejs创建，并在收到连接时传给用户。</p>
<h5 id="new-net-Socket-options"><a href="#new-net-Socket-options" class="headerlink" title="new net.Socket([options])"></a>new net.Socket([options])</h5><p>创建一个socket对象。</p>
<h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><p>一旦socket完全关闭就发出该事件。</p>
<h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><p>当一个socket连接成功建立的时候触发该事件。</p>
<h5 id="data事件"><a href="#data事件" class="headerlink" title="data事件"></a>data事件</h5><p>当接收到数据的时候触发该事件。<br>data参数是一个Buffer或String<br>当Socket触发data事件的时候，如果没有监听器则数据将会丢失。</p>
<h5 id="drain事件"><a href="#drain事件" class="headerlink" title="drain事件"></a>drain事件</h5><p>当写入缓冲区变为空时触发。可以用来做上传节流。</p>
<h5 id="end事件"><a href="#end事件" class="headerlink" title="end事件"></a>end事件</h5><p>当socket的另一端发送一个FIN包的时候触发，从而结束socket的可读流。</p>
<h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><p>当错误发生时触发。close事件也会紧接着该事件被触发。</p>
<h5 id="lookup事件"><a href="#lookup事件" class="headerlink" title="lookup事件"></a>lookup事件</h5><p>当找到主机之后创建连接之前触发。</p>
<h5 id="ready事件"><a href="#ready事件" class="headerlink" title="ready事件"></a>ready事件</h5><p>套接字准备好使用时触发。<br>connect后立即触发。</p>
<h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><p>当socket超时的时候触发。</p>
<h5 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect()"></a>socket.connect()</h5><h5 id="socket-connecting"><a href="#socket-connecting" class="headerlink" title="socket.connecting()"></a>socket.connecting()</h5><h5 id="socket-destrory-exception"><a href="#socket-destrory-exception" class="headerlink" title="socket.destrory([exception])"></a>socket.destrory([exception])</h5><h5 id="socket-destroyed"><a href="#socket-destroyed" class="headerlink" title="socket.destroyed"></a>socket.destroyed</h5><p>指示连接是否已经被销毁。<br>一旦连接被销毁就不能再使用它传输任何数据。</p>
<h5 id="socket-end-data-encoding-callback"><a href="#socket-end-data-encoding-callback" class="headerlink" title="socket.end([data[,encoding]][, callback])"></a>socket.end([data[,encoding]][, callback])</h5><p>半关闭socket。</p>
<h4 id="net-isIP-input"><a href="#net-isIP-input" class="headerlink" title="net.isIP(input)"></a>net.isIP(input)</h4><p>测试输入是否是IP地址。<br>无效的字符串则返回0<br>IPv4地址则返回4<br>IPv6的地址则返回6</p>
<h4 id="net-isIPv4-input"><a href="#net-isIPv4-input" class="headerlink" title="net.isIPv4(input)"></a>net.isIPv4(input)</h4><p>如果输入是IPv4地址返回true，否则返回false</p>
<h4 id="net-isIPv6-input"><a href="#net-isIPv6-input" class="headerlink" title="net.isIPv6(input)"></a>net.isIPv6(input)</h4><p>如果输入是IPv6地址返回true，否则返回false</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之module</title>
    <url>/articles/2020-02-05-node-module.html</url>
    <content><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>模块。</p>
<p>在Nodejs模块系统中，每个文件都被视为一个独立的模块。</p>
<a id="more"></a>

<h4 id="访问主模块"><a href="#访问主模块" class="headerlink" title="访问主模块"></a>访问主模块</h4><p>当Nodejs直接运行一个文件时mrequire.main会被视为module。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>模块在第一次加载后会被缓存。<br>每次调用相同的模块都解析到同一个文件，则返回相同的对象。</p>
<h5 id="模块缓存的注意事项"><a href="#模块缓存的注意事项" class="headerlink" title="模块缓存的注意事项"></a>模块缓存的注意事项</h5><p>模块是基于其解析的文件名进行缓存的。由于调用模块的位置不同，模块可能被解析成不同的<br>文件名，这样就不能保证总能返回完全相同的对象。</p>
<p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，<br>但缓存仍然会将它们视为不同的模块，并多次重新加载。</p>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>核心模块定义在Nodejs原代码的lib/目录下。<br>require()总是会优先加载核心模块。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当循环调用require()时，一个模块可能在未完成执行时被返回。</p>
<h4 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h4><p>提供一个单一的入口来指向它。</p>
<h4 id="从node-modules目录加载"><a href="#从node-modules目录加载" class="headerlink" title="从node_modules目录加载"></a>从node_modules目录加载</h4><h4 id="从全局目录加载"><a href="#从全局目录加载" class="headerlink" title="从全局目录加载"></a>从全局目录加载</h4><h4 id="模块封装器"><a href="#模块封装器" class="headerlink" title="模块封装器"></a>模块封装器</h4><p>在指向模块代码之前，Nodejs会使用一个如下的函数封装器将其封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">&#x2F;&#x2F; 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这样做，Nodejs实现了以下几点：</p>
<ul>
<li>它保持了顶层的变量（用var、const或let定义）作用在模块范围内，而不是全局对象；</li>
<li>它有助于提高一些看似全局但实际是模块特定的变量；</li>
</ul>
<h4 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h4><h5 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h5><p>当前模块的目录名。</p>
<h5 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h5><p>当前模块的文件名。</p>
<h5 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h5><h5 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h5><p>对当前模块的引用。</p>
<h5 id="require-id"><a href="#require-id" class="headerlink" title="require(id)"></a>require(id)</h5><h5 id="require-cache"><a href="#require-cache" class="headerlink" title="require.cache"></a>require.cache</h5><p>被引入的模块江北诶缓存在这个对象中，从此对象中删除键值对将会导致下一次require重新加载<br>被删除的模块。这不适用原生插件，因为它们的重载将会导致错误。</p>
<h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>module的自由变量是对表示当前模块的对象的引用。</p>
<h5 id="module-children"><a href="#module-children" class="headerlink" title="module.children"></a>module.children</h5><p>被该模块引用的模块对象。</p>
<h5 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h5><p>module.exports对象由Module系统创建。</p>
<h5 id="exports快捷方式"><a href="#exports快捷方式" class="headerlink" title="exports快捷方式"></a>exports快捷方式</h5><p>exports变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给module。exports。</p>
<h5 id="module-filename"><a href="#module-filename" class="headerlink" title="module.filename"></a>module.filename</h5><p>模块的完全解析后的文件名。</p>
<h5 id="module-id"><a href="#module-id" class="headerlink" title="module.id"></a>module.id</h5><p>模块的标识符。通常是完全解析后的文件名。</p>
<h5 id="module-loaded"><a href="#module-loaded" class="headerlink" title="module.loaded"></a>module.loaded</h5><p>模块是否已经加载完成，或正在加载中。</p>
<h5 id="module-parent"><a href="#module-parent" class="headerlink" title="module.parent"></a>module.parent</h5><p>最先引用该模块的模块。</p>
<h5 id="module-paths"><a href="#module-paths" class="headerlink" title="module.paths"></a>module.paths</h5><p>模块的搜索路径。</p>
<h5 id="module-require-id"><a href="#module-require-id" class="headerlink" title="module.require(id)"></a>module.require(id)</h5><p>提供一种加载模块的方法。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之inspector</title>
    <url>/articles/2020-02-05-node-inspector.html</url>
    <content><![CDATA[<h2 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h2><p>检查器。</p>
<p>inspector模块提供了一个用户与V8 inspector交互的API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const inspector &#x3D; require(&#39;inspector&#39;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="inspector-close"><a href="#inspector-close" class="headerlink" title="inspector.close()"></a>inspector.close()</h4><h4 id="inspector-close-1"><a href="#inspector-close-1" class="headerlink" title="inspector.close"></a>inspector.close</h4><h4 id="inspector-open-port-host-wait"><a href="#inspector-open-port-host-wait" class="headerlink" title="inspector.open([port[, host[, wait]]])"></a>inspector.open([port[, host[, wait]]])</h4><h4 id="inspector-url"><a href="#inspector-url" class="headerlink" title="inspector.url()"></a>inspector.url()</h4><h4 id="inspector-waitForDebugger"><a href="#inspector-waitForDebugger" class="headerlink" title="inspector.waitForDebugger()"></a>inspector.waitForDebugger()</h4><h4 id="inspector-Session类"><a href="#inspector-Session类" class="headerlink" title="inspector.Session类"></a>inspector.Session类</h4><h5 id="new-inspector-Session"><a href="#new-inspector-Session" class="headerlink" title="new inspector.Session()"></a>new inspector.Session()</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之HTTPS</title>
    <url>/articles/2020-02-05-node-HTTPS.html</url>
    <content><![CDATA[<h2 id="https-HTTPS"><a href="#https-HTTPS" class="headerlink" title="https(HTTPS)"></a>https(HTTPS)</h2><p>HTTPS是基于TLS/SSL的HTTP协议。在NodeJS中，作为一个单独的模块实现。</p>
<a id="more"></a>

<h4 id="https-Agent类"><a href="#https-Agent类" class="headerlink" title="https.Agent类"></a>https.Agent类</h4><p>HTTPS的Agent对象，类似于http.Agent.</p>
<h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><h4 id="https-Server类"><a href="#https-Server类" class="headerlink" title="https.Server类"></a>https.Server类</h4><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h5 id="server-headersTimeout"><a href="#server-headersTimeout" class="headerlink" title="server.headersTimeout"></a>server.headersTimeout</h5><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><h5 id="server-maxHeadersCount"><a href="#server-maxHeadersCount" class="headerlink" title="server.maxHeadersCount"></a>server.maxHeadersCount</h5><h5 id="server-setTimeout-msecs-callback"><a href="#server-setTimeout-msecs-callback" class="headerlink" title="server.setTimeout([msecs][,callback])"></a>server.setTimeout([msecs][,callback])</h5><h5 id="server-timeout"><a href="#server-timeout" class="headerlink" title="server.timeout"></a>server.timeout</h5><h5 id="server-keepAliveTimeout"><a href="#server-keepAliveTimeout" class="headerlink" title="server.keepAliveTimeout"></a>server.keepAliveTimeout</h5><h5 id="heeps-createServer-options-requestListener"><a href="#heeps-createServer-options-requestListener" class="headerlink" title="heeps.createServer([options][,requestListener])"></a>heeps.createServer([options][,requestListener])</h5><h5 id="https-get-options-callback"><a href="#https-get-options-callback" class="headerlink" title="https.get(options[,callback])"></a>https.get(options[,callback])</h5><h5 id="https-get-url-options-callback"><a href="#https-get-url-options-callback" class="headerlink" title="https.get(url[,options][,callback])"></a>https.get(url[,options][,callback])</h5><h5 id="https-request-options-callback"><a href="#https-request-options-callback" class="headerlink" title="https.request(options[,callback])"></a>https.request(options[,callback])</h5><h5 id="https-request-url-options-callback"><a href="#https-request-url-options-callback" class="headerlink" title="https.request(url[,options][,callback])"></a>https.request(url[,options][,callback])</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const https &#x3D; require(&#39;https&#39;);</span><br><span class="line"></span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  hostname: &#39;encrypted.google.com&#39;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  method: &#39;GET&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const req &#x3D; https.request(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;状态码:&#39;, res.statusCode);</span><br><span class="line">  console.log(&#39;请求头:&#39;, res.headers);</span><br><span class="line"></span><br><span class="line">  res.on(&#39;data&#39;, (d) &#x3D;&gt; &#123;</span><br><span class="line">    process.stdout.write(d);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(e);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS之HTTP/2</title>
    <url>/articles/2020-02-05-node-Http-2.html</url>
    <content><![CDATA[<h2 id="http2-HTTP-2"><a href="#http2-HTTP-2" class="headerlink" title="http2 (HTTP/2)"></a>http2 (HTTP/2)</h2><p>http2模块提供了HTTP/2协议的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h4><p>核心API提供了专门针对支持HTTP/2协议的特性而设计的底层接口。</p>
<p>http2核心API在客户端和服务器之间比http API更加对称。</p>
<h4 id="Http2Session类"><a href="#Http2Session类" class="headerlink" title="Http2Session类"></a>Http2Session类</h4><p>Http2Session类的实例代表了HTTP/2客户端与服务器之间的一个活跃的通信会话。</p>
<p>每个Http2Session实例会有略有不同的行为，这取决于它是作为服务器还是客户端运行。<br>Http2Session.type属性可用于判断Http2Session的运行模式。</p>
<p>用户代码不会直接的创建Http2Session实例。<br>当接收到新的http/2连接时，服务端的Http2Session实例由Http2Server实例创建。</p>
<h5 id="Http2Session与Socket"><a href="#Http2Session与Socket" class="headerlink" title="Http2Session与Socket"></a>Http2Session与Socket</h5><p>每个Http2Session实例在创建时都会与一个net.Socket或tls.TLSSocket关联。<br>当Socket或Http2Session被销毁时，两者都会被销毁。</p>
<p>一旦将Socket绑定到Http2Session，则用户代码应仅依赖于Http2Session的API。</p>
<h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="stream事件"><a href="#stream事件" class="headerlink" title="stream事件"></a>stream事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line">session.on(&#39;stream&#39;, (stream, headers, flags) &#x3D;&gt; &#123;</span><br><span class="line">  const method &#x3D; headers[&#39;:method&#39;];</span><br><span class="line">  const path &#x3D; headers[&#39;:path&#39;];</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;:status&#39;: 200,</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;plain&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.write(&#39;hello &#39;);</span><br><span class="line">  stream.end(&#39;world&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an unencrypted HTTP&#x2F;2 server</span><br><span class="line">const server &#x3D; http2.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;stream&#39;, (stream, headers) &#x3D;&gt; &#123;</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;html&#39;,</span><br><span class="line">    &#39;:status&#39;: 200</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.on(&#39;error&#39;, (error) &#x3D;&gt; console.error(error));</span><br><span class="line">  stream.end(&#39;&lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br></pre></td></tr></table></figure>

<h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><h4 id="ClientHttp2Session类"><a href="#ClientHttp2Session类" class="headerlink" title="ClientHttp2Session类"></a>ClientHttp2Session类</h4><h4 id="Http2Stream类"><a href="#Http2Stream类" class="headerlink" title="Http2Stream类"></a>Http2Stream类</h4><h5 id="Http2Stream的生命周期"><a href="#Http2Stream的生命周期" class="headerlink" title="Http2Stream的生命周期"></a>Http2Stream的生命周期</h5><p>创建、销毁、</p>
<h4 id="ClientHttp2Stream类"><a href="#ClientHttp2Stream类" class="headerlink" title="ClientHttp2Stream类"></a>ClientHttp2Stream类</h4><h4 id="ServerHttp2Stream类"><a href="#ServerHttp2Stream类" class="headerlink" title="ServerHttp2Stream类"></a>ServerHttp2Stream类</h4><h4 id="Http2Server类"><a href="#Http2Server类" class="headerlink" title="Http2Server类"></a>Http2Server类</h4><h4 id="Http2SecureServer类"><a href="#Http2SecureServer类" class="headerlink" title="Http2SecureServer类"></a>Http2SecureServer类</h4><h4 id="http2-Http2ServerRequest类"><a href="#http2-Http2ServerRequest类" class="headerlink" title="http2.Http2ServerRequest类"></a>http2.Http2ServerRequest类</h4><h4 id="http2-Http2ServerResponse类"><a href="#http2-Http2ServerResponse类" class="headerlink" title="http2.Http2ServerResponse类"></a>http2.Http2ServerResponse类</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之Http</title>
    <url>/articles/2020-02-02-node-Http.html</url>
    <content><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>要使用HTTP服务器和客户端，必须require(‘http’);</p>
<a id="more"></a>

<h4 id="http-Agent类"><a href="#http-Agent类" class="headerlink" title="http.Agent类"></a>http.Agent类</h4><p>Agent负责管理HTTP客户端的链接持久性和重用。</p>
<p>它为给定的主机和端口维护一个待处理请求队列，为每个请求重用单独的套接字连接，<br>直到队列为空，此时套接字被销毁或放入连接池，以便再次用于请求到同一个主机和端口。</p>
<p>销毁还是放入连接池取决于keepAlive选项。</p>
<p>连接池中的连接已启用TCP Keep-Alive，但服务器仍可能关闭空闲连接，<br>这种情况下，它们将从连接池中删除，并且当为该主机和端口发出新的HTTP请求时将建立新的连接。<br>服务器也可以拒绝通过同一连接允许多个请求，在这种情况下，必须为每个请求重新建立连接，<br>并且不能放入连接池。Agent仍将向该服务器发出请求，但每个请求都将通过新连接发生。</p>
<p>当客户端或服务器关闭连接时，它将从连接池中删除。连接池中任何未使用的套接字都将被销毁，<br>以便当没有未完成的请求时不用保持Nodejs进程运行。</p>
<p>当不再使用时最好destrory() Agent实例，因为未使用的套接字会消耗操作系统资源。</p>
<p>当套接字触发close事件或agentRemove事件时，则套接字从代理中删除。<br>当打算长时间保持一个HTTP请求打开而不将其保留在代理中时，可以执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.get(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 做些事情。</span><br><span class="line">&#125;).on(&#39;socket&#39;, (socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.emit(&#39;agentRemove&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代理也可以用于单个请求，通过提供{agent:false}作为http.get()或http.request()<br>函数的选项，则将使用一次性的具有默认选项的Agent用于客户端的连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.get(&#123;</span><br><span class="line">  hostname: &#39;localhost&#39;,</span><br><span class="line">  port: 80,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  agent: false  &#x2F;&#x2F; 仅为此一个请求创建一个新代理。</span><br><span class="line">&#125;, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 用响应做些事情。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><p>options要在代理上设置的可配置选项集。</p>
<p>要配置其中任何一个，则必须创建自定义的http.Agent实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const keepAliveAgent &#x3D; new http.Agent(&#123; keepAlive: true &#125;);</span><br><span class="line">options.agent &#x3D; keepAliveAgent;</span><br><span class="line">http.request(options, onResponseCallback);</span><br></pre></td></tr></table></figure>

<h5 id="agent-createConnection-options-callback"><a href="#agent-createConnection-options-callback" class="headerlink" title="agent.createConnection(options[, callback])"></a>agent.createConnection(options[, callback])</h5><p>生成用于http请求的套接字或流。</p>
<h5 id="agent-keepSocketAlive-socket"><a href="#agent-keepSocketAlive-socket" class="headerlink" title="agent.keepSocketAlive(socket)"></a>agent.keepSocketAlive(socket)</h5><p>当socket与请求分离并且可以由Agent保留时调用，默认行为是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.setKeepAlive(true, this.keepAliveMsecs);</span><br><span class="line">socket.unref();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<h5 id="agent-reuseSocket-socket-request"><a href="#agent-reuseSocket-socket-request" class="headerlink" title="agent.reuseSocket(socket, request)"></a>agent.reuseSocket(socket, request)</h5><p>由于keep-alive选项而在持久化后将socket附加到request时调用。<br>默认行为是<code>socket.ref()</code></p>
<h5 id="agent-destroy"><a href="#agent-destroy" class="headerlink" title="agent.destroy()"></a>agent.destroy()</h5><p>销毁代理当前使用的所有套接字。</p>
<h5 id="agent-maxSockets"><a href="#agent-maxSockets" class="headerlink" title="agent.maxSockets"></a>agent.maxSockets</h5><p>决定代理可以为每个来源打开多少并发套接字。</p>
<h5 id="agent-requests"><a href="#agent-requests" class="headerlink" title="agent.requests"></a>agent.requests</h5><p>一个对象，包含尚未分配给套接字的请求队列，不要修改。</p>
<h5 id="agent-sockets"><a href="#agent-sockets" class="headerlink" title="agent.sockets"></a>agent.sockets</h5><p>一个对象，包含当前代理正在使用的套接字数组，不要修改。</p>
<h4 id="http-ClientRequest类"><a href="#http-ClientRequest类" class="headerlink" title="http.ClientRequest类"></a>http.ClientRequest类</h4><h4 id="http-Server类"><a href="#http-Server类" class="headerlink" title="http.Server类"></a>http.Server类</h4><h4 id="http-ServerResponse类"><a href="#http-ServerResponse类" class="headerlink" title="http.ServerResponse类"></a>http.ServerResponse类</h4><h4 id="http-IncomingMessage类"><a href="#http-IncomingMessage类" class="headerlink" title="http.IncomingMessage类"></a>http.IncomingMessage类</h4><h4 id="http-METHODS"><a href="#http-METHODS" class="headerlink" title="http.METHODS"></a>http.METHODS</h4><h4 id="http-STATUS-CODES"><a href="#http-STATUS-CODES" class="headerlink" title="http.STATUS_CODES"></a>http.STATUS_CODES</h4><h4 id="http-createServer-options-requestListener"><a href="#http-createServer-options-requestListener" class="headerlink" title="http.createServer([options][, requestListener])"></a>http.createServer([options][, requestListener])</h4><h4 id="http-get-options-callback"><a href="#http-get-options-callback" class="headerlink" title="http.get(options[,callback])"></a>http.get(options[,callback])</h4><h4 id="http-get-url-options-callback"><a href="#http-get-url-options-callback" class="headerlink" title="http.get(url[,options][,callback])"></a>http.get(url[,options][,callback])</h4><h4 id="http-globalAgent"><a href="#http-globalAgent" class="headerlink" title="http.globalAgent"></a>http.globalAgent</h4><h4 id="http-maxHeaderSize"><a href="#http-maxHeaderSize" class="headerlink" title="http.maxHeaderSize"></a>http.maxHeaderSize</h4><h4 id="http-request-options-callback"><a href="#http-request-options-callback" class="headerlink" title="http.request(options[,callback])"></a>http.request(options[,callback])</h4><h4 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[,options][,callback])"></a>http.request(url[,options][,callback])</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之global</title>
    <url>/articles/2020-02-02-node-global.html</url>
    <content><![CDATA[<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>全局变量。</p>
<p>所有模块都提供这些对象。</p>
<h4 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h4><p>用于处理二进制数据。</p>
<h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<a id="more"></a>

<h4 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h4><h4 id="clearInterval-intervalObject"><a href="#clearInterval-intervalObject" class="headerlink" title="clearInterval(intervalObject)"></a>clearInterval(intervalObject)</h4><h4 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h4><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="global-1"><a href="#global-1" class="headerlink" title="global"></a>global</h4><p>在浏览器中，顶层作用域是全局作用域。<br>在nodejs中，顶层作用于不是全局作用域，nodejs模块中的var something的作用域只在该模块内。</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>进程对象。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h4><h4 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[,…args])"></a>setInterval(callback, delay[,…args])</h4><h4 id="setTimeout-callback-delay-…-args"><a href="#setTimeout-callback-delay-…-args" class="headerlink" title="setTimeout(callback, delay[, ….args])"></a>setTimeout(callback, delay[, ….args])</h4><h4 id="TextDecoder"><a href="#TextDecoder" class="headerlink" title="TextDecoder"></a>TextDecoder</h4><h4 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h4><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之fs</title>
    <url>/articles/2020-02-01-node-fs.html</url>
    <content><![CDATA[<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p>文件系统</p>
<p>fs模块提供了一个API，用于模仿标准的POSIX函数的方式与文件系统进行交互。</p>
<p>引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br></pre></td></tr></table></figure>

<p>所有文件系统操作都具有同步和异步的形式；</p>
<a id="more"></a>

<h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>fs操作接受的文件路径可以指定为字符串、Buffer、或使用file：协议的URL对象。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>fs.open()方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、写入数据或请求关于文件的信息。</p>
<h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>所有的文件系统API，除了fs.FSWatcher()和那些显示同步之外，都使用libuv的线程池。</p>
<h4 id="fs-Dir类"><a href="#fs-Dir类" class="headerlink" title="fs.Dir类"></a>fs.Dir类</h4><p>目录流的类。<br>由fs.opendir(), fs.opendirSync()和fsPromises.opendir()创建。</p>
<h5 id="dir-close"><a href="#dir-close" class="headerlink" title="dir.close()"></a>dir.close()</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>返回一个Promise，将会在关闭资源之后被解决。</p>
<h5 id="dir-close-callback"><a href="#dir-close-callback" class="headerlink" title="dir.close(callback)"></a>dir.close(callback)</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>关闭资源句柄之后就会调用callback</p>
<h5 id="dir-closeSync"><a href="#dir-closeSync" class="headerlink" title="dir.closeSync()"></a>dir.closeSync()</h5><p>同步的关闭目录的底层资源句柄。</p>
<h5 id="dir-path"><a href="#dir-path" class="headerlink" title="dir.path"></a>dir.path</h5><p>此目录的只读路径。</p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>代码逐条执行，会阻塞。</p>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.openSync(path, flags[,mode])</span><br></pre></td></tr></table></figure>
<p>写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.writeSync(fd, string[, position[,encoding]])</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.closeSync(fd)</span><br></pre></td></tr></table></figure>

<h5 id="异步文件写入"><a href="#异步文件写入" class="headerlink" title="异步文件写入"></a>异步文件写入</h5><p>代码会一起执行不会阻塞。</p>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.open(path, flags[,mode], callback)</span><br></pre></td></tr></table></figure>
<p>写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.write(fd, string[, position[,encoding]], callback)</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>

<h5 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h5><p>同步异步简单文件的写入不适合大文件的写入，性能较差，容易导致内存溢出，<br>而流式文件写入会一点一点的写进去，不会导致内存溢出的状况。</p>
<p>创建一个可写流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.createWriteStream(path[,options])</span><br></pre></td></tr></table></figure>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; fs.createWriteStream(&#39;hello.txt&#39;)</span><br><span class="line"></span><br><span class="line">监听流可选：</span><br><span class="line">ws.once(&#39;open&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流打开了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#39;close&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流关闭了&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过ws向文件中输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.write(&#39;hhhhhhhh&#39;)</span><br><span class="line">ws.write(&#39;gggggggg&#39;)</span><br></pre></td></tr></table></figure>

<p>关闭流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.end()</span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>将可读流中的内容，直接输出到可写流里。</p>
<h5 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path)"></a>fs.existsSync(path)</h5><p>检查一个文件是否存在。</p>
<h5 id="fs-stat-path-options-callback-fs-statSync-path-options"><a href="#fs-stat-path-options-callback-fs-statSync-path-options" class="headerlink" title="fs.stat(path[,options], callback) / fs.statSync(path[,options])"></a>fs.stat(path[,options], callback) / fs.statSync(path[,options])</h5><p>获取文件状态。</p>
<h5 id="fs-unlink-path-callback-fs-unlinkSync-path"><a href="#fs-unlink-path-callback-fs-unlinkSync-path" class="headerlink" title="fs.unlink(path, callback) / fs.unlinkSync(path)"></a>fs.unlink(path, callback) / fs.unlinkSync(path)</h5><p>删除文件。</p>
<h5 id="fs-readdir-path-options-callback-fs-readdirSync-path-options"><a href="#fs-readdir-path-options-callback-fs-readdirSync-path-options" class="headerlink" title="fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])"></a>fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])</h5><p>读取一个目录的目录结构。</p>
<h5 id="fs-truncate-path-len-callback-fs-truncateSync-path-len"><a href="#fs-truncate-path-len-callback-fs-truncateSync-path-len" class="headerlink" title="fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])"></a>fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])</h5><p>截断文件。</p>
<h5 id="fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode"><a href="#fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode" class="headerlink" title="fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])"></a>fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])</h5><p>创建一个文件夹。</p>
<h5 id="fs-rmdir-path-callback-fs-rmdirSync-path"><a href="#fs-rmdir-path-callback-fs-rmdirSync-path" class="headerlink" title="fs.rmdir(path, callback) / fs.rmdirSync(path)"></a>fs.rmdir(path, callback) / fs.rmdirSync(path)</h5><p>删除一个目录。</p>
<h5 id="fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath"><a href="#fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath" class="headerlink" title="fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)"></a>fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)</h5><p>重命名文件夹。</p>
<h5 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[,options], listener)"></a>fs.watchFile(filename[,options], listener)</h5><p>监视文件的修改。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之events</title>
    <url>/articles/2020-02-01-node-events.html</url>
    <content><![CDATA[<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>事件触发器。</p>
<p>eventEmitter.on()：用于注册监听器；<br>eventEmitter.emit()：用于触发事件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line"></span><br><span class="line">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="将参数和this传给监听器"><a href="#将参数和this传给监听器" class="headerlink" title="将参数和this传给监听器"></a>将参数和this传给监听器</h4><p>eventEmitter.emit()方法可以传任意数量的参数到监听器函数。<br>当监听器函数被调用时，this关键词被指向监听器所绑定的EventEmitter实例。<br>当使用ES6de箭头函数作为监听器，this不会指向EventEmitter实例。</p>
<h4 id="异步-VS-同步"><a href="#异步-VS-同步" class="headerlink" title="异步 VS 同步"></a>异步 VS 同步</h4><p>EventEmitter以注册的顺序同步调用所有监听器。<br>监听器函数可以使用setImmediate()和process.nextTick()方法切换到异步的操作模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;异步地发生&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="仅处理事件一次"><a href="#仅处理事件一次" class="headerlink" title="仅处理事件一次"></a>仅处理事件一次</h4><p>eventEmitter.on()注册监听器时，监听器会在每次触发命名事件时调用。<br>eventEmitter.once()可以注册最多可调用一次的监听器，当事件被触发时，监听器会被注销，然后再调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">let m &#x3D; 0;</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 2</span><br><span class="line"></span><br><span class="line">myEmitter.once(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 不触发</span><br></pre></td></tr></table></figure>

<h4 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h4><p>EventEmitter实例出错时，应该触发error事件，<br>如果没有为error事件注册监听器，当error事件触发时，会抛出错误、打印堆栈跟踪、并退出Node进程。</p>
<p>为了防止崩溃Node进程，可以使用domain模块，不推荐。<br>最佳是应该始终为error事件注册监听器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;错误信息&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;error&#39;, new Error(&#39;错误&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印: 错误信息</span><br></pre></td></tr></table></figure>

<h4 id="EventEmitter类"><a href="#EventEmitter类" class="headerlink" title="EventEmitter类"></a>EventEmitter类</h4><p>由events模块定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br></pre></td></tr></table></figure>
<p>当新增监听器时，会触发newListener事件；<br>当移除已存在的监听器时，则触发removeListener事件；</p>
<p>emitter.addListener(eventName, listener)：emitter.on(eventName, listener)的别名。<br>emitter.emit(eventName[, …args])：按照监听器注册的顺序，同步调用每个注册到名为eventName事件的监听器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const myEmitter &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function firstListener() &#123;</span><br><span class="line">  console.log(&#39;第一个监听器&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第二个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function secondListener(arg1, arg2) &#123;</span><br><span class="line">  console.log(&#96;第二个监听器中的事件有参数 $&#123;arg1&#125;、$&#123;arg2&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第三个监听器</span><br><span class="line">myEmitter.on(&#39;event&#39;, function thirdListener(...args) &#123;</span><br><span class="line">  const parameters &#x3D; args.join(&#39;, &#39;);</span><br><span class="line">  console.log(&#96;第三个监听器中的事件有参数 $&#123;parameters&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(myEmitter.listeners(&#39;event&#39;));</span><br><span class="line"></span><br><span class="line">myEmitter.emit(&#39;event&#39;, 1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;   [Function: firstListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: secondListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: thirdListener]</span><br><span class="line">&#x2F;&#x2F; ]</span><br><span class="line">&#x2F;&#x2F; 第一个监听器</span><br><span class="line">&#x2F;&#x2F; 第二个监听器中的事件有参数 1、2</span><br><span class="line">&#x2F;&#x2F; 第三个监听器中的事件有参数 1, 2, 3, 4, 5</span><br></pre></td></tr></table></figure>

<p>emitter.eventNames()：返回已注册监听器的事件名数组。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之error</title>
    <url>/articles/2020-02-01-node-error.html</url>
    <content><![CDATA[<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>错误。</p>
<p>NodeJs应用程序一般会有四种错误：</p>
<ul>
<li>标准的JavaScript错误；</li>
<li>由底层操作系统触发的系统错误；</li>
<li>由应用程序代码触发的用户自定义的错误；</li>
<li>AssertionError错误，当Node监测到不应该发生的异常逻辑时触发，这类错误通常来自assert模块；</li>
</ul>
<p>所有由Nodejs引起的Javascript错误与系统错误都继承自或实例化自标准的JavaScript<Error>类，<br>且保证至少提供类中的属性。</p>
<a id="more"></a>

<h4 id="错误的冒泡和捕获"><a href="#错误的冒泡和捕获" class="headerlink" title="错误的冒泡和捕获"></a>错误的冒泡和捕获</h4><p>异常捕获处理<code>try...catch</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抛出一个 ReferenceError，因为 z 未定义。</span><br><span class="line">try &#123;</span><br><span class="line">  const m &#x3D; 1;</span><br><span class="line">  const n &#x3D; m + z;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在这里处理错误。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调中的Error参数"><a href="#回调中的Error参数" class="headerlink" title="回调中的Error参数"></a>回调中的Error参数</h4><p>大多数Nodejs核心API所提供的异步方法都遵从错误信息优先的回调模式惯例，这种模式有时也称为Nodejs回调。</p>
<p>但JavaScript的try…catch机制不能用来截获异步方法产生的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">     setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异常错误，这是因为异步函数执行上下文不同，所以捕获不到。</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了捕获异步产生的异常错误，可以用domain模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var domain &#x3D; require(&#39;domain&#39;);</span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line">d.run(function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异步异常</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    console.log(err); &#x2F;&#x2F; 这里可以捕获异步异常</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者express挂载接受error函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function (err,req,res,next)&#123;</span><br><span class="line">   &#x2F;&#x2F;前面的中间件的错误next(err),都在这里接收。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>new Error(message)：新建一个Error实例，创建一个异常错误对象；<br>throw new Error(message)：创建一个对象并抛出错误，如果不捕获则node崩溃；</p>
<p>error.code：标识错误类别的字符标签；<br>error.message：错误描述；<br>error.stack：一个字符串；</p>
<h4 id="AssertionError类"><a href="#AssertionError类" class="headerlink" title="AssertionError类"></a>AssertionError类</h4><p>表明断言的失败。</p>
<h4 id="ReferenceError类"><a href="#ReferenceError类" class="headerlink" title="ReferenceError类"></a>ReferenceError类</h4><p>表明试图访问一个未定义的变量。<br>此类错误通常表明代码有拼写错误或程序已损坏。</p>
<h4 id="SyntaxError类"><a href="#SyntaxError类" class="headerlink" title="SyntaxError类"></a>SyntaxError类</h4><p>表明程序不是有效的JavaScript。</p>
<h4 id="TypeError类"><a href="#TypeError类" class="headerlink" title="TypeError类"></a>TypeError类</h4><p>表明提供的参数不是被允许的类型。</p>
<h4 id="NodeJs中常用的异常处理方式"><a href="#NodeJs中常用的异常处理方式" class="headerlink" title="NodeJs中常用的异常处理方式"></a>NodeJs中常用的异常处理方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每秒钟打印一次时间，确保程序没有奔溃</span><br><span class="line">(function loop() &#123;</span><br><span class="line">    console.log(new Date().getTime())</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        loop() </span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 模拟同步代码块内出现异常</span><br><span class="line">let syncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;Sync Error&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 模拟异步代码块内出现异常</span><br><span class="line">let asyncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;Async Error&#39;)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">try &#123;</span><br><span class="line">    syncError()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;异常被捕获了，我可以继续执行&#39;)</span><br><span class="line"></span><br><span class="line">2. callback方式</span><br><span class="line">fs.mkdir(&#39;&#x2F;dir&#39;, function (e) &#123;</span><br><span class="line">    if (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;创建目录成功&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3. event方式</span><br><span class="line">let events &#x3D; require(&quot;events&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个事件监听对象</span><br><span class="line">let emitter &#x3D; new events.EventEmitter();</span><br><span class="line">&#x2F;&#x2F;监听error事件</span><br><span class="line">emitter.addListener(&quot;error&quot;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发error事件</span><br><span class="line">emitter.emit(&quot;error&quot;, new Error(&#39;出错啦&#39;));</span><br><span class="line"></span><br><span class="line">4. Promise方式</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    syncError()</span><br><span class="line">    &#x2F;* or</span><br><span class="line">    try&#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">Promise同样无法处理异步代码块中抛出的异常</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    asyncError()</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*异常无法被捕获,导致进程退出*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">5. Async&#x2F;Await方式</span><br><span class="line">var sleep &#x3D; function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await sleep(100);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">6. process方式（可以捕获任何异常，但过于笨重）</span><br><span class="line">process.on(&#39;uncaughtException&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">asyncError()</span><br><span class="line">syncError()</span><br><span class="line"></span><br><span class="line">7. domain方式（也可以处理任何异常模块）</span><br><span class="line">let domain &#x3D; require(&#39;domain&#39;)</span><br><span class="line">let d &#x3D; domain.create()</span><br><span class="line">d.on(&#39;error&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">d.run(asyncError)</span><br><span class="line">d.run(syncError)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之domain</title>
    <url>/articles/2020-02-01-node-domain.html</url>
    <content><![CDATA[<h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h2><p>域。<br>简化了异步代码的异常处理，可以捕捉try catch无法捕捉的异常。</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const domain &#x3D; require(&#39;domain&#39;)</span><br></pre></td></tr></table></figure>
<p>domain模块把处理多个不同的IO操作为一个组。<br>当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不会导致程序错误立即退出、</p>
<h4 id="显示绑定和隐式绑定"><a href="#显示绑定和隐式绑定" class="headerlink" title="显示绑定和隐式绑定"></a>显示绑定和隐式绑定</h4><p>显示绑定：把不是在domain上下文中定义的变量，以代码的方式绑定到domain。<br>隐式绑定：把在domain上下文中定义的变量，自动绑定到domain对象。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>domain.members：已加入domain对象的域定时器和事件发射器的数组。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>domain.run(function)：在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</p>
<p>doamin.add(emitter)：显示的增加事件。</p>
<p>doamin.remove(emitter)：删除事件。</p>
<p>domain.bind(callback)：返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数时，所有被抛出的错误都会被导向到这个域的error事件。</p>
<p>domain.intercept(callback)：和bind类似，除了捕捉错误外，它还会拦截error对象作为参数传递到这个函数。</p>
<p>domain.enter()：进入一个异步调用的上下文，绑定到domain。</p>
<p>domain.exit()：退出当前的domain，切换到不同的链的异步调用的上下文中。</p>
<p>domain.dispose()：释放一个domain对象，让node进程回收这部分资源。</p>
<p>domain.create()：返回一个domain对象。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之dns</title>
    <url>/articles/2020-02-01-node-dns.html</url>
    <content><![CDATA[<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>域名服务器。</p>
<p>dns模块包含了两个不同类别的函数：<br>1、使用底层操作系统工具执行名称解析但不一定执行任何网络通信的函数。<br>此类别仅包含一个函数：dns.lookup()。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.lookup(&#39;iana.org&#39;, (err, address, family) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;地址: %j 地址族: IPv%s&#39;, address, family);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 地址: &quot;192.0.43.8&quot; 地址族: IPv4</span><br></pre></td></tr></table></figure>

<p>2、连接到实际的DNS服务器以执行名称解析并始终使用网络执行DNS查询的函数。包含dns模块中除dns.lookup()之外的所有函数。<br>这些函数不使用与dns.lookup()使用的同一配置文件。<br>这些函数应该由不希望使用底层系统的工具进行名称解析、而始终执行dns查询的开发者使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.resolve4(&#39;archive.org&#39;, (err, addresses) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;地址: $&#123;JSON.stringify(addresses)&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  addresses.forEach((a) &#x3D;&gt; &#123;</span><br><span class="line">    dns.reverse(a, (err, hostnames) &#x3D;&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        throw err;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#96;地址 $&#123;a&#125; 逆向解析到域名: $&#123;JSON.stringify(hostnames)&#125;&#96;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200120172840178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vXzI0Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200120174218212.png" alt="在这里插入图片描述"></p>
<h3 id="rrtypes"><a href="#rrtypes" class="headerlink" title="rrtypes"></a>rrtypes</h3><p>dns.resolve() 方法中有效的 rrtypes值:</p>
<ul>
<li>‘A’ IPV4 地址, 默认；</li>
<li>‘AAAA’ IPV6 地址；</li>
<li>‘MX’ 邮件交换记录；</li>
<li>‘TXT’ text 记录；</li>
<li>‘SRV’ SRV 记录；</li>
<li>‘PTR’ 用来反向 IP 查找；</li>
<li>‘NS’ 域名服务器记录；</li>
<li>‘CNAME’ 别名记录；</li>
<li>‘SOA’ 授权记录的初始值；</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之dgram</title>
    <url>/articles/2020-02-01-node-dgram.html</url>
    <content><![CDATA[<h2 id="dgram"><a href="#dgram" class="headerlink" title="dgram"></a>dgram</h2><p>dgram数据报提供了UDP数据包socket的实现。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">创建dgram.Sockrt的新实例，不使用new</span><br><span class="line">const server &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line"></span><br><span class="line">error发生错误时触发</span><br><span class="line">server.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器异常：\n$&#123;err.stack&#125;&#96;);</span><br><span class="line">  关闭一个socket之后触发，一旦触发，则这个socket上将不会触发新的message事件。</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">当有新的数据包被socket接收时，message事件会被触发</span><br><span class="line">server.on(&#39;message&#39;, (msg, rinfo) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器接收到来自 $&#123;rinfo.address&#125;:$&#123;rinfo.port&#125; 的 $&#123;msg&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">开始监听数据包信息时触发</span><br><span class="line">server.on(&#39;listening&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  const address &#x3D; server.address();</span><br><span class="line">  console.log(&#96;服务器监听 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.bind(41234);</span><br><span class="line">&#x2F;&#x2F; 服务器监听 0.0.0.0:41234</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>addMembership()<br>  添加组播成员；</li>
<li>dropMembership()<br>  删除组播成员；</li>
<li>address()<br>  返回socket地址信息对象，UDP socket对象包含address、family和port属性；</li>
<li>bind()<br>  绑定端口和主机。<br>  若端口未指定，操作系统绑定一个随机的端口；<br>  若address未指定，操作系统会尝试在所有地址上监听；</li>
<li>close()<br>  关闭该socket并停止监听其上的数据。</li>
<li>connect()<br>  关联一个远程地址和端口。</li>
<li>disconnect()<br>  与远程地址断掉的同步函数。</li>
<li>ref()<br>将socket重新添加到这个引用列表中，并恢复默认行为。</li>
<li>unref()<br>将socket从node进程的引用列表中删除。<br>socket对象不再进行通信，程序会退出。<br>即使socket对象还在坚挺数据，也允许退出。</li>
<li>send()<br>在socket上广播数据报。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">const message &#x3D; Buffer.from(&#39;一些字节&#39;);</span><br><span class="line">const client &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line">client.send(message, 41234, &#39;localhost&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>setTTL()<br>  设置数据报生存时间</li>
<li>setMulticastTTL()<br>  设置组播数据报生存时间</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之crypto</title>
    <url>/articles/2020-02-01-node-crypto.html</url>
    <content><![CDATA[<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><p>crypto模块提供了加密脑功能，包括对OpenSSL的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装。</p>
<p>下面整理了一些平常经常用到的加密解密方法：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const Crypto &#x3D; require(&#39;cryptojs&#39;).Crypto</span><br><span class="line">const _crypto &#x3D; require(&#39;crypto&#39;)</span><br><span class="line">const cryptoJS &#x3D; require(&#39;crypto-js&#39;)</span><br><span class="line">const mode &#x3D; new Crypto.mode.CBC(Crypto.pad.pkcs7)</span><br><span class="line">const bytes &#x3D; require(&#39;utf8-bytes&#39;)</span><br><span class="line">const aesKey &#x3D; &#39;&#39;</span><br><span class="line">const aesIv &#x3D; &#39;&#39;</span><br><span class="line">const algorithm &#x3D; &#39;aes-128-cbc&#39;</span><br><span class="line"></span><br><span class="line">1. sha1</span><br><span class="line">function sha1Sign(src) &#123;</span><br><span class="line">    const sha1 &#x3D; crypto.createHash(&#39;sha1&#39;);</span><br><span class="line">    sha1.update(src);</span><br><span class="line">    return sha1.digest(&#39;hex&#39;).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function makeSalt() &#123;</span><br><span class="line">    return crypto.randomBytes(16).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. hash</span><br><span class="line">function hashPassword(password, salt) &#123;</span><br><span class="line">    assert(password &amp;&amp; salt, &#39;pwd or salt missing&#39;);</span><br><span class="line">    const _salt &#x3D; new Buffer(salt, &#39;base64&#39;);</span><br><span class="line">    return crypto.pbkdf2Sync(password, _salt, 10000, 64).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. dec</span><br><span class="line">const algorithm &#x3D; &#39;aes-256-ctr&#39;,</span><br><span class="line">    password &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">function encrypt(buffer)&#123;</span><br><span class="line">    let cipher &#x3D; crypto.createCipher(algorithm,password)</span><br><span class="line">    let crypted &#x3D; Buffer.concat([cipher.update(buffer),cipher.final()]);</span><br><span class="line">    return crypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt(buffer)&#123;</span><br><span class="line">    let decipher &#x3D; crypto.createDecipher(algorithm,password)</span><br><span class="line">    let dec &#x3D; Buffer.concat([decipher.update(buffer) , decipher.final()]);</span><br><span class="line">    return dec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. des-cbc</span><br><span class="line">const desIv &#x3D; &#39;\1\2\3\4\5\6\7\x08&#39;; (在不同的语言对初始向量的处理方式不同会造成解密不完全、乱码等，需要初始向量的表现形式)</span><br><span class="line"></span><br><span class="line">function desCreateCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv ? desIv : 0);</span><br><span class="line">    &#x2F;&#x2F; encrypt</span><br><span class="line">    let cipher &#x3D; crypto.createCipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    cipher.setAutoPadding(true);</span><br><span class="line">    let ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;hex&#39;);</span><br><span class="line">    return ciph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desDecryptCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv);</span><br><span class="line">    const decipher &#x3D; crypto.createDecipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    decipher.setAutoPadding(true);</span><br><span class="line">    let txt &#x3D; decipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    txt +&#x3D; decipher.final(&#39;utf8&#39;);</span><br><span class="line">    return txt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. des-ecb</span><br><span class="line">function desEcbEncrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createCipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;base64&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desEcbDecrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createDecipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;utf8&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7. md5</span><br><span class="line">function md5(Str) &#123;</span><br><span class="line">    var md5sum &#x3D; _crypto.createHash(&#39;md5&#39;)</span><br><span class="line">    md5sum.update(new Buffer(Str))</span><br><span class="line">    return md5sum.digest(&#39;hex&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5to16(Str) &#123;</span><br><span class="line">    let res &#x3D; md5(Str)</span><br><span class="line">    return res.substring(8, 24)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8. dec</span><br><span class="line">function encrypt(plaintext, key) &#123;</span><br><span class="line">    var ub &#x3D; Crypto.charenc.UTF8.stringToBytes(plaintext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var eb &#x3D; Crypto.AES.encrypt(ub, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.util.bytesToBase64(eb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt (ciphertext, key) &#123;</span><br><span class="line">    var eb &#x3D; Crypto.util.base64ToBytes(ciphertext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var ub &#x3D; Crypto.AES.decrypt(eb, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.charenc.UTF8.bytesToString(ub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateKey (buffer) &#123;</span><br><span class="line">    if (buffer) return Crypto.util.bytesToBase64(buffer)</span><br><span class="line">    return Crypto.util.bytesToBase64(Crypto.util.randomBytes(16))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateEpubKey(chapterName) &#123;</span><br><span class="line">    let key &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.key&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.key&#125;&#96;)</span><br><span class="line">    let IV &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.IV&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.IV&#125;&#96;)</span><br><span class="line">    return IV + key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function encryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createCipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createDecipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipher(ciphertext) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipher(data) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(data, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dictSort(obj) &#x3D;&gt; &#123;</span><br><span class="line">    const sorted &#x3D; Object.keys(obj).sort();</span><br><span class="line">    let str &#x3D; &#39;&#39;;</span><br><span class="line">    sorted.forEach((key) &#x3D;&gt; str +&#x3D; obj[key]);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherIv (plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherHexIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;hex&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherHexIv(plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;) + cip.final(&#39;hex&#39;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接请求字符串并加密</span><br><span class="line">function hmacSHA256 (content, appKey) &#123;</span><br><span class="line">    return cryptoJS.enc.Hex.stringify(cryptoJS.HmacSHA256(content, appKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9. AES解密 </span><br><span class="line">function aesDecrypt(content, keys, ivs) &#123;</span><br><span class="line">    const key &#x3D; cryptoJS.enc.Utf8.parse(keys);</span><br><span class="line">    const iv &#x3D; cryptoJS.enc.Utf8.parse(ivs);</span><br><span class="line">    const encryptedHexStr &#x3D; cryptoJS.enc.Hex.parse(content);</span><br><span class="line">    const srcs &#x3D; cryptoJS.enc.Base64.stringify(encryptedHexStr);</span><br><span class="line">    const decrypt &#x3D; cryptoJS.AES.decrypt(srcs, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: cryptoJS.mode.CBC,</span><br><span class="line">        padding: cryptoJS.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    const decryptedStr &#x3D; decrypt.toString(cryptoJS.enc.Utf8);</span><br><span class="line">    return decryptedStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之cluster</title>
    <url>/articles/2020-02-01-node-cluster.html</url>
    <content><![CDATA[<h2 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h2><p>集群<br>单个Nodejs实例运行在单个线程中，为充分利用多核系统，需要启用一组Node进程处理负载任务。</p>
<p>cluster允许建立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。<br>worker之间采用进程通信交换消息，cluster模块内置一个负载均衡。</p>
<p>cluster集成两个方面：</p>
<ul>
<li>集成了child_process.fork方法创建node子进程的方式；</li>
<li>继承了很多多核cpu创建子进程后，自动控制负载均衡的方式；</li>
</ul>
<a id="more"></a>

<p>cluster模块可以创建共享服务器端口的子进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const numCPUs &#x3D; require(&#39;os&#39;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#96;主进程 $&#123;process.pid&#125; 正在运行&#96;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 衍生工作进程。</span><br><span class="line">  for (let i &#x3D; 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作进程 $&#123;worker.process.pid&#125; 已退出&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程可以共享任何 TCP 连接。</span><br><span class="line">  &#x2F;&#x2F; 在本例子中，共享的是 HTTP 服务器。</span><br><span class="line">  http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end(&#39;你好世界\n&#39;);</span><br><span class="line">  &#125;).listen(8000);</span><br><span class="line"></span><br><span class="line">  console.log(&#96;工作进程 $&#123;process.pid&#125; 已启动&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主进程 3596 正在运行</span><br><span class="line">工作进程 4324 已启动</span><br><span class="line">工作进程 4520 已启动</span><br><span class="line">工作进程 6056 已启动</span><br><span class="line">工作进程 5644 已启动</span><br></pre></td></tr></table></figure>

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>cluster支持两种分发连接方法：</p>
<ol>
<li>循环法，由主进程负责监听端口，接收新连接后再将连接循环发给工作进程，在分发中使用了一些内置技巧防止工作进程中任务过载；</li>
<li>主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接；</li>
</ol>
<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker对象包含了关于工作进程的所有的公共的信息和方法。<br>主进程中，使用cluster.workers获取<br>工作进程中，使用cluster.worker获取</p>
<h4 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>断开连接</p>
<h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><p>工作进程中，可以使用process.on(‘error’)</p>
<h4 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const worker &#x3D; cluster.fork();</span><br><span class="line">worker.on(&#39;exit&#39;, (code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (signal) &#123;</span><br><span class="line">    console.log(&#96;工作进程已被信号 $&#123;signal&#125; 杀死&#96;);</span><br><span class="line">  &#125; else if (code !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    console.log(&#96;工作进程退出，退出码: $&#123;code&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;工作进程成功退出&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="listening事件"><a href="#listening事件" class="headerlink" title="listening事件"></a>listening事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.fork().on(&#39;listening&#39;, (address) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程正在监听。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h4><p>在工作进程内，也可以使用 process.on(‘message’)</p>
<h4 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.fork().on(&#39;online&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程已上线。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="worker-disconnect"><a href="#worker-disconnect" class="headerlink" title="worker.disconnect()"></a>worker.disconnect()</h4><p>在一个工作进程内，调用此方法会关闭所有的 server，并等待这些 server 的 ‘close’ 事件执行，然后关闭 IPC 管道。</p>
<p>在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用 .disconnect()</p>
<h4 id="worker-exitedAfterDisconnect"><a href="#worker-exitedAfterDisconnect" class="headerlink" title="worker.exitedAfterDisconnect"></a>worker.exitedAfterDisconnect</h4><p>如果工作进程由于 .kill() 或 .disconnect() 而退出，则此属性为 true。<br>如果工作进程以任何其他方式退出，则为 false。<br>如果工作进程尚未退出，则为 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (worker.exitedAfterDisconnect &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">    console.log(&#39;这是自发退出，无需担心&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 杀死工作进程。</span><br><span class="line">worker.kill();</span><br></pre></td></tr></table></figure>

<h4 id="worker-id"><a href="#worker-id" class="headerlink" title="worker.id"></a>worker.id</h4><p>每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。</p>
<h4 id="worker-isConnected"><a href="#worker-isConnected" class="headerlink" title="worker.isConnected()"></a>worker.isConnected()</h4><p>当工作进程通过 IPC 管道连接至主进程时，这个方法返回 true，否则返回 false。<br>一个工作进程在创建后会自动连接到它的主进程。<br>当 ‘disconnect’ 事件被触发时才会断开连接。</p>
<h4 id="worker-isDead"><a href="#worker-isDead" class="headerlink" title="worker.isDead()"></a>worker.isDead()</h4><p>当工作进程被终止时（包括自动退出或被发送信号），这个方法返回 true。 否则，返回 false。</p>
<h4 id="worker-kill-signal-’SIGTERM’"><a href="#worker-kill-signal-’SIGTERM’" class="headerlink" title="worker.kill([signal=’SIGTERM’])"></a>worker.kill([signal=’SIGTERM’])</h4><p>杀死工作进程。<br>主进程，通过断开与worker.process的连接来实现，一旦断开连接，通过signal杀死工作进程；<br>工作进程，通过断开IPC管道来实现，然后以代码0退出进程；</p>
<h4 id="worker-process"><a href="#worker-process" class="headerlink" title="worker.process"></a>worker.process</h4><p>所有的工作都通过child_process.fork()创建，返回的对象被存储为.process。工作进程中，process属于全局对象。</p>
<p>当process发生disconnect事件，且.exitedAfterDisconnect的值不是true时，工作进程会调用process.exit(0)来防止连接意外断开。</p>
<h4 id="worker-send"><a href="#worker-send" class="headerlink" title="worker.send()"></a>worker.send()</h4><p>发送消息给主进程或工作进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  const worker &#x3D; cluster.fork();</span><br><span class="line">  worker.send(&#39;你好&#39;);</span><br><span class="line"></span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  process.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">    process.send(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="disconnect事件-1"><a href="#disconnect事件-1" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>工作进程的IPC管道被断开后触发。<br>可能导致触发的原因：</p>
<ul>
<li><p>工作进程优雅的退出；</p>
</li>
<li><p>被杀死；</p>
</li>
<li><p>手动断开连接；</p>
<p>‘disconnect’ 和 ‘exit’ 事件之间可能存在延迟。 这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;disconnect&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;工作进程 #$&#123;worker.id&#125; 已断开连接&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="exit事件-1"><a href="#exit事件-1" class="headerlink" title="exit事件"></a>exit事件</h4><p>当任何一个工作进程关闭的时候，cluster模块都会触发exit事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程 %d 关闭 (%s). 重启中...&#39;,</span><br><span class="line">              worker.process.pid, signal || code);</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="fork事件"><a href="#fork事件" class="headerlink" title="fork事件"></a>fork事件</h4><p>当新的工作进程被衍生时，cluster触发fork事件。<br>可以被用来记录工作进程活动，并产生一个自定义的超时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timeouts &#x3D; [];</span><br><span class="line">function errorMsg() &#123;</span><br><span class="line">  console.error(&#39;连接出错&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cluster.on(&#39;fork&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  timeouts[worker.id] &#x3D; setTimeout(errorMsg, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">  errorMsg();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="listening事件-1"><a href="#listening事件-1" class="headerlink" title="listening事件"></a>listening事件</h4><p>当工作进程调用listen()后，工作进程上的server会触发listening事件，<br>同时主进程上的cluster会触发listening事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker 包含了工作进程对象</span><br><span class="line">address 包含了以下的连接属性：address、 port 和 addressType。 </span><br><span class="line"></span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;工作进程已连接到 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>addressType 可选值包括:</p>
<ul>
<li>4 (TCPv4) </li>
<li>6 (TCPv6)</li>
<li>-1 (Unix 域 socket)</li>
<li>‘udp4’ or ‘udp6’ (UDP v4 或 v6)</li>
</ul>
<h4 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h4><p>当集群主进程从任何工作进程接收到消息时触发。</p>
<h4 id="online事件-1"><a href="#online事件-1" class="headerlink" title="online事件"></a>online事件</h4><p>当衍生一个新的工作进程后，工作进程会响应一个上线消息。<br>当主进程收到上线消息后悔触发此事件。</p>
<p>当主进程衍生工作进程时触发fork；<br>当工作进程运行时触发online；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;online&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程被衍生后响应&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="setup事件"><a href="#setup事件" class="headerlink" title="setup事件"></a>setup事件</h4><p>每当.setupMaster()被调用时触发。</p>
<h4 id="cluster-disconnect"><a href="#cluster-disconnect" class="headerlink" title="cluster.disconnect()"></a>cluster.disconnect()</h4><p>cluster.workers的每个工作进程中调用.disconnect()</p>
<h4 id="cluster-fork"><a href="#cluster-fork" class="headerlink" title="cluster.fork()"></a>cluster.fork()</h4><p>衍生出一个新的工作进程，只能通过主进程调用。</p>
<h4 id="cluster-isMaster"><a href="#cluster-isMaster" class="headerlink" title="cluster.isMaster"></a>cluster.isMaster</h4><p>如果进程是主进程，则为true。</p>
<h4 id="cluster-isWorker"><a href="#cluster-isWorker" class="headerlink" title="cluster.isWorker"></a>cluster.isWorker</h4><p>如果进程不是主进程，则为true。</p>
<h4 id="cluster-schdulingPolicy"><a href="#cluster-schdulingPolicy" class="headerlink" title="cluster.schdulingPolicy"></a>cluster.schdulingPolicy</h4><p>调度策略。</p>
<h4 id="cluster-settings"><a href="#cluster-settings" class="headerlink" title="cluster.settings"></a>cluster.settings</h4><p>调用.setupMaster()或.fork()之后，这个配置对象将会包含这些配置项，包括默认值。</p>
<h4 id="cluster-setupMaster"><a href="#cluster-setupMaster" class="headerlink" title="cluster.setupMaster()"></a>cluster.setupMaster()</h4><p>setupMaster用于修改默认的fork行为，一旦调用，会按照cluster.settings进行设置。<br>所有的设置只对后来的.fork()调用有效，对之前的工作进程无影响。<br>唯一无法通过.setupMaster()设置的属性是传给.fork()的env属性。<br>只能由主进程调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上述的默认值只在第一次调用时有效，当后续调用时，将采用 cluster.setupMaster() 调用时的当前值。</span><br><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;https&#39;],</span><br><span class="line">  silent: true</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; https 工作进程</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;http&#39;]</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; http 工作进程</span><br></pre></td></tr></table></figure>

<h4 id="cluster-worker"><a href="#cluster-worker" class="headerlink" title="cluster.worker"></a>cluster.worker</h4><p>当前工作进程对象的引用，对于主进程是无用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#39;这是主进程&#39;);</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  console.log(&#96;这是工作进程 #$&#123;cluster.worker.id&#125;&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cluster-workers"><a href="#cluster-workers" class="headerlink" title="cluster.workers"></a>cluster.workers</h4><p>一个哈希表，储存了活跃的工作进程对象，id作为键名。<br>只能在主进程中调用。<br>工作进程断开连接及退出后，将会从cluster.workers里面移除。<br>移除工作在disconnect和exit两个事件中的最后一个触发之前完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历所有工作进程。</span><br><span class="line">function eachWorker(callback) &#123;</span><br><span class="line">  for (const id in cluster.workers) &#123;</span><br><span class="line">    callback(cluster.workers[id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">eachWorker((worker) &#x3D;&gt; &#123;</span><br><span class="line">  worker.send(&#39;通知所有工作进程&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">使用工作进程的唯一 id 是定位工作进程最简单的方式。</span><br><span class="line">socket.on(&#39;data&#39;, (id) &#x3D;&gt; &#123;</span><br><span class="line">  const worker &#x3D; cluster.workers[id];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之child_process</title>
    <url>/articles/2020-02-01-node-child-process.html</url>
    <content><![CDATA[<h2 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h2><p>child_process提供了衍生子进程的能力。</p>
<p>node单线程的问题就是会导致无法充分利用CPU等资源，通过child_process实现子进程，从而实现1个主进程(master)，多个子进程的模式(工作进程)。</p>
<a id="more"></a>

<h4 id="创建异步的子进程"><a href="#创建异步的子进程" class="headerlink" title="创建异步的子进程"></a>创建异步的子进程</h4><ul>
<li><p>child_process.exec(command[, options][, callback])<br>执行的是非node程序，是一个shell命令，执行结果以回调的形式返回。</p>
<p>  【注意】</p>
<pre><code> 1、command 是一个 shell 命令的字符串，一般是 shell 内置的 命令或shell脚本组成的文件，如 ls、cat、start.sh等，包含了命令的参数；
2、可以使用 callback；
3、执行成功，error为null；失败，error为Error的实例，error.code为错误码；
4、若timeout大于0，则当子进程运行超过timeout毫秒，会给进程发送killSignal指定的信号；</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">exec(&#39;cat *.js missing_file | wc -l&#39;, (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.error(&#96;执行的错误: $&#123;error&#125;&#96;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#96;stdout: $&#123;stdout&#125;&#96;);</span><br><span class="line">  console.error(&#96;stderr: $&#123;stderr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const exec &#x3D; util.promisify(require(&#39;child_process&#39;).exec);</span><br><span class="line"></span><br><span class="line">async function lsExample() &#123;</span><br><span class="line">  const &#123; stdout, stderr &#125; &#x3D; await exec(&#39;ls&#39;);</span><br><span class="line">  console.log(&#39;stdout:&#39;, stdout);</span><br><span class="line">  console.error(&#39;stderr:&#39;, stderr);</span><br><span class="line">&#125;</span><br><span class="line">lsExample();</span><br></pre></td></tr></table></figure>
</li>
<li><p>child_process.execFile(file[, args][, options][, callback])<br>执行的是非node程序，是一个可执行文件或应用，执行结果以回调的形式返回。</p>
<p> 【注意】<br> 1、比exec更高效，更安全；<br> 2、命令的参数只能作为第二个参数传递；<br> 3、默认情况下不会衍生 shell（和exec的最大差别），指定的可执行 file 直接作为新进程衍生；<br> 3、file 是要运行的可执行文件的名称或路径，如 node.exe，不能是 start.js 这种脚本文件；<br> 4、不支持I/O重定向，文件glob等；</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; execFile &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const execFile &#x3D; util.promisify(require(&#39;child_process&#39;).execFile);</span><br><span class="line">async function getVersion() &#123;</span><br><span class="line">  const &#123; stdout &#125; &#x3D; await execFile(&#39;node&#39;, [&#39;--version&#39;]);</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;</span><br><span class="line">getVersion();</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>child_process.spawn(command[, args][, options])<br>执行的是非node程序，是一个shell命令，不需要获取执行结果，执行结果以流的形式返回。</p>
<p> 【注意】<br> 1、 使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数，默认是空数组；<br> 2、以流的形式，可以减少内存占用提高输入输出效率；</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 检查失败的spawn</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const subprocess &#x3D; spawn(&#39;bad_command&#39;);</span><br><span class="line"></span><br><span class="line">subprocess.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;启动子进程失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. 运行ls -lh &#x2F;usr，并捕获stdout、stderr、退出码</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const ls &#x3D; spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;&#x2F;usr&#39;]);</span><br><span class="line"></span><br><span class="line">ls.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;stdout: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#96;stderr: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.on(&#39;close&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;子进程退出，退出码 $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>child_process.fork(modulePath[, args][, options])<br>执行的是node程序，是一个.js文件，不需要获取执行结果，执行结果以流的形式返回，fork出来的进程一定是node进程。</p>
<p>  【注意】<br> 1、专门用于衍生新的 node进程；<br> 2、返回子进程ChildProcess对象，并内置为一个额外的IPC通信通道，允许消息在父进程和子进程之间来回传递，子进程独立于父进程；<br> 3、modulePath 要在node子进程中运行的模块，由于是 node.js 的进程，所以可以是 .js 文件；<br> 4、无回调，参数要以第二个参数传入；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过process.on(&#39;message&#39;)和process.send()的机制来接收和发送消息</span><br><span class="line">child.js</span><br><span class="line">process.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">   process.send(msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">parent.js</span><br><span class="line">let cp&#x3D;require(&#39;child_process&#39;);</span><br><span class="line">let child&#x3D;cp.fork(&#39;.&#x2F;child&#39;);</span><br><span class="line">child.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">  console.log(&#39;got a message is&#39;,msg);</span><br><span class="line">&#125;);</span><br><span class="line">child.send(&#39;hello world&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; child.disconnect() 父进程中调用， 断开父子间IPC通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; got a message is hello world</span><br></pre></td></tr></table></figure>

<h4 id="ChildProcess类"><a href="#ChildProcess类" class="headerlink" title="ChildProcess类"></a>ChildProcess类</h4><p>1、childProcess的实例代表衍生的子进程；<br>2、每个实例都有stdout、stdin、stderr三个流对象；</p>
<ul>
<li><p>subprocess.stderr 子进程的stderr可读流，subprocess.stderr 是 subprocess.stdio[2] 的别名。 两个属性都将会指向相同的值；</p>
</li>
<li><p>subprocess.stdin 子进程的stdin的可写流，subprocess.stdin 是 subprocess.stdio[0] 的别名。 两个属性都将会指向相同的值；</p>
</li>
<li><p>subprocess.stdio 一个到子进程的稀疏数组，subprocess.stdio[0]、 subprocess.stdio[1] 和 subprocess.stdio[2] 也分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr；</p>
</li>
<li><p>subprocess.stdout 子进程的stdout的可读流，subprocess.stdout 是 subprocess.stdio[1] 的别名。 两个属性都将会指向相同的值；</p>
</li>
</ul>
<p>3、通过fork产生的子进程与父进程可以用send即监听message来相互通信；<br>4、事件：error、close、message、exit、disconnect</p>
<ul>
<li>close当子进程的stdio流已被关闭时会触发close事件；</li>
<li>disconnect断开连接，不再发送或接收消息；</li>
<li>error出现情况有4中：<br>  1）无法衍生进程；<br>  2）无法杀死进程；<br>  3）向子进程发送消息失败；</li>
<li>exit子进程结束后退出，但子进程的stdio流可能仍然是打开的；</li>
<li>message子进程使用process.send()发送消息时会触发message事件；</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之buffer</title>
    <url>/articles/2020-02-01-node-buffer.html</url>
    <content><![CDATA[<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer类是作为Node API的一部分引入的，用于在TCP流、文件系统操作及其他上下文中与八位字节流进行交互。<br>一个更好的操作二进制数据的类。<br>暂时存放输入输出数据的一段内存。</p>
<ul>
<li>Buffer的大小在创建的时候确定，且无法更改；</li>
<li>Buffer类在全局作用域中，所以无需引用require(‘buffer’)；</li>
<li>分配的内存不在V8内存中，而是在node的C++层实现的；</li>
<li>采用slab分配机制，slab是动态内存管理机制，分为full(完全分配状态)、partial(部分分配状态)、empty(未分配状态)；</li>
</ul>
<a id="more"></a>

<p><strong>创建Buffer：</strong></p>
<ul>
<li>Buffer.alloc(size，string， encoding)<br>  必填：size<br>  非必填：string、encoding<br>  创建的buffer是被初始化的，Buffer的每一项都用00填充</li>
<li>Buffer.allocUnsafe(size，string， encoding)<br>  创建的Buffer并没有经过初始化，在内存中只要有闲置的buffer就使用。创建Buffer使得内存分配非常快，但已分配的内存段可能包含敏感的数据，有明显性能优势却不安全。</li>
</ul>
<p> <strong>根据内容直接创建buffer：</strong></p>
<ul>
<li><p>Buffer.from(buffer)</p>
</li>
<li><p>Buffer.from(array)</p>
</li>
<li><p>Buffer.from(string, encoding)<br>  必填：string<br>  非必填：encoding</p>
<ul>
<li>Buffer.from(buffer)<br> 参数为buffer的时候，会创建一个新的buffer并复制上面的每一个成员；<br> Buffer为引用类型，一个Buffer复制另一个buffer的成员，当其中一个Buffer复制的成员更改，另一个Buffer对应成员跟着改变。</li>
</ul>
</li>
</ul>
<p>  <strong>操作Buffer：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查下buffer的结构</span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer里存的是16进制数字，按照字节长度计算</span><br><span class="line">buf.length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写入数据到buffer</span><br><span class="line">buf.write()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解码buffer</span><br><span class="line">buf.toString()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer拼接</span><br><span class="line">buf.concat(list[, totalLength])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断对象是否为 Buffer</span><br><span class="line">Buffer.isBuffer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断 Buffer 对象编码</span><br><span class="line">Buffer.isEncoding</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和数组的 indexOf 类似，返回某字符串、acsii 码或者 buf 在改 buf 中的位置</span><br><span class="line">buf.indexOf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将一个 buf 的（部分）内容复制到另外一个 buf 中</span><br><span class="line">buf.copy</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之async_hooks</title>
    <url>/articles/2020-02-01-node-async-hooks.html</url>
    <content><![CDATA[<h2 id="async-hooks"><a href="#async-hooks" class="headerlink" title="async_hooks"></a>async_hooks</h2><p>异步钩子；<br>提供了一组API用来跟踪Nodejs的异步资源(asynchronous resources)的生命周期；</p>
<p>特性：</p>
<ol>
<li>每个函数都会提供一个上下文，为async scope（node为每个函数都提供了一个async scope）;</li>
<li>每个async scope都有一个asyncId标志，最外层的asyncId是1，每个异步资源在创建时asyncId是全量递增的；</li>
<li>同步函数不会改变其调用者的asyncId；</li>
<li>同一个函数，不同时刻进行异步调用，会分配不同的asyncId；</li>
<li>triggerAsyncId当前函数调用者的asyncId；</li>
<li>executionAsyncId当前函数的asyncId；</li>
</ol>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">const async_hooks &#x3D; require(&#39;async_hooks&#39;)</span><br><span class="line"></span><br><span class="line">const eid &#x3D; async_hooks.executionAsyncId()</span><br><span class="line">const tid &#x3D; async_hooks.triggerAsyncId()</span><br><span class="line">console.log(&#96;executionAsyncId: $&#123;eid&#125;, triggerAsyncId: $&#123;tid&#125;&#96;)</span><br><span class="line"></span><br><span class="line">const asyncHooks &#x3D; async_hooks.createHook(&#123;</span><br><span class="line">    &#x2F;&#x2F; fs.writeSync向控制台打印消息，不可用console.log，因为它是一个异步调用，再次使用会触发hook事件，造成无限循环。</span><br><span class="line">    init(asyncId, type, triggerAsyncId, resource) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;init start: asyncId-$&#123;asyncId&#125;, type-$&#123;type&#125;, triggerAsyncId-$&#123;triggerAsyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    before(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;before: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    after(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;after: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;destroy: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动跟踪</span><br><span class="line">asyncHooks.enable()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; asyncHooks.disable()</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20191218171717821.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>async_hooks.createHook(callbacks)<br>  创建一个hook，初始化hook的声明周期的工厂方法。<br>  用来跟踪应用中的异步资源，当资源在被初始化，回调之前，回调之后，销毁后，自动触发init，before，after，destory。</p>
</li>
<li><p>asyncHooks.enable()<br>  启用跟踪</p>
</li>
<li><p>asyncHooks.disable()<br>  关闭跟踪</p>
</li>
<li><p>init(asyncId, type, triggerAsyncId, resource)<br>  asyncId：代表当前异步资源的ID，每个异步资源都会生成一个唯一性标志；<br>  type：表示该资源的类型；<br>  triggerAsyncId：调用者的asyncId，即触发当前异步资源被创建的对应的async scope的asyncid；<br>  resource：被初始化的异步资源包含的一些信息；</p>
</li>
<li><p>before(asyncId)<br>  在asyncId对应的异步资源操作完成后，准备执行回调函数前被调用，由回调的次数决定执行的次数。</p>
</li>
<li><p>after(asyncId)<br>  异步资源操作完成后立即被调用。</p>
</li>
<li><p>destroy(asyncId)<br>  asyncid被销毁时调用</p>
</li>
<li><p>promiseResolve(asyncId)</p>
</li>
<li><p>async_hooks.executionAsyncId()<br>  当前异步资源的ID</p>
</li>
<li><p>async_hooks.triggerAsyncId()<br>  调用者的ID</p>
</li>
</ul>
<ul>
<li>Promise执行跟踪<br>  PromiseResolve(asyncId)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1729).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;Promise resolve: executionAsyncId: $&#123;async_hooks.executionAsyncId()&#125;, triggerAsyncId: $&#123;async_hooks.triggerAsyncId()&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之assert</title>
    <url>/articles/2020-02-01-node-assert.html</url>
    <content><![CDATA[<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>断言模块，断言测试、用于测试不变量；<br>发现代码问题、定位问题；<br>对代码的可维护性、代码重构及后期功能扩展有重要意义；</p>
<a id="more"></a>

<ul>
<li><p>assert.AssertionError类<br>表明断言的失败，assert所有的错误都是AssertionError类的实例。</p>
</li>
<li><p>严格模式：严格相等和不相等判断<br>严格相等满足‘===’<br>assert.deepEqual(actual, expected[, message])</p>
</li>
<li><p>相等和不相等判断<br>assert.equal(actual, expected[, message])</p>
</li>
<li><p>深度匹配和不匹配判断<br>assert.deepEqual(actual, expected[,message])<br>assert.notDeepEqual(actual, expected[,message])</p>
</li>
<li><p>错误：抛出断言异常<br>assert.fail([message])</p>
</li>
<li><p>抛出异常<br>assert.throws(fn[, error][,message])</p>
</li>
<li><p>判断是否为假<br>assert.ifError(value)</p>
</li>
<li><p>判断是否为真<br>assert.ok(value[, message])</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AssertionError: 假值</span><br><span class="line">assert.ok(false, &#39;假值&#39;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>编程常用的工具汇总</title>
    <url>/articles/2020-01-31-code-tools.html</url>
    <content><![CDATA[<p>1、在线工具汇总：<a href="https://tool.lu；" target="_blank" rel="noopener">https://tool.lu；</a><br>2、草料二维码生成器：<a href="https://cli.im/text；" target="_blank" rel="noopener">https://cli.im/text；</a><br>3、正则表达式工具：<a href="https://tool.lu/regex/；" target="_blank" rel="noopener">https://tool.lu/regex/；</a><br>4、JSON在线解析及格式化验证：<a href="https://www.json.cn；" target="_blank" rel="noopener">https://www.json.cn；</a><br>5、在线编码转换：<a href="http://tool.oschina.net/encode?type=4；" target="_blank" rel="noopener">http://tool.oschina.net/encode?type=4；</a></p>
]]></content>
      <categories>
        <category>code-tools</category>
      </categories>
      <tags>
        <tag>code-tools</tag>
      </tags>
  </entry>
  <entry>
    <title>解决出现Cannot find module &#39;XXX’的错误</title>
    <url>/articles/2020-01-31-node-cannot-find-module.html</url>
    <content><![CDATA[<p>在进行webpack打包的时候，会出现Cannot find module ‘XXX’的错误，找不到某个模块的错误，今天给出解决方法：</p>
<p>1、直接进行npm install重新打包；<br>2、如果npm install重新打包之后，仍然出现这个问题，可以进行删除node_modules文件夹，同时清除缓存，如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line"></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>删除node_modules文件夹</title>
    <url>/articles/2020-01-31-node-modules.html</url>
    <content><![CDATA[<p>有时候很难直接删除node_modules文件夹，以下提供两种删除node_modules文件夹的方法：<br>1、如果能够直接右击鼠标删除文件夹，则直接执行删除 ；<br>2、否则</p>
<ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install rimraf -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>node_modules</category>
      </categories>
      <tags>
        <tag>node_modules</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/articles/2020-01-30-git.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clone远程工程：</span><br><span class="line">    git clone https:&#x2F;&#x2F;xxxx.git</span><br><span class="line"></span><br><span class="line">fetch远程分支到本地某分支：</span><br><span class="line">    git fetch origin &lt;originname&gt;:&lt;clonename&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看分支：</span><br><span class="line">    git branch</span><br><span class="line"></span><br><span class="line">查看远程所有分支：</span><br><span class="line">    git branch -r</span><br><span class="line"></span><br><span class="line">查看本地和远程所有分支：</span><br><span class="line">    git branch -a</span><br><span class="line"></span><br><span class="line">创建分支：</span><br><span class="line">    git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：</span><br><span class="line">    git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建并切换分支：</span><br><span class="line">    git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：</span><br><span class="line">    git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">把分支推送到远程：</span><br><span class="line">    git push origin &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除本地分支：</span><br><span class="line">    git branch (-d|-D) &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除远程分支：</span><br><span class="line">    git push origin -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line">分支重命名：</span><br><span class="line">    git branch (-m|-M) &lt;oldbranch&gt; &lt;newbranch&gt;</span><br><span class="line"></span><br><span class="line">查看分支最近一次的修改列表：</span><br><span class="line">    git status</span><br><span class="line"></span><br><span class="line">查看分支的commit信息（倒序）：</span><br><span class="line">    git log: (commit id,Author,Date,Commit info)；</span><br><span class="line">    git shortlog:按提交者分类显示所有提交信息；</span><br><span class="line">    git log --online:只输出commit id和commit info；</span><br><span class="line">    git log --stat：查看增删改查了哪些文件；</span><br><span class="line"></span><br><span class="line">版本回退：</span><br><span class="line">    回退到上一版本：git reset --hard HEAD^</span><br><span class="line">    回退到上上版本：git reset --hard HEAD^^</span><br><span class="line">                 git reset --hard HEAD~2</span><br><span class="line">    回退到某个版本：git reset --hard &lt;commit id&gt;</span><br><span class="line">    强制推送到远程分支：git push -f</span><br><span class="line"></span><br><span class="line">    注意：</span><br><span class="line">        HEAD：指向的版本是当前版本，^表示上一个版本，~N表示上N个版本，&lt;commit id&gt;可简写</span><br><span class="line">        git log：查看&lt;commit id&gt;</span><br><span class="line">        git reflog:查看命令历史，回退到某个未来的版本；</span><br><span class="line"></span><br><span class="line">文件增加、提交、拉取、推送、比对、合并</span><br><span class="line">    添加新增文件：git add README.md</span><br><span class="line">    添加所有新增文件：git add .</span><br><span class="line">    暂存变更文件：git stash [save &quot;暂存备注&quot;]</span><br><span class="line">    恢复暂存文件：git stash pop</span><br><span class="line">    提交变更文件：git commit -m &quot;变更备注&quot;</span><br><span class="line">    拉取远程代码：git pull [origin &lt;name&gt;]</span><br><span class="line">    推送到远程：git push origin &lt;name&gt;</span><br><span class="line">    比对两个分支：git diff &lt;name1&gt; &lt;name2&gt;</span><br><span class="line">    比对两个分支变更的文件列表：git diff &lt;name1&gt; &lt;name2&gt; --stat</span><br><span class="line">    比对本地和远程分支：git diff &lt;name&gt; origin&#x2F;&lt;name&gt;</span><br><span class="line">    合并某个分支：git merge &lt;name&gt;</span><br><span class="line">    强制覆盖本地分支：  </span><br><span class="line">        git fetch --all</span><br><span class="line">        git reset  --hard origin&#x2F;&lt;name&gt;</span><br><span class="line">        git pull</span><br><span class="line"></span><br><span class="line">常用选项和其他命令</span><br><span class="line">    git中部分选项解释</span><br><span class="line">        -f --force：强制</span><br><span class="line">        -d --delete：删除</span><br><span class="line">        -D --delete --force</span><br><span class="line">        -m --move：移动或重命名</span><br><span class="line">        -M --remote：远程</span><br><span class="line">        -a --all：所有</span><br><span class="line"></span><br><span class="line">    其他命令</span><br><span class="line">        清空工程：</span><br><span class="line">            $ git rm -rf .</span><br><span class="line">        每隔X秒运行一次git pull：</span><br><span class="line">            $ for((i&#x3D;1;i&lt;&#x3D;10000;i+&#x3D;1)); do sleep X &amp;&amp; git pull; done</span><br><span class="line">        使用git rebase将一个feature分支变基到master分支</span><br><span class="line">            $ git checkout feature</span><br><span class="line">            $ git rebase master</span><br><span class="line"></span><br><span class="line">配置相关:</span><br><span class="line">    查看当前配置：  git config --list</span><br><span class="line">    修改git的name和email：</span><br><span class="line">        git config --global user.name &lt;name&gt;</span><br><span class="line">        git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo+github进行搭建博客</title>
    <url>/articles/2020-01-29-hexo.html</url>
    <content><![CDATA[<p>Hexo+github搭建博客步骤：</p>
<ol>
<li>git账号创建</li>
<li>node环境搭建</li>
<li>安装Hexo</li>
<li>github创建个人仓库</li>
<li>hexo部署到github</li>
<li>个人域名</li>
<li>发布文章<a id="more"></a>

</li>
</ol>
<h4 id="1-git账号创建"><a href="#1-git账号创建" class="headerlink" title="1. git账号创建"></a>1. git账号创建</h4><p>git官网上可以注册创建一个账号。</p>
<h4 id="2-node环境搭建"><a href="#2-node环境搭建" class="headerlink" title="2. node环境搭建"></a>2. node环境搭建</h4><p>安装node和npm，查看node是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nodejs</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>
<h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h4><ul>
<li><p>安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li>
<li><p>初始化一个boke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line">cd my-blog</span><br></pre></td></tr></table></figure></li>
<li><p>成功后，可看到文件目录<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p>
</li>
<li><p>部署后，打开服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>本地的<a href="localhost:4000">localhost:4000</a>就可以访问你生成的博客了。</p>
</li>
</ul>
<h4 id="4-github创建个人仓库"><a href="#4-github创建个人仓库" class="headerlink" title="4. github创建个人仓库"></a>4. github创建个人仓库</h4><p>github官网创建好账号之后，新建一个仓库：用户名.github.io</p>
<h4 id="5-hexo部署到github"><a href="#5-hexo部署到github" class="headerlink" title="5. hexo部署到github"></a>5. hexo部署到github</h4><ul>
<li><p>将hexo和github关联起来，需要修改配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;git名&#x2F;git用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时需要安装deploy-git，即部署命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除之前的东西</span><br><span class="line">hexo g  &#x2F;&#x2F; 生成静态文章</span><br><span class="line">hexo d  &#x2F;&#x2F; 部署文章</span><br></pre></td></tr></table></figure>
<p>执行完成后，就可以在<a href="https://github.com/git名/git用户名.github.io.git" target="_blank" rel="noopener">https://github.com/git名/git用户名.github.io.git</a>看到博客了。</p>
</li>
</ul>
<h4 id="6-个人域名"><a href="#6-个人域名" class="headerlink" title="6. 个人域名"></a>6. 个人域名</h4><p>需要自己去买个域名，在阿里云，买好域名后：<br>需要进行解析域名，解析时把地址指向你的github的地址。</p>
<p>登录github后，进入刚刚创建的仓库，点击settings，设置Custom domain，输入你的域名地址。<br>并且在my-blog项目下的source中创建一个名为CNAME的文件，把域名加入。<br>最后一步再进行部署，此时访问你的域名就可以看到你的博客了</p>
<h4 id="7-发布文章"><a href="#7-发布文章" class="headerlink" title="7. 发布文章"></a>7. 发布文章</h4><p>创建标签或自定义文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;name&#39;</span><br></pre></td></tr></table></figure>
<p>写文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new pageName</span><br></pre></td></tr></table></figure>
<p>部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
