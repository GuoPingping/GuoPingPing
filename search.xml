<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NodeJs之module</title>
    <url>/2020-02-05-node-module.html</url>
    <content><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>模块。</p>
<p>在Nodejs模块系统中，每个文件都被视为一个独立的模块。</p>
<a id="more"></a>

<h4 id="访问主模块"><a href="#访问主模块" class="headerlink" title="访问主模块"></a>访问主模块</h4><p>当Nodejs直接运行一个文件时mrequire.main会被视为module。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>模块在第一次加载后会被缓存。<br>每次调用相同的模块都解析到同一个文件，则返回相同的对象。</p>
<h5 id="模块缓存的注意事项"><a href="#模块缓存的注意事项" class="headerlink" title="模块缓存的注意事项"></a>模块缓存的注意事项</h5><p>模块是基于其解析的文件名进行缓存的。由于调用模块的位置不同，模块可能被解析成不同的<br>文件名，这样就不能保证总能返回完全相同的对象。</p>
<p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，<br>但缓存仍然会将它们视为不同的模块，并多次重新加载。</p>
<h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>核心模块定义在Nodejs原代码的lib/目录下。<br>require()总是会优先加载核心模块。</p>
<h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当循环调用require()时，一个模块可能在未完成执行时被返回。</p>
<h4 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h4><p>提供一个单一的入口来指向它。</p>
<h4 id="从node-modules目录加载"><a href="#从node-modules目录加载" class="headerlink" title="从node_modules目录加载"></a>从node_modules目录加载</h4><h4 id="从全局目录加载"><a href="#从全局目录加载" class="headerlink" title="从全局目录加载"></a>从全局目录加载</h4><h4 id="模块封装器"><a href="#模块封装器" class="headerlink" title="模块封装器"></a>模块封装器</h4><p>在指向模块代码之前，Nodejs会使用一个如下的函数封装器将其封装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">&#x2F;&#x2F; 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>通过这样做，Nodejs实现了以下几点：</p>
<ul>
<li>它保持了顶层的变量（用var、const或let定义）作用在模块范围内，而不是全局对象；</li>
<li>它有助于提高一些看似全局但实际是模块特定的变量；</li>
</ul>
<h4 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h4><h5 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h5><p>当前模块的目录名。</p>
<h5 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h5><p>当前模块的文件名。</p>
<h5 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h5><h5 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h5><p>对当前模块的引用。</p>
<h5 id="require-id"><a href="#require-id" class="headerlink" title="require(id)"></a>require(id)</h5><h5 id="require-cache"><a href="#require-cache" class="headerlink" title="require.cache"></a>require.cache</h5><p>被引入的模块江北诶缓存在这个对象中，从此对象中删除键值对将会导致下一次require重新加载<br>被删除的模块。这不适用原生插件，因为它们的重载将会导致错误。</p>
<h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>module的自由变量是对表示当前模块的对象的引用。</p>
<h5 id="module-children"><a href="#module-children" class="headerlink" title="module.children"></a>module.children</h5><p>被该模块引用的模块对象。</p>
<h5 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h5><p>module.exports对象由Module系统创建。</p>
<h5 id="exports快捷方式"><a href="#exports快捷方式" class="headerlink" title="exports快捷方式"></a>exports快捷方式</h5><p>exports变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给module。exports。</p>
<h5 id="module-filename"><a href="#module-filename" class="headerlink" title="module.filename"></a>module.filename</h5><p>模块的完全解析后的文件名。</p>
<h5 id="module-id"><a href="#module-id" class="headerlink" title="module.id"></a>module.id</h5><p>模块的标识符。通常是完全解析后的文件名。</p>
<h5 id="module-loaded"><a href="#module-loaded" class="headerlink" title="module.loaded"></a>module.loaded</h5><p>模块是否已经加载完成，或正在加载中。</p>
<h5 id="module-parent"><a href="#module-parent" class="headerlink" title="module.parent"></a>module.parent</h5><p>最先引用该模块的模块。</p>
<h5 id="module-paths"><a href="#module-paths" class="headerlink" title="module.paths"></a>module.paths</h5><p>模块的搜索路径。</p>
<h5 id="module-require-id"><a href="#module-require-id" class="headerlink" title="module.require(id)"></a>module.require(id)</h5><p>提供一种加载模块的方法。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之inspector</title>
    <url>/2020-02-05-node-inspector.html</url>
    <content><![CDATA[<h2 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h2><p>检查器。</p>
<p>inspector模块提供了一个用户与V8 inspector交互的API。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const inspector &#x3D; require(&#39;inspector&#39;)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="inspector-close"><a href="#inspector-close" class="headerlink" title="inspector.close()"></a>inspector.close()</h4><h4 id="inspector-close-1"><a href="#inspector-close-1" class="headerlink" title="inspector.close"></a>inspector.close</h4><h4 id="inspector-open-port-host-wait"><a href="#inspector-open-port-host-wait" class="headerlink" title="inspector.open([port[, host[, wait]]])"></a>inspector.open([port[, host[, wait]]])</h4><h4 id="inspector-url"><a href="#inspector-url" class="headerlink" title="inspector.url()"></a>inspector.url()</h4><h4 id="inspector-waitForDebugger"><a href="#inspector-waitForDebugger" class="headerlink" title="inspector.waitForDebugger()"></a>inspector.waitForDebugger()</h4><h4 id="inspector-Session类"><a href="#inspector-Session类" class="headerlink" title="inspector.Session类"></a>inspector.Session类</h4><h5 id="new-inspector-Session"><a href="#new-inspector-Session" class="headerlink" title="new inspector.Session()"></a>new inspector.Session()</h5>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之HTTPS</title>
    <url>/2020-02-05-node-HTTPS.html</url>
    <content><![CDATA[<h2 id="https-HTTPS"><a href="#https-HTTPS" class="headerlink" title="https(HTTPS)"></a>https(HTTPS)</h2><p>HTTPS是基于TLS/SSL的HTTP协议。在NodeJS中，作为一个单独的模块实现。</p>
<a id="more"></a>

<h4 id="https-Agent类"><a href="#https-Agent类" class="headerlink" title="https.Agent类"></a>https.Agent类</h4><p>HTTPS的Agent对象，类似于http.Agent.</p>
<h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><h4 id="https-Server类"><a href="#https-Server类" class="headerlink" title="https.Server类"></a>https.Server类</h4><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h5 id="server-headersTimeout"><a href="#server-headersTimeout" class="headerlink" title="server.headersTimeout"></a>server.headersTimeout</h5><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><h5 id="server-maxHeadersCount"><a href="#server-maxHeadersCount" class="headerlink" title="server.maxHeadersCount"></a>server.maxHeadersCount</h5><h5 id="server-setTimeout-msecs-callback"><a href="#server-setTimeout-msecs-callback" class="headerlink" title="server.setTimeout([msecs][,callback])"></a>server.setTimeout([msecs][,callback])</h5><h5 id="server-timeout"><a href="#server-timeout" class="headerlink" title="server.timeout"></a>server.timeout</h5><h5 id="server-keepAliveTimeout"><a href="#server-keepAliveTimeout" class="headerlink" title="server.keepAliveTimeout"></a>server.keepAliveTimeout</h5><h5 id="heeps-createServer-options-requestListener"><a href="#heeps-createServer-options-requestListener" class="headerlink" title="heeps.createServer([options][,requestListener])"></a>heeps.createServer([options][,requestListener])</h5><h5 id="https-get-options-callback"><a href="#https-get-options-callback" class="headerlink" title="https.get(options[,callback])"></a>https.get(options[,callback])</h5><h5 id="https-get-url-options-callback"><a href="#https-get-url-options-callback" class="headerlink" title="https.get(url[,options][,callback])"></a>https.get(url[,options][,callback])</h5><h5 id="https-request-options-callback"><a href="#https-request-options-callback" class="headerlink" title="https.request(options[,callback])"></a>https.request(options[,callback])</h5><h5 id="https-request-url-options-callback"><a href="#https-request-url-options-callback" class="headerlink" title="https.request(url[,options][,callback])"></a>https.request(url[,options][,callback])</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const https &#x3D; require(&#39;https&#39;);</span><br><span class="line"></span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  hostname: &#39;encrypted.google.com&#39;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  method: &#39;GET&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const req &#x3D; https.request(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;状态码:&#39;, res.statusCode);</span><br><span class="line">  console.log(&#39;请求头:&#39;, res.headers);</span><br><span class="line"></span><br><span class="line">  res.on(&#39;data&#39;, (d) &#x3D;&gt; &#123;</span><br><span class="line">    process.stdout.write(d);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(e);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJS之HTTP/2</title>
    <url>/2020-02-05-node-Http-2.html</url>
    <content><![CDATA[<h2 id="http2-HTTP-2"><a href="#http2-HTTP-2" class="headerlink" title="http2 (HTTP/2)"></a>http2 (HTTP/2)</h2><p>http2模块提供了HTTP/2协议的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2)</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h4><p>核心API提供了专门针对支持HTTP/2协议的特性而设计的底层接口。</p>
<p>http2核心API在客户端和服务器之间比http API更加对称。</p>
<h4 id="Http2Session类"><a href="#Http2Session类" class="headerlink" title="Http2Session类"></a>Http2Session类</h4><p>Http2Session类的实例代表了HTTP/2客户端与服务器之间的一个活跃的通信会话。</p>
<p>每个Http2Session实例会有略有不同的行为，这取决于它是作为服务器还是客户端运行。<br>Http2Session.type属性可用于判断Http2Session的运行模式。</p>
<p>用户代码不会直接的创建Http2Session实例。<br>当接收到新的http/2连接时，服务端的Http2Session实例由Http2Server实例创建。</p>
<h5 id="Http2Session与Socket"><a href="#Http2Session与Socket" class="headerlink" title="Http2Session与Socket"></a>Http2Session与Socket</h5><p>每个Http2Session实例在创建时都会与一个net.Socket或tls.TLSSocket关联。<br>当Socket或Http2Session被销毁时，两者都会被销毁。</p>
<p>一旦将Socket绑定到Http2Session，则用户代码应仅依赖于Http2Session的API。</p>
<h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="stream事件"><a href="#stream事件" class="headerlink" title="stream事件"></a>stream事件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line">session.on(&#39;stream&#39;, (stream, headers, flags) &#x3D;&gt; &#123;</span><br><span class="line">  const method &#x3D; headers[&#39;:method&#39;];</span><br><span class="line">  const path &#x3D; headers[&#39;:path&#39;];</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;:status&#39;: 200,</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;plain&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.write(&#39;hello &#39;);</span><br><span class="line">  stream.end(&#39;world&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an unencrypted HTTP&#x2F;2 server</span><br><span class="line">const server &#x3D; http2.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;stream&#39;, (stream, headers) &#x3D;&gt; &#123;</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;html&#39;,</span><br><span class="line">    &#39;:status&#39;: 200</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.on(&#39;error&#39;, (error) &#x3D;&gt; console.error(error));</span><br><span class="line">  stream.end(&#39;&lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br></pre></td></tr></table></figure>

<h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><h4 id="ClientHttp2Session类"><a href="#ClientHttp2Session类" class="headerlink" title="ClientHttp2Session类"></a>ClientHttp2Session类</h4><h4 id="Http2Stream类"><a href="#Http2Stream类" class="headerlink" title="Http2Stream类"></a>Http2Stream类</h4><h5 id="Http2Stream的生命周期"><a href="#Http2Stream的生命周期" class="headerlink" title="Http2Stream的生命周期"></a>Http2Stream的生命周期</h5><p>创建、销毁、</p>
<h4 id="ClientHttp2Stream类"><a href="#ClientHttp2Stream类" class="headerlink" title="ClientHttp2Stream类"></a>ClientHttp2Stream类</h4><h4 id="ServerHttp2Stream类"><a href="#ServerHttp2Stream类" class="headerlink" title="ServerHttp2Stream类"></a>ServerHttp2Stream类</h4><h4 id="Http2Server类"><a href="#Http2Server类" class="headerlink" title="Http2Server类"></a>Http2Server类</h4><h4 id="Http2SecureServer类"><a href="#Http2SecureServer类" class="headerlink" title="Http2SecureServer类"></a>Http2SecureServer类</h4><h4 id="http2-Http2ServerRequest类"><a href="#http2-Http2ServerRequest类" class="headerlink" title="http2.Http2ServerRequest类"></a>http2.Http2ServerRequest类</h4><h4 id="http2-Http2ServerResponse类"><a href="#http2-Http2ServerResponse类" class="headerlink" title="http2.Http2ServerResponse类"></a>http2.Http2ServerResponse类</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之Http</title>
    <url>/2020-02-02-node-Http.html</url>
    <content><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>要使用HTTP服务器和客户端，必须require(‘http’);</p>
<a id="more"></a>

<h4 id="http-Agent类"><a href="#http-Agent类" class="headerlink" title="http.Agent类"></a>http.Agent类</h4><p>Agent负责管理HTTP客户端的链接持久性和重用。</p>
<p>它为给定的主机和端口维护一个待处理请求队列，为每个请求重用单独的套接字连接，<br>直到队列为空，此时套接字被销毁或放入连接池，以便再次用于请求到同一个主机和端口。</p>
<p>销毁还是放入连接池取决于keepAlive选项。</p>
<p>连接池中的连接已启用TCP Keep-Alive，但服务器仍可能关闭空闲连接，<br>这种情况下，它们将从连接池中删除，并且当为该主机和端口发出新的HTTP请求时将建立新的连接。<br>服务器也可以拒绝通过同一连接允许多个请求，在这种情况下，必须为每个请求重新建立连接，<br>并且不能放入连接池。Agent仍将向该服务器发出请求，但每个请求都将通过新连接发生。</p>
<p>当客户端或服务器关闭连接时，它将从连接池中删除。连接池中任何未使用的套接字都将被销毁，<br>以便当没有未完成的请求时不用保持Nodejs进程运行。</p>
<p>当不再使用时最好destrory() Agent实例，因为未使用的套接字会消耗操作系统资源。</p>
<p>当套接字触发close事件或agentRemove事件时，则套接字从代理中删除。<br>当打算长时间保持一个HTTP请求打开而不将其保留在代理中时，可以执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.get(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 做些事情。</span><br><span class="line">&#125;).on(&#39;socket&#39;, (socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.emit(&#39;agentRemove&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>代理也可以用于单个请求，通过提供{agent:false}作为http.get()或http.request()<br>函数的选项，则将使用一次性的具有默认选项的Agent用于客户端的连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http.get(&#123;</span><br><span class="line">  hostname: &#39;localhost&#39;,</span><br><span class="line">  port: 80,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  agent: false  &#x2F;&#x2F; 仅为此一个请求创建一个新代理。</span><br><span class="line">&#125;, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 用响应做些事情。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><p>options要在代理上设置的可配置选项集。</p>
<p>要配置其中任何一个，则必须创建自定义的http.Agent实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const keepAliveAgent &#x3D; new http.Agent(&#123; keepAlive: true &#125;);</span><br><span class="line">options.agent &#x3D; keepAliveAgent;</span><br><span class="line">http.request(options, onResponseCallback);</span><br></pre></td></tr></table></figure>

<h5 id="agent-createConnection-options-callback"><a href="#agent-createConnection-options-callback" class="headerlink" title="agent.createConnection(options[, callback])"></a>agent.createConnection(options[, callback])</h5><p>生成用于http请求的套接字或流。</p>
<h5 id="agent-keepSocketAlive-socket"><a href="#agent-keepSocketAlive-socket" class="headerlink" title="agent.keepSocketAlive(socket)"></a>agent.keepSocketAlive(socket)</h5><p>当socket与请求分离并且可以由Agent保留时调用，默认行为是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">socket.setKeepAlive(true, this.keepAliveMsecs);</span><br><span class="line">socket.unref();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure>

<h5 id="agent-reuseSocket-socket-request"><a href="#agent-reuseSocket-socket-request" class="headerlink" title="agent.reuseSocket(socket, request)"></a>agent.reuseSocket(socket, request)</h5><p>由于keep-alive选项而在持久化后将socket附加到request时调用。<br>默认行为是<code>socket.ref()</code></p>
<h5 id="agent-destroy"><a href="#agent-destroy" class="headerlink" title="agent.destroy()"></a>agent.destroy()</h5><p>销毁代理当前使用的所有套接字。</p>
<h5 id="agent-maxSockets"><a href="#agent-maxSockets" class="headerlink" title="agent.maxSockets"></a>agent.maxSockets</h5><p>决定代理可以为每个来源打开多少并发套接字。</p>
<h5 id="agent-requests"><a href="#agent-requests" class="headerlink" title="agent.requests"></a>agent.requests</h5><p>一个对象，包含尚未分配给套接字的请求队列，不要修改。</p>
<h5 id="agent-sockets"><a href="#agent-sockets" class="headerlink" title="agent.sockets"></a>agent.sockets</h5><p>一个对象，包含当前代理正在使用的套接字数组，不要修改。</p>
<h4 id="http-ClientRequest类"><a href="#http-ClientRequest类" class="headerlink" title="http.ClientRequest类"></a>http.ClientRequest类</h4><h4 id="http-Server类"><a href="#http-Server类" class="headerlink" title="http.Server类"></a>http.Server类</h4><h4 id="http-ServerResponse类"><a href="#http-ServerResponse类" class="headerlink" title="http.ServerResponse类"></a>http.ServerResponse类</h4><h4 id="http-IncomingMessage类"><a href="#http-IncomingMessage类" class="headerlink" title="http.IncomingMessage类"></a>http.IncomingMessage类</h4><h4 id="http-METHODS"><a href="#http-METHODS" class="headerlink" title="http.METHODS"></a>http.METHODS</h4><h4 id="http-STATUS-CODES"><a href="#http-STATUS-CODES" class="headerlink" title="http.STATUS_CODES"></a>http.STATUS_CODES</h4><h4 id="http-createServer-options-requestListener"><a href="#http-createServer-options-requestListener" class="headerlink" title="http.createServer([options][, requestListener])"></a>http.createServer([options][, requestListener])</h4><h4 id="http-get-options-callback"><a href="#http-get-options-callback" class="headerlink" title="http.get(options[,callback])"></a>http.get(options[,callback])</h4><h4 id="http-get-url-options-callback"><a href="#http-get-url-options-callback" class="headerlink" title="http.get(url[,options][,callback])"></a>http.get(url[,options][,callback])</h4><h4 id="http-globalAgent"><a href="#http-globalAgent" class="headerlink" title="http.globalAgent"></a>http.globalAgent</h4><h4 id="http-maxHeaderSize"><a href="#http-maxHeaderSize" class="headerlink" title="http.maxHeaderSize"></a>http.maxHeaderSize</h4><h4 id="http-request-options-callback"><a href="#http-request-options-callback" class="headerlink" title="http.request(options[,callback])"></a>http.request(options[,callback])</h4><h4 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[,options][,callback])"></a>http.request(url[,options][,callback])</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之global</title>
    <url>/2020-02-02-node-global.html</url>
    <content><![CDATA[<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>全局变量。</p>
<p>所有模块都提供这些对象。</p>
<h4 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h4><p>用于处理二进制数据。</p>
<h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<a id="more"></a>

<h4 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h4><h4 id="clearInterval-intervalObject"><a href="#clearInterval-intervalObject" class="headerlink" title="clearInterval(intervalObject)"></a>clearInterval(intervalObject)</h4><h4 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h4><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="global-1"><a href="#global-1" class="headerlink" title="global"></a>global</h4><p>在浏览器中，顶层作用域是全局作用域。<br>在nodejs中，顶层作用于不是全局作用域，nodejs模块中的var something的作用域只在该模块内。</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>进程对象。</p>
<h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p>此变量虽然看起来是全局的，但实际上不是。</p>
<h4 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h4><h4 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[,…args])"></a>setInterval(callback, delay[,…args])</h4><h4 id="setTimeout-callback-delay-…-args"><a href="#setTimeout-callback-delay-…-args" class="headerlink" title="setTimeout(callback, delay[, ….args])"></a>setTimeout(callback, delay[, ….args])</h4><h4 id="TextDecoder"><a href="#TextDecoder" class="headerlink" title="TextDecoder"></a>TextDecoder</h4><h4 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h4><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之fs</title>
    <url>/2020-02-01-node-fs.html</url>
    <content><![CDATA[<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p>文件系统</p>
<p>fs模块提供了一个API，用于模仿标准的POSIX函数的方式与文件系统进行交互。</p>
<p>引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br></pre></td></tr></table></figure>

<p>所有文件系统操作都具有同步和异步的形式；</p>
<a id="more"></a>

<h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>fs操作接受的文件路径可以指定为字符串、Buffer、或使用file：协议的URL对象。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>fs.open()方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、写入数据或请求关于文件的信息。</p>
<h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>所有的文件系统API，除了fs.FSWatcher()和那些显示同步之外，都使用libuv的线程池。</p>
<h4 id="fs-Dir类"><a href="#fs-Dir类" class="headerlink" title="fs.Dir类"></a>fs.Dir类</h4><p>目录流的类。<br>由fs.opendir(), fs.opendirSync()和fsPromises.opendir()创建。</p>
<h5 id="dir-close"><a href="#dir-close" class="headerlink" title="dir.close()"></a>dir.close()</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>返回一个Promise，将会在关闭资源之后被解决。</p>
<h5 id="dir-close-callback"><a href="#dir-close-callback" class="headerlink" title="dir.close(callback)"></a>dir.close(callback)</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>关闭资源句柄之后就会调用callback</p>
<h5 id="dir-closeSync"><a href="#dir-closeSync" class="headerlink" title="dir.closeSync()"></a>dir.closeSync()</h5><p>同步的关闭目录的底层资源句柄。</p>
<h5 id="dir-path"><a href="#dir-path" class="headerlink" title="dir.path"></a>dir.path</h5><p>此目录的只读路径。</p>
<h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>代码逐条执行，会阻塞。</p>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.openSync(path, flags[,mode])</span><br></pre></td></tr></table></figure>
<p>写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.writeSync(fd, string[, position[,encoding]])</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.closeSync(fd)</span><br></pre></td></tr></table></figure>

<h5 id="异步文件写入"><a href="#异步文件写入" class="headerlink" title="异步文件写入"></a>异步文件写入</h5><p>代码会一起执行不会阻塞。</p>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.open(path, flags[,mode], callback)</span><br></pre></td></tr></table></figure>
<p>写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.write(fd, string[, position[,encoding]], callback)</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure>

<h5 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h5><p>同步异步简单文件的写入不适合大文件的写入，性能较差，容易导致内存溢出，<br>而流式文件写入会一点一点的写进去，不会导致内存溢出的状况。</p>
<p>创建一个可写流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fs.createWriteStream(path[,options])</span><br></pre></td></tr></table></figure>
<p>打开文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const ws &#x3D; fs.createWriteStream(&#39;hello.txt&#39;)</span><br><span class="line"></span><br><span class="line">监听流可选：</span><br><span class="line">ws.once(&#39;open&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流打开了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#39;close&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流关闭了&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>通过ws向文件中输出内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.write(&#39;hhhhhhhh&#39;)</span><br><span class="line">ws.write(&#39;gggggggg&#39;)</span><br></pre></td></tr></table></figure>

<p>关闭流</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ws.end()</span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>将可读流中的内容，直接输出到可写流里。</p>
<h5 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path)"></a>fs.existsSync(path)</h5><p>检查一个文件是否存在。</p>
<h5 id="fs-stat-path-options-callback-fs-statSync-path-options"><a href="#fs-stat-path-options-callback-fs-statSync-path-options" class="headerlink" title="fs.stat(path[,options], callback) / fs.statSync(path[,options])"></a>fs.stat(path[,options], callback) / fs.statSync(path[,options])</h5><p>获取文件状态。</p>
<h5 id="fs-unlink-path-callback-fs-unlinkSync-path"><a href="#fs-unlink-path-callback-fs-unlinkSync-path" class="headerlink" title="fs.unlink(path, callback) / fs.unlinkSync(path)"></a>fs.unlink(path, callback) / fs.unlinkSync(path)</h5><p>删除文件。</p>
<h5 id="fs-readdir-path-options-callback-fs-readdirSync-path-options"><a href="#fs-readdir-path-options-callback-fs-readdirSync-path-options" class="headerlink" title="fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])"></a>fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])</h5><p>读取一个目录的目录结构。</p>
<h5 id="fs-truncate-path-len-callback-fs-truncateSync-path-len"><a href="#fs-truncate-path-len-callback-fs-truncateSync-path-len" class="headerlink" title="fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])"></a>fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])</h5><p>截断文件。</p>
<h5 id="fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode"><a href="#fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode" class="headerlink" title="fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])"></a>fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])</h5><p>创建一个文件夹。</p>
<h5 id="fs-rmdir-path-callback-fs-rmdirSync-path"><a href="#fs-rmdir-path-callback-fs-rmdirSync-path" class="headerlink" title="fs.rmdir(path, callback) / fs.rmdirSync(path)"></a>fs.rmdir(path, callback) / fs.rmdirSync(path)</h5><p>删除一个目录。</p>
<h5 id="fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath"><a href="#fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath" class="headerlink" title="fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)"></a>fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)</h5><p>重命名文件夹。</p>
<h5 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[,options], listener)"></a>fs.watchFile(filename[,options], listener)</h5><p>监视文件的修改。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之events</title>
    <url>/2020-02-01-node-events.html</url>
    <content><![CDATA[<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>事件触发器。</p>
<p>eventEmitter.on()：用于注册监听器；<br>eventEmitter.emit()：用于触发事件；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line"></span><br><span class="line">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="将参数和this传给监听器"><a href="#将参数和this传给监听器" class="headerlink" title="将参数和this传给监听器"></a>将参数和this传给监听器</h4><p>eventEmitter.emit()方法可以传任意数量的参数到监听器函数。<br>当监听器函数被调用时，this关键词被指向监听器所绑定的EventEmitter实例。<br>当使用ES6de箭头函数作为监听器，this不会指向EventEmitter实例。</p>
<h4 id="异步-VS-同步"><a href="#异步-VS-同步" class="headerlink" title="异步 VS 同步"></a>异步 VS 同步</h4><p>EventEmitter以注册的顺序同步调用所有监听器。<br>监听器函数可以使用setImmediate()和process.nextTick()方法切换到异步的操作模式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;异步地发生&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="仅处理事件一次"><a href="#仅处理事件一次" class="headerlink" title="仅处理事件一次"></a>仅处理事件一次</h4><p>eventEmitter.on()注册监听器时，监听器会在每次触发命名事件时调用。<br>eventEmitter.once()可以注册最多可调用一次的监听器，当事件被触发时，监听器会被注销，然后再调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">let m &#x3D; 0;</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 2</span><br><span class="line"></span><br><span class="line">myEmitter.once(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 不触发</span><br></pre></td></tr></table></figure>

<h4 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h4><p>EventEmitter实例出错时，应该触发error事件，<br>如果没有为error事件注册监听器，当error事件触发时，会抛出错误、打印堆栈跟踪、并退出Node进程。</p>
<p>为了防止崩溃Node进程，可以使用domain模块，不推荐。<br>最佳是应该始终为error事件注册监听器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;错误信息&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;error&#39;, new Error(&#39;错误&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印: 错误信息</span><br></pre></td></tr></table></figure>

<h4 id="EventEmitter类"><a href="#EventEmitter类" class="headerlink" title="EventEmitter类"></a>EventEmitter类</h4><p>由events模块定义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br></pre></td></tr></table></figure>
<p>当新增监听器时，会触发newListener事件；<br>当移除已存在的监听器时，则触发removeListener事件；</p>
<p>emitter.addListener(eventName, listener)：emitter.on(eventName, listener)的别名。<br>emitter.emit(eventName[, …args])：按照监听器注册的顺序，同步调用每个注册到名为eventName事件的监听器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const myEmitter &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function firstListener() &#123;</span><br><span class="line">  console.log(&#39;第一个监听器&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第二个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function secondListener(arg1, arg2) &#123;</span><br><span class="line">  console.log(&#96;第二个监听器中的事件有参数 $&#123;arg1&#125;、$&#123;arg2&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第三个监听器</span><br><span class="line">myEmitter.on(&#39;event&#39;, function thirdListener(...args) &#123;</span><br><span class="line">  const parameters &#x3D; args.join(&#39;, &#39;);</span><br><span class="line">  console.log(&#96;第三个监听器中的事件有参数 $&#123;parameters&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(myEmitter.listeners(&#39;event&#39;));</span><br><span class="line"></span><br><span class="line">myEmitter.emit(&#39;event&#39;, 1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;   [Function: firstListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: secondListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: thirdListener]</span><br><span class="line">&#x2F;&#x2F; ]</span><br><span class="line">&#x2F;&#x2F; 第一个监听器</span><br><span class="line">&#x2F;&#x2F; 第二个监听器中的事件有参数 1、2</span><br><span class="line">&#x2F;&#x2F; 第三个监听器中的事件有参数 1, 2, 3, 4, 5</span><br></pre></td></tr></table></figure>

<p>emitter.eventNames()：返回已注册监听器的事件名数组。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之error</title>
    <url>/2020-02-01-node-error.html</url>
    <content><![CDATA[<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>错误。</p>
<p>NodeJs应用程序一般会有四种错误：</p>
<ul>
<li>标准的JavaScript错误；</li>
<li>由底层操作系统触发的系统错误；</li>
<li>由应用程序代码触发的用户自定义的错误；</li>
<li>AssertionError错误，当Node监测到不应该发生的异常逻辑时触发，这类错误通常来自assert模块；</li>
</ul>
<p>所有由Nodejs引起的Javascript错误与系统错误都继承自或实例化自标准的JavaScript<Error>类，<br>且保证至少提供类中的属性。</p>
<a id="more"></a>

<h4 id="错误的冒泡和捕获"><a href="#错误的冒泡和捕获" class="headerlink" title="错误的冒泡和捕获"></a>错误的冒泡和捕获</h4><p>异常捕获处理<code>try...catch</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 抛出一个 ReferenceError，因为 z 未定义。</span><br><span class="line">try &#123;</span><br><span class="line">  const m &#x3D; 1;</span><br><span class="line">  const n &#x3D; m + z;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在这里处理错误。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调中的Error参数"><a href="#回调中的Error参数" class="headerlink" title="回调中的Error参数"></a>回调中的Error参数</h4><p>大多数Nodejs核心API所提供的异步方法都遵从错误信息优先的回调模式惯例，这种模式有时也称为Nodejs回调。</p>
<p>但JavaScript的try…catch机制不能用来截获异步方法产生的错误。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">     setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异常错误，这是因为异步函数执行上下文不同，所以捕获不到。</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了捕获异步产生的异常错误，可以用domain模块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var domain &#x3D; require(&#39;domain&#39;);</span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line">d.run(function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异步异常</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    console.log(err); &#x2F;&#x2F; 这里可以捕获异步异常</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>或者express挂载接受error函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.use(function (err,req,res,next)&#123;</span><br><span class="line">   &#x2F;&#x2F;前面的中间件的错误next(err),都在这里接收。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>new Error(message)：新建一个Error实例，创建一个异常错误对象；<br>throw new Error(message)：创建一个对象并抛出错误，如果不捕获则node崩溃；</p>
<p>error.code：标识错误类别的字符标签；<br>error.message：错误描述；<br>error.stack：一个字符串；</p>
<h4 id="AssertionError类"><a href="#AssertionError类" class="headerlink" title="AssertionError类"></a>AssertionError类</h4><p>表明断言的失败。</p>
<h4 id="ReferenceError类"><a href="#ReferenceError类" class="headerlink" title="ReferenceError类"></a>ReferenceError类</h4><p>表明试图访问一个未定义的变量。<br>此类错误通常表明代码有拼写错误或程序已损坏。</p>
<h4 id="SyntaxError类"><a href="#SyntaxError类" class="headerlink" title="SyntaxError类"></a>SyntaxError类</h4><p>表明程序不是有效的JavaScript。</p>
<h4 id="TypeError类"><a href="#TypeError类" class="headerlink" title="TypeError类"></a>TypeError类</h4><p>表明提供的参数不是被允许的类型。</p>
<h4 id="NodeJs中常用的异常处理方式"><a href="#NodeJs中常用的异常处理方式" class="headerlink" title="NodeJs中常用的异常处理方式"></a>NodeJs中常用的异常处理方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每秒钟打印一次时间，确保程序没有奔溃</span><br><span class="line">(function loop() &#123;</span><br><span class="line">    console.log(new Date().getTime())</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        loop() </span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 模拟同步代码块内出现异常</span><br><span class="line">let syncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;Sync Error&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 模拟异步代码块内出现异常</span><br><span class="line">let asyncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;Async Error&#39;)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">try &#123;</span><br><span class="line">    syncError()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;异常被捕获了，我可以继续执行&#39;)</span><br><span class="line"></span><br><span class="line">2. callback方式</span><br><span class="line">fs.mkdir(&#39;&#x2F;dir&#39;, function (e) &#123;</span><br><span class="line">    if (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;创建目录成功&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3. event方式</span><br><span class="line">let events &#x3D; require(&quot;events&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个事件监听对象</span><br><span class="line">let emitter &#x3D; new events.EventEmitter();</span><br><span class="line">&#x2F;&#x2F;监听error事件</span><br><span class="line">emitter.addListener(&quot;error&quot;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发error事件</span><br><span class="line">emitter.emit(&quot;error&quot;, new Error(&#39;出错啦&#39;));</span><br><span class="line"></span><br><span class="line">4. Promise方式</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    syncError()</span><br><span class="line">    &#x2F;* or</span><br><span class="line">    try&#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">Promise同样无法处理异步代码块中抛出的异常</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    asyncError()</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*异常无法被捕获,导致进程退出*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">5. Async&#x2F;Await方式</span><br><span class="line">var sleep &#x3D; function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await sleep(100);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">6. process方式（可以捕获任何异常，但过于笨重）</span><br><span class="line">process.on(&#39;uncaughtException&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">asyncError()</span><br><span class="line">syncError()</span><br><span class="line"></span><br><span class="line">7. domain方式（也可以处理任何异常模块）</span><br><span class="line">let domain &#x3D; require(&#39;domain&#39;)</span><br><span class="line">let d &#x3D; domain.create()</span><br><span class="line">d.on(&#39;error&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">d.run(asyncError)</span><br><span class="line">d.run(syncError)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之domain</title>
    <url>/2020-02-01-node-domain.html</url>
    <content><![CDATA[<h2 id="domain"><a href="#domain" class="headerlink" title="domain"></a>domain</h2><p>域。<br>简化了异步代码的异常处理，可以捕捉try catch无法捕捉的异常。</p>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const domain &#x3D; require(&#39;domain&#39;)</span><br></pre></td></tr></table></figure>
<p>domain模块把处理多个不同的IO操作为一个组。<br>当发生一个错误事件或抛出一个错误时，domain对象会被通知，不会丢失上下文环境，也不会导致程序错误立即退出、</p>
<h4 id="显示绑定和隐式绑定"><a href="#显示绑定和隐式绑定" class="headerlink" title="显示绑定和隐式绑定"></a>显示绑定和隐式绑定</h4><p>显示绑定：把不是在domain上下文中定义的变量，以代码的方式绑定到domain。<br>隐式绑定：把在domain上下文中定义的变量，自动绑定到domain对象。</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>domain.members：已加入domain对象的域定时器和事件发射器的数组。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>domain.run(function)：在域的上下文运行提供的函数，隐式的绑定了所有的事件分发器，计时器和底层请求。</p>
<p>doamin.add(emitter)：显示的增加事件。</p>
<p>doamin.remove(emitter)：删除事件。</p>
<p>domain.bind(callback)：返回的函数是一个对于所提供的回调函数的包装函数。当调用这个返回的函数时，所有被抛出的错误都会被导向到这个域的error事件。</p>
<p>domain.intercept(callback)：和bind类似，除了捕捉错误外，它还会拦截error对象作为参数传递到这个函数。</p>
<p>domain.enter()：进入一个异步调用的上下文，绑定到domain。</p>
<p>domain.exit()：退出当前的domain，切换到不同的链的异步调用的上下文中。</p>
<p>domain.dispose()：释放一个domain对象，让node进程回收这部分资源。</p>
<p>domain.create()：返回一个domain对象。</p>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之dns</title>
    <url>/2020-02-01-node-dns.html</url>
    <content><![CDATA[<h2 id="dns"><a href="#dns" class="headerlink" title="dns"></a>dns</h2><p>域名服务器。</p>
<p>dns模块包含了两个不同类别的函数：<br>1、使用底层操作系统工具执行名称解析但不一定执行任何网络通信的函数。<br>此类别仅包含一个函数：dns.lookup()。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.lookup(&#39;iana.org&#39;, (err, address, family) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;地址: %j 地址族: IPv%s&#39;, address, family);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 地址: &quot;192.0.43.8&quot; 地址族: IPv4</span><br></pre></td></tr></table></figure>

<p>2、连接到实际的DNS服务器以执行名称解析并始终使用网络执行DNS查询的函数。包含dns模块中除dns.lookup()之外的所有函数。<br>这些函数不使用与dns.lookup()使用的同一配置文件。<br>这些函数应该由不希望使用底层系统的工具进行名称解析、而始终执行dns查询的开发者使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dns &#x3D; require(&#39;dns&#39;);</span><br><span class="line"></span><br><span class="line">dns.resolve4(&#39;archive.org&#39;, (err, addresses) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line"></span><br><span class="line">  console.log(&#96;地址: $&#123;JSON.stringify(addresses)&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  addresses.forEach((a) &#x3D;&gt; &#123;</span><br><span class="line">    dns.reverse(a, (err, hostnames) &#x3D;&gt; &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">        throw err;</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&#96;地址 $&#123;a&#125; 逆向解析到域名: $&#123;JSON.stringify(hostnames)&#125;&#96;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200120172840178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21vXzI0Nw==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200120174218212.png" alt="在这里插入图片描述"></p>
<h3 id="rrtypes"><a href="#rrtypes" class="headerlink" title="rrtypes"></a>rrtypes</h3><p>dns.resolve() 方法中有效的 rrtypes值:</p>
<ul>
<li>‘A’ IPV4 地址, 默认；</li>
<li>‘AAAA’ IPV6 地址；</li>
<li>‘MX’ 邮件交换记录；</li>
<li>‘TXT’ text 记录；</li>
<li>‘SRV’ SRV 记录；</li>
<li>‘PTR’ 用来反向 IP 查找；</li>
<li>‘NS’ 域名服务器记录；</li>
<li>‘CNAME’ 别名记录；</li>
<li>‘SOA’ 授权记录的初始值；</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之dgram</title>
    <url>/2020-02-01-node-dgram.html</url>
    <content><![CDATA[<h2 id="dgram"><a href="#dgram" class="headerlink" title="dgram"></a>dgram</h2><p>dgram数据报提供了UDP数据包socket的实现。</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">创建dgram.Sockrt的新实例，不使用new</span><br><span class="line">const server &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line"></span><br><span class="line">error发生错误时触发</span><br><span class="line">server.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器异常：\n$&#123;err.stack&#125;&#96;);</span><br><span class="line">  关闭一个socket之后触发，一旦触发，则这个socket上将不会触发新的message事件。</span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">当有新的数据包被socket接收时，message事件会被触发</span><br><span class="line">server.on(&#39;message&#39;, (msg, rinfo) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;服务器接收到来自 $&#123;rinfo.address&#125;:$&#123;rinfo.port&#125; 的 $&#123;msg&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">开始监听数据包信息时触发</span><br><span class="line">server.on(&#39;listening&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  const address &#x3D; server.address();</span><br><span class="line">  console.log(&#96;服务器监听 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.bind(41234);</span><br><span class="line">&#x2F;&#x2F; 服务器监听 0.0.0.0:41234</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li>addMembership()<br>  添加组播成员；</li>
<li>dropMembership()<br>  删除组播成员；</li>
<li>address()<br>  返回socket地址信息对象，UDP socket对象包含address、family和port属性；</li>
<li>bind()<br>  绑定端口和主机。<br>  若端口未指定，操作系统绑定一个随机的端口；<br>  若address未指定，操作系统会尝试在所有地址上监听；</li>
<li>close()<br>  关闭该socket并停止监听其上的数据。</li>
<li>connect()<br>  关联一个远程地址和端口。</li>
<li>disconnect()<br>  与远程地址断掉的同步函数。</li>
<li>ref()<br>将socket重新添加到这个引用列表中，并恢复默认行为。</li>
<li>unref()<br>将socket从node进程的引用列表中删除。<br>socket对象不再进行通信，程序会退出。<br>即使socket对象还在坚挺数据，也允许退出。</li>
<li>send()<br>在socket上广播数据报。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const dgram &#x3D; require(&#39;dgram&#39;);</span><br><span class="line">const message &#x3D; Buffer.from(&#39;一些字节&#39;);</span><br><span class="line">const client &#x3D; dgram.createSocket(&#39;udp4&#39;);</span><br><span class="line">client.send(message, 41234, &#39;localhost&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  client.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>setTTL()<br>  设置数据报生存时间</li>
<li>setMulticastTTL()<br>  设置组播数据报生存时间</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之crypto</title>
    <url>/2020-02-01-node-crypto.html</url>
    <content><![CDATA[<h2 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h2><p>crypto模块提供了加密脑功能，包括对OpenSSL的哈希、HMAC、加密、解密、签名以及验证功能的一整套封装。</p>
<p>下面整理了一些平常经常用到的加密解密方法：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const crypto &#x3D; require(&#39;crypto&#39;);</span><br><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const Crypto &#x3D; require(&#39;cryptojs&#39;).Crypto</span><br><span class="line">const _crypto &#x3D; require(&#39;crypto&#39;)</span><br><span class="line">const cryptoJS &#x3D; require(&#39;crypto-js&#39;)</span><br><span class="line">const mode &#x3D; new Crypto.mode.CBC(Crypto.pad.pkcs7)</span><br><span class="line">const bytes &#x3D; require(&#39;utf8-bytes&#39;)</span><br><span class="line">const aesKey &#x3D; &#39;&#39;</span><br><span class="line">const aesIv &#x3D; &#39;&#39;</span><br><span class="line">const algorithm &#x3D; &#39;aes-128-cbc&#39;</span><br><span class="line"></span><br><span class="line">1. sha1</span><br><span class="line">function sha1Sign(src) &#123;</span><br><span class="line">    const sha1 &#x3D; crypto.createHash(&#39;sha1&#39;);</span><br><span class="line">    sha1.update(src);</span><br><span class="line">    return sha1.digest(&#39;hex&#39;).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function makeSalt() &#123;</span><br><span class="line">    return crypto.randomBytes(16).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. hash</span><br><span class="line">function hashPassword(password, salt) &#123;</span><br><span class="line">    assert(password &amp;&amp; salt, &#39;pwd or salt missing&#39;);</span><br><span class="line">    const _salt &#x3D; new Buffer(salt, &#39;base64&#39;);</span><br><span class="line">    return crypto.pbkdf2Sync(password, _salt, 10000, 64).toString(&#39;base64&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">4. dec</span><br><span class="line">const algorithm &#x3D; &#39;aes-256-ctr&#39;,</span><br><span class="line">    password &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">function encrypt(buffer)&#123;</span><br><span class="line">    let cipher &#x3D; crypto.createCipher(algorithm,password)</span><br><span class="line">    let crypted &#x3D; Buffer.concat([cipher.update(buffer),cipher.final()]);</span><br><span class="line">    return crypted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt(buffer)&#123;</span><br><span class="line">    let decipher &#x3D; crypto.createDecipher(algorithm,password)</span><br><span class="line">    let dec &#x3D; Buffer.concat([decipher.update(buffer) , decipher.final()]);</span><br><span class="line">    return dec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">5. des-cbc</span><br><span class="line">const desIv &#x3D; &#39;\1\2\3\4\5\6\7\x08&#39;; (在不同的语言对初始向量的处理方式不同会造成解密不完全、乱码等，需要初始向量的表现形式)</span><br><span class="line"></span><br><span class="line">function desCreateCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv ? desIv : 0);</span><br><span class="line">    &#x2F;&#x2F; encrypt</span><br><span class="line">    let cipher &#x3D; crypto.createCipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    cipher.setAutoPadding(true);</span><br><span class="line">    let ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;hex&#39;);</span><br><span class="line">    return ciph</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desDecryptCipheriv (plaintext, desKey) &#123;</span><br><span class="line">    const key &#x3D; new Buffer(desKey);</span><br><span class="line">    const iv &#x3D; new Buffer(desIv);</span><br><span class="line">    const decipher &#x3D; crypto.createDecipheriv(&#39;des-cbc&#39;, key, iv);</span><br><span class="line">    decipher.setAutoPadding(true);</span><br><span class="line">    let txt &#x3D; decipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    txt +&#x3D; decipher.final(&#39;utf8&#39;);</span><br><span class="line">    return txt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6. des-ecb</span><br><span class="line">function desEcbEncrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createCipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;base64&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function desEcbDecrypt(plaintext, key) &#123;</span><br><span class="line">    key &#x3D; new Buffer(key.substr(0, 8))</span><br><span class="line">    var cipher &#x3D; _crypto.createDecipheriv(&#39;des-ecb&#39;, key, new Buffer(0));</span><br><span class="line">    cipher.setAutoPadding(true)</span><br><span class="line">    var ciph &#x3D; cipher.update(plaintext, &#39;base64&#39;, &#39;utf8&#39;);</span><br><span class="line">    ciph +&#x3D; cipher.final(&#39;utf8&#39;);</span><br><span class="line">    return ciph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">7. md5</span><br><span class="line">function md5(Str) &#123;</span><br><span class="line">    var md5sum &#x3D; _crypto.createHash(&#39;md5&#39;)</span><br><span class="line">    md5sum.update(new Buffer(Str))</span><br><span class="line">    return md5sum.digest(&#39;hex&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function md5to16(Str) &#123;</span><br><span class="line">    let res &#x3D; md5(Str)</span><br><span class="line">    return res.substring(8, 24)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">8. dec</span><br><span class="line">function encrypt(plaintext, key) &#123;</span><br><span class="line">    var ub &#x3D; Crypto.charenc.UTF8.stringToBytes(plaintext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var eb &#x3D; Crypto.AES.encrypt(ub, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.util.bytesToBase64(eb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decrypt (ciphertext, key) &#123;</span><br><span class="line">    var eb &#x3D; Crypto.util.base64ToBytes(ciphertext)</span><br><span class="line">    var kb &#x3D; Crypto.util.base64ToBytes(key)</span><br><span class="line">    var ub &#x3D; Crypto.AES.decrypt(eb, kb, &#123;asBytes: true, mode: mode&#125;)</span><br><span class="line">    return Crypto.charenc.UTF8.bytesToString(ub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateKey (buffer) &#123;</span><br><span class="line">    if (buffer) return Crypto.util.bytesToBase64(buffer)</span><br><span class="line">    return Crypto.util.bytesToBase64(Crypto.util.randomBytes(16))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function generateEpubKey(chapterName) &#123;</span><br><span class="line">    let key &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.key&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.key&#125;&#96;)</span><br><span class="line">    let IV &#x3D; md5to16(md5(&#96;$&#123;config.epubCrypto.md5_32.IV&#125;$&#123;chapterName&#125;&#96;) + &#96;$&#123;config.epubCrypto.md5_16.IV&#125;&#96;)</span><br><span class="line">    return IV + key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function encryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createCipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decryptEpub(key) &#123;</span><br><span class="line">    return _crypto.createDecipher(&#39;aes128&#39;, key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipher(ciphertext) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipher(data) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(data, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function dictSort(obj) &#x3D;&gt; &#123;</span><br><span class="line">    const sorted &#x3D; Object.keys(obj).sort();</span><br><span class="line">    let str &#x3D; &#39;&#39;;</span><br><span class="line">    sorted.forEach((key) &#x3D;&gt; str +&#x3D; obj[key]);</span><br><span class="line">    return str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;base64&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherIv (plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;base64&#39;) + cip.final(&#39;base64&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function decipherHexIv (ciphertext, aesKey, aesIv) &#123;</span><br><span class="line">    let decip &#x3D; _crypto.createDecipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return decip.update(ciphertext, &#39;hex&#39;, &#39;utf8&#39;) + decip.final(&#39;utf8&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function cipherHexIv(plaintext, aesKey, aesIv) &#123;</span><br><span class="line">    let cip &#x3D; _crypto.createCipheriv(algorithm, aesKey, aesIv)</span><br><span class="line">    return cip.update(plaintext, &#39;utf8&#39;, &#39;hex&#39;) + cip.final(&#39;hex&#39;)</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拼接请求字符串并加密</span><br><span class="line">function hmacSHA256 (content, appKey) &#123;</span><br><span class="line">    return cryptoJS.enc.Hex.stringify(cryptoJS.HmacSHA256(content, appKey));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">9. AES解密 </span><br><span class="line">function aesDecrypt(content, keys, ivs) &#123;</span><br><span class="line">    const key &#x3D; cryptoJS.enc.Utf8.parse(keys);</span><br><span class="line">    const iv &#x3D; cryptoJS.enc.Utf8.parse(ivs);</span><br><span class="line">    const encryptedHexStr &#x3D; cryptoJS.enc.Hex.parse(content);</span><br><span class="line">    const srcs &#x3D; cryptoJS.enc.Base64.stringify(encryptedHexStr);</span><br><span class="line">    const decrypt &#x3D; cryptoJS.AES.decrypt(srcs, key, &#123;</span><br><span class="line">        iv: iv,</span><br><span class="line">        mode: cryptoJS.mode.CBC,</span><br><span class="line">        padding: cryptoJS.pad.Pkcs7</span><br><span class="line">    &#125;);</span><br><span class="line">    const decryptedStr &#x3D; decrypt.toString(cryptoJS.enc.Utf8);</span><br><span class="line">    return decryptedStr.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之cluster</title>
    <url>/2020-02-01-node-cluster.html</url>
    <content><![CDATA[<h2 id="cluster"><a href="#cluster" class="headerlink" title="cluster"></a>cluster</h2><p>集群<br>单个Nodejs实例运行在单个线程中，为充分利用多核系统，需要启用一组Node进程处理负载任务。</p>
<p>cluster允许建立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。<br>worker之间采用进程通信交换消息，cluster模块内置一个负载均衡。</p>
<p>cluster集成两个方面：</p>
<ul>
<li>集成了child_process.fork方法创建node子进程的方式；</li>
<li>继承了很多多核cpu创建子进程后，自动控制负载均衡的方式；</li>
</ul>
<a id="more"></a>

<p>cluster模块可以创建共享服务器端口的子进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const numCPUs &#x3D; require(&#39;os&#39;).cpus().length;</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#96;主进程 $&#123;process.pid&#125; 正在运行&#96;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 衍生工作进程。</span><br><span class="line">  for (let i &#x3D; 0; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作进程 $&#123;worker.process.pid&#125; 已退出&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程可以共享任何 TCP 连接。</span><br><span class="line">  &#x2F;&#x2F; 在本例子中，共享的是 HTTP 服务器。</span><br><span class="line">  http.createServer((req, res) &#x3D;&gt; &#123;</span><br><span class="line">    res.writeHead(200);</span><br><span class="line">    res.end(&#39;你好世界\n&#39;);</span><br><span class="line">  &#125;).listen(8000);</span><br><span class="line"></span><br><span class="line">  console.log(&#96;工作进程 $&#123;process.pid&#125; 已启动&#96;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主进程 3596 正在运行</span><br><span class="line">工作进程 4324 已启动</span><br><span class="line">工作进程 4520 已启动</span><br><span class="line">工作进程 6056 已启动</span><br><span class="line">工作进程 5644 已启动</span><br></pre></td></tr></table></figure>

<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>cluster支持两种分发连接方法：</p>
<ol>
<li>循环法，由主进程负责监听端口，接收新连接后再将连接循环发给工作进程，在分发中使用了一些内置技巧防止工作进程中任务过载；</li>
<li>主进程创建监听socket后发送给感兴趣的工作进程，由工作进程负责直接接收连接；</li>
</ol>
<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker对象包含了关于工作进程的所有的公共的信息和方法。<br>主进程中，使用cluster.workers获取<br>工作进程中，使用cluster.worker获取</p>
<h4 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>断开连接</p>
<h4 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h4><p>工作进程中，可以使用process.on(‘error’)</p>
<h4 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const worker &#x3D; cluster.fork();</span><br><span class="line">worker.on(&#39;exit&#39;, (code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (signal) &#123;</span><br><span class="line">    console.log(&#96;工作进程已被信号 $&#123;signal&#125; 杀死&#96;);</span><br><span class="line">  &#125; else if (code !&#x3D;&#x3D; 0) &#123;</span><br><span class="line">    console.log(&#96;工作进程退出，退出码: $&#123;code&#125;&#96;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;工作进程成功退出&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="listening事件"><a href="#listening事件" class="headerlink" title="listening事件"></a>listening事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.fork().on(&#39;listening&#39;, (address) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程正在监听。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h4><p>在工作进程内，也可以使用 process.on(‘message’)</p>
<h4 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.fork().on(&#39;online&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 工作进程已上线。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="worker-disconnect"><a href="#worker-disconnect" class="headerlink" title="worker.disconnect()"></a>worker.disconnect()</h4><p>在一个工作进程内，调用此方法会关闭所有的 server，并等待这些 server 的 ‘close’ 事件执行，然后关闭 IPC 管道。</p>
<p>在主进程内，会给工作进程发送一个内部消息，导致工作进程自身调用 .disconnect()</p>
<h4 id="worker-exitedAfterDisconnect"><a href="#worker-exitedAfterDisconnect" class="headerlink" title="worker.exitedAfterDisconnect"></a>worker.exitedAfterDisconnect</h4><p>如果工作进程由于 .kill() 或 .disconnect() 而退出，则此属性为 true。<br>如果工作进程以任何其他方式退出，则为 false。<br>如果工作进程尚未退出，则为 undefined。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  if (worker.exitedAfterDisconnect &#x3D;&#x3D;&#x3D; true) &#123;</span><br><span class="line">    console.log(&#39;这是自发退出，无需担心&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 杀死工作进程。</span><br><span class="line">worker.kill();</span><br></pre></td></tr></table></figure>

<h4 id="worker-id"><a href="#worker-id" class="headerlink" title="worker.id"></a>worker.id</h4><p>每一个新衍生的工作进程都会被赋予自己独一无二的编号，这个编号就是储存在 id 里面。</p>
<h4 id="worker-isConnected"><a href="#worker-isConnected" class="headerlink" title="worker.isConnected()"></a>worker.isConnected()</h4><p>当工作进程通过 IPC 管道连接至主进程时，这个方法返回 true，否则返回 false。<br>一个工作进程在创建后会自动连接到它的主进程。<br>当 ‘disconnect’ 事件被触发时才会断开连接。</p>
<h4 id="worker-isDead"><a href="#worker-isDead" class="headerlink" title="worker.isDead()"></a>worker.isDead()</h4><p>当工作进程被终止时（包括自动退出或被发送信号），这个方法返回 true。 否则，返回 false。</p>
<h4 id="worker-kill-signal-’SIGTERM’"><a href="#worker-kill-signal-’SIGTERM’" class="headerlink" title="worker.kill([signal=’SIGTERM’])"></a>worker.kill([signal=’SIGTERM’])</h4><p>杀死工作进程。<br>主进程，通过断开与worker.process的连接来实现，一旦断开连接，通过signal杀死工作进程；<br>工作进程，通过断开IPC管道来实现，然后以代码0退出进程；</p>
<h4 id="worker-process"><a href="#worker-process" class="headerlink" title="worker.process"></a>worker.process</h4><p>所有的工作都通过child_process.fork()创建，返回的对象被存储为.process。工作进程中，process属于全局对象。</p>
<p>当process发生disconnect事件，且.exitedAfterDisconnect的值不是true时，工作进程会调用process.exit(0)来防止连接意外断开。</p>
<h4 id="worker-send"><a href="#worker-send" class="headerlink" title="worker.send()"></a>worker.send()</h4><p>发送消息给主进程或工作进程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  const worker &#x3D; cluster.fork();</span><br><span class="line">  worker.send(&#39;你好&#39;);</span><br><span class="line"></span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  process.on(&#39;message&#39;, (msg) &#x3D;&gt; &#123;</span><br><span class="line">    process.send(msg);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="disconnect事件-1"><a href="#disconnect事件-1" class="headerlink" title="disconnect事件"></a>disconnect事件</h4><p>工作进程的IPC管道被断开后触发。<br>可能导致触发的原因：</p>
<ul>
<li><p>工作进程优雅的退出；</p>
</li>
<li><p>被杀死；</p>
</li>
<li><p>手动断开连接；</p>
<p>‘disconnect’ 和 ‘exit’ 事件之间可能存在延迟。 这些事件可以用来检测进程是否在清理过程中被卡住，或是否存在长时间运行的连接。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;disconnect&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;工作进程 #$&#123;worker.id&#125; 已断开连接&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="exit事件-1"><a href="#exit事件-1" class="headerlink" title="exit事件"></a>exit事件</h4><p>当任何一个工作进程关闭的时候，cluster模块都会触发exit事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程 %d 关闭 (%s). 重启中...&#39;,</span><br><span class="line">              worker.process.pid, signal || code);</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="fork事件"><a href="#fork事件" class="headerlink" title="fork事件"></a>fork事件</h4><p>当新的工作进程被衍生时，cluster触发fork事件。<br>可以被用来记录工作进程活动，并产生一个自定义的超时。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const timeouts &#x3D; [];</span><br><span class="line">function errorMsg() &#123;</span><br><span class="line">  console.error(&#39;连接出错&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cluster.on(&#39;fork&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  timeouts[worker.id] &#x3D; setTimeout(errorMsg, 2000);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">&#125;);</span><br><span class="line">cluster.on(&#39;exit&#39;, (worker, code, signal) &#x3D;&gt; &#123;</span><br><span class="line">  clearTimeout(timeouts[worker.id]);</span><br><span class="line">  errorMsg();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="listening事件-1"><a href="#listening事件-1" class="headerlink" title="listening事件"></a>listening事件</h4><p>当工作进程调用listen()后，工作进程上的server会触发listening事件，<br>同时主进程上的cluster会触发listening事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker 包含了工作进程对象</span><br><span class="line">address 包含了以下的连接属性：address、 port 和 addressType。 </span><br><span class="line"></span><br><span class="line">cluster.on(&#39;listening&#39;, (worker, address) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#96;工作进程已连接到 $&#123;address.address&#125;:$&#123;address.port&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>addressType 可选值包括:</p>
<ul>
<li>4 (TCPv4) </li>
<li>6 (TCPv6)</li>
<li>-1 (Unix 域 socket)</li>
<li>‘udp4’ or ‘udp6’ (UDP v4 或 v6)</li>
</ul>
<h4 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h4><p>当集群主进程从任何工作进程接收到消息时触发。</p>
<h4 id="online事件-1"><a href="#online事件-1" class="headerlink" title="online事件"></a>online事件</h4><p>当衍生一个新的工作进程后，工作进程会响应一个上线消息。<br>当主进程收到上线消息后悔触发此事件。</p>
<p>当主进程衍生工作进程时触发fork；<br>当工作进程运行时触发online；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster.on(&#39;online&#39;, (worker) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;工作进程被衍生后响应&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="setup事件"><a href="#setup事件" class="headerlink" title="setup事件"></a>setup事件</h4><p>每当.setupMaster()被调用时触发。</p>
<h4 id="cluster-disconnect"><a href="#cluster-disconnect" class="headerlink" title="cluster.disconnect()"></a>cluster.disconnect()</h4><p>cluster.workers的每个工作进程中调用.disconnect()</p>
<h4 id="cluster-fork"><a href="#cluster-fork" class="headerlink" title="cluster.fork()"></a>cluster.fork()</h4><p>衍生出一个新的工作进程，只能通过主进程调用。</p>
<h4 id="cluster-isMaster"><a href="#cluster-isMaster" class="headerlink" title="cluster.isMaster"></a>cluster.isMaster</h4><p>如果进程是主进程，则为true。</p>
<h4 id="cluster-isWorker"><a href="#cluster-isWorker" class="headerlink" title="cluster.isWorker"></a>cluster.isWorker</h4><p>如果进程不是主进程，则为true。</p>
<h4 id="cluster-schdulingPolicy"><a href="#cluster-schdulingPolicy" class="headerlink" title="cluster.schdulingPolicy"></a>cluster.schdulingPolicy</h4><p>调度策略。</p>
<h4 id="cluster-settings"><a href="#cluster-settings" class="headerlink" title="cluster.settings"></a>cluster.settings</h4><p>调用.setupMaster()或.fork()之后，这个配置对象将会包含这些配置项，包括默认值。</p>
<h4 id="cluster-setupMaster"><a href="#cluster-setupMaster" class="headerlink" title="cluster.setupMaster()"></a>cluster.setupMaster()</h4><p>setupMaster用于修改默认的fork行为，一旦调用，会按照cluster.settings进行设置。<br>所有的设置只对后来的.fork()调用有效，对之前的工作进程无影响。<br>唯一无法通过.setupMaster()设置的属性是传给.fork()的env属性。<br>只能由主进程调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">上述的默认值只在第一次调用时有效，当后续调用时，将采用 cluster.setupMaster() 调用时的当前值。</span><br><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;https&#39;],</span><br><span class="line">  silent: true</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; https 工作进程</span><br><span class="line">cluster.setupMaster(&#123;</span><br><span class="line">  exec: &#39;worker.js&#39;,</span><br><span class="line">  args: [&#39;--use&#39;, &#39;http&#39;]</span><br><span class="line">&#125;);</span><br><span class="line">cluster.fork(); &#x2F;&#x2F; http 工作进程</span><br></pre></td></tr></table></figure>

<h4 id="cluster-worker"><a href="#cluster-worker" class="headerlink" title="cluster.worker"></a>cluster.worker</h4><p>当前工作进程对象的引用，对于主进程是无用的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cluster &#x3D; require(&#39;cluster&#39;);</span><br><span class="line"></span><br><span class="line">if (cluster.isMaster) &#123;</span><br><span class="line">  console.log(&#39;这是主进程&#39;);</span><br><span class="line">  cluster.fork();</span><br><span class="line">  cluster.fork();</span><br><span class="line">&#125; else if (cluster.isWorker) &#123;</span><br><span class="line">  console.log(&#96;这是工作进程 #$&#123;cluster.worker.id&#125;&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cluster-workers"><a href="#cluster-workers" class="headerlink" title="cluster.workers"></a>cluster.workers</h4><p>一个哈希表，储存了活跃的工作进程对象，id作为键名。<br>只能在主进程中调用。<br>工作进程断开连接及退出后，将会从cluster.workers里面移除。<br>移除工作在disconnect和exit两个事件中的最后一个触发之前完成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 遍历所有工作进程。</span><br><span class="line">function eachWorker(callback) &#123;</span><br><span class="line">  for (const id in cluster.workers) &#123;</span><br><span class="line">    callback(cluster.workers[id]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">eachWorker((worker) &#x3D;&gt; &#123;</span><br><span class="line">  worker.send(&#39;通知所有工作进程&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">使用工作进程的唯一 id 是定位工作进程最简单的方式。</span><br><span class="line">socket.on(&#39;data&#39;, (id) &#x3D;&gt; &#123;</span><br><span class="line">  const worker &#x3D; cluster.workers[id];</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之child_process</title>
    <url>/2020-02-01-node-child-process.html</url>
    <content><![CDATA[<h2 id="child-process"><a href="#child-process" class="headerlink" title="child_process"></a>child_process</h2><p>child_process提供了衍生子进程的能力。</p>
<p>node单线程的问题就是会导致无法充分利用CPU等资源，通过child_process实现子进程，从而实现1个主进程(master)，多个子进程的模式(工作进程)。</p>
<a id="more"></a>

<h4 id="创建异步的子进程"><a href="#创建异步的子进程" class="headerlink" title="创建异步的子进程"></a>创建异步的子进程</h4><ul>
<li><p>child_process.exec(command[, options][, callback])<br>执行的是非node程序，是一个shell命令，执行结果以回调的形式返回。</p>
<p>  【注意】</p>
<pre><code> 1、command 是一个 shell 命令的字符串，一般是 shell 内置的 命令或shell脚本组成的文件，如 ls、cat、start.sh等，包含了命令的参数；
2、可以使用 callback；
3、执行成功，error为null；失败，error为Error的实例，error.code为错误码；
4、若timeout大于0，则当子进程运行超过timeout毫秒，会给进程发送killSignal指定的信号；</code></pre> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; exec &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">exec(&#39;cat *.js missing_file | wc -l&#39;, (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    console.error(&#96;执行的错误: $&#123;error&#125;&#96;);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&#96;stdout: $&#123;stdout&#125;&#96;);</span><br><span class="line">  console.error(&#96;stderr: $&#123;stderr&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">   2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const exec &#x3D; util.promisify(require(&#39;child_process&#39;).exec);</span><br><span class="line"></span><br><span class="line">async function lsExample() &#123;</span><br><span class="line">  const &#123; stdout, stderr &#125; &#x3D; await exec(&#39;ls&#39;);</span><br><span class="line">  console.log(&#39;stdout:&#39;, stdout);</span><br><span class="line">  console.error(&#39;stderr:&#39;, stderr);</span><br><span class="line">&#125;</span><br><span class="line">lsExample();</span><br></pre></td></tr></table></figure>
</li>
<li><p>child_process.execFile(file[, args][, options][, callback])<br>执行的是非node程序，是一个可执行文件或应用，执行结果以回调的形式返回。</p>
<p> 【注意】<br> 1、比exec更高效，更安全；<br> 2、命令的参数只能作为第二个参数传递；<br> 3、默认情况下不会衍生 shell（和exec的最大差别），指定的可执行 file 直接作为新进程衍生；<br> 3、file 是要运行的可执行文件的名称或路径，如 node.exe，不能是 start.js 这种脚本文件；<br> 4、不支持I/O重定向，文件glob等；</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 回调函数</span><br><span class="line">const &#123; execFile &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const child &#x3D; execFile(&#39;node&#39;, [&#39;--version&#39;], (error, stdout, stderr) &#x3D;&gt; &#123;</span><br><span class="line">  if (error) &#123;</span><br><span class="line">    throw error;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. Promise</span><br><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const execFile &#x3D; util.promisify(require(&#39;child_process&#39;).execFile);</span><br><span class="line">async function getVersion() &#123;</span><br><span class="line">  const &#123; stdout &#125; &#x3D; await execFile(&#39;node&#39;, [&#39;--version&#39;]);</span><br><span class="line">  console.log(stdout);</span><br><span class="line">&#125;</span><br><span class="line">getVersion();</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>child_process.spawn(command[, args][, options])<br>执行的是非node程序，是一个shell命令，不需要获取执行结果，执行结果以流的形式返回。</p>
<p> 【注意】<br> 1、 使用给定的 command 衍生一个新进程，并带上 args 中的命令行参数，默认是空数组；<br> 2、以流的形式，可以减少内存占用提高输入输出效率；</p>
</li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 检查失败的spawn</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const subprocess &#x3D; spawn(&#39;bad_command&#39;);</span><br><span class="line"></span><br><span class="line">subprocess.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;启动子进程失败&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">2. 运行ls -lh &#x2F;usr，并捕获stdout、stderr、退出码</span><br><span class="line">const &#123; spawn &#125; &#x3D; require(&#39;child_process&#39;);</span><br><span class="line">const ls &#x3D; spawn(&#39;ls&#39;, [&#39;-lh&#39;, &#39;&#x2F;usr&#39;]);</span><br><span class="line"></span><br><span class="line">ls.stdout.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;stdout: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.stderr.on(&#39;data&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#96;stderr: $&#123;data&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">ls.on(&#39;close&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;子进程退出，退出码 $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><ul>
<li><p>child_process.fork(modulePath[, args][, options])<br>执行的是node程序，是一个.js文件，不需要获取执行结果，执行结果以流的形式返回，fork出来的进程一定是node进程。</p>
<p>  【注意】<br> 1、专门用于衍生新的 node进程；<br> 2、返回子进程ChildProcess对象，并内置为一个额外的IPC通信通道，允许消息在父进程和子进程之间来回传递，子进程独立于父进程；<br> 3、modulePath 要在node子进程中运行的模块，由于是 node.js 的进程，所以可以是 .js 文件；<br> 4、无回调，参数要以第二个参数传入；</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过process.on(&#39;message&#39;)和process.send()的机制来接收和发送消息</span><br><span class="line">child.js</span><br><span class="line">process.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">   process.send(msg)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">parent.js</span><br><span class="line">let cp&#x3D;require(&#39;child_process&#39;);</span><br><span class="line">let child&#x3D;cp.fork(&#39;.&#x2F;child&#39;);</span><br><span class="line">child.on(&#39;message&#39;,function(msg)&#123;</span><br><span class="line">  console.log(&#39;got a message is&#39;,msg);</span><br><span class="line">&#125;);</span><br><span class="line">child.send(&#39;hello world&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; child.disconnect() 父进程中调用， 断开父子间IPC通信</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; got a message is hello world</span><br></pre></td></tr></table></figure>

<h4 id="ChildProcess类"><a href="#ChildProcess类" class="headerlink" title="ChildProcess类"></a>ChildProcess类</h4><p>1、childProcess的实例代表衍生的子进程；<br>2、每个实例都有stdout、stdin、stderr三个流对象；</p>
<ul>
<li><p>subprocess.stderr 子进程的stderr可读流，subprocess.stderr 是 subprocess.stdio[2] 的别名。 两个属性都将会指向相同的值；</p>
</li>
<li><p>subprocess.stdin 子进程的stdin的可写流，subprocess.stdin 是 subprocess.stdio[0] 的别名。 两个属性都将会指向相同的值；</p>
</li>
<li><p>subprocess.stdio 一个到子进程的稀疏数组，subprocess.stdio[0]、 subprocess.stdio[1] 和 subprocess.stdio[2] 也分别可用作 subprocess.stdin、 subprocess.stdout 和 subprocess.stderr；</p>
</li>
<li><p>subprocess.stdout 子进程的stdout的可读流，subprocess.stdout 是 subprocess.stdio[1] 的别名。 两个属性都将会指向相同的值；</p>
</li>
</ul>
<p>3、通过fork产生的子进程与父进程可以用send即监听message来相互通信；<br>4、事件：error、close、message、exit、disconnect</p>
<ul>
<li>close当子进程的stdio流已被关闭时会触发close事件；</li>
<li>disconnect断开连接，不再发送或接收消息；</li>
<li>error出现情况有4中：<br>  1）无法衍生进程；<br>  2）无法杀死进程；<br>  3）向子进程发送消息失败；</li>
<li>exit子进程结束后退出，但子进程的stdio流可能仍然是打开的；</li>
<li>message子进程使用process.send()发送消息时会触发message事件；</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之buffer</title>
    <url>/2020-02-01-node-buffer.html</url>
    <content><![CDATA[<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Buffer类是作为Node API的一部分引入的，用于在TCP流、文件系统操作及其他上下文中与八位字节流进行交互。<br>一个更好的操作二进制数据的类。<br>暂时存放输入输出数据的一段内存。</p>
<ul>
<li>Buffer的大小在创建的时候确定，且无法更改；</li>
<li>Buffer类在全局作用域中，所以无需引用require(‘buffer’)；</li>
<li>分配的内存不在V8内存中，而是在node的C++层实现的；</li>
<li>采用slab分配机制，slab是动态内存管理机制，分为full(完全分配状态)、partial(部分分配状态)、empty(未分配状态)；</li>
</ul>
<a id="more"></a>

<p><strong>创建Buffer：</strong></p>
<ul>
<li>Buffer.alloc(size，string， encoding)<br>  必填：size<br>  非必填：string、encoding<br>  创建的buffer是被初始化的，Buffer的每一项都用00填充</li>
<li>Buffer.allocUnsafe(size，string， encoding)<br>  创建的Buffer并没有经过初始化，在内存中只要有闲置的buffer就使用。创建Buffer使得内存分配非常快，但已分配的内存段可能包含敏感的数据，有明显性能优势却不安全。</li>
</ul>
<p> <strong>根据内容直接创建buffer：</strong></p>
<ul>
<li><p>Buffer.from(buffer)</p>
</li>
<li><p>Buffer.from(array)</p>
</li>
<li><p>Buffer.from(string, encoding)<br>  必填：string<br>  非必填：encoding</p>
<ul>
<li>Buffer.from(buffer)<br> 参数为buffer的时候，会创建一个新的buffer并复制上面的每一个成员；<br> Buffer为引用类型，一个Buffer复制另一个buffer的成员，当其中一个Buffer复制的成员更改，另一个Buffer对应成员跟着改变。</li>
</ul>
</li>
</ul>
<p>  <strong>操作Buffer：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 检查下buffer的结构</span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">buf.toJSON()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer里存的是16进制数字，按照字节长度计算</span><br><span class="line">buf.length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写入数据到buffer</span><br><span class="line">buf.write()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解码buffer</span><br><span class="line">buf.toString()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; buffer拼接</span><br><span class="line">buf.concat(list[, totalLength])</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断对象是否为 Buffer</span><br><span class="line">Buffer.isBuffer</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 判断 Buffer 对象编码</span><br><span class="line">Buffer.isEncoding</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 和数组的 indexOf 类似，返回某字符串、acsii 码或者 buf 在改 buf 中的位置</span><br><span class="line">buf.indexOf</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将一个 buf 的（部分）内容复制到另外一个 buf 中</span><br><span class="line">buf.copy</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之async_hooks</title>
    <url>/2020-02-01-node-async-hooks.html</url>
    <content><![CDATA[<h2 id="async-hooks"><a href="#async-hooks" class="headerlink" title="async_hooks"></a>async_hooks</h2><p>异步钩子；<br>提供了一组API用来跟踪Nodejs的异步资源(asynchronous resources)的生命周期；</p>
<p>特性：</p>
<ol>
<li>每个函数都会提供一个上下文，为async scope（node为每个函数都提供了一个async scope）;</li>
<li>每个async scope都有一个asyncId标志，最外层的asyncId是1，每个异步资源在创建时asyncId是全量递增的；</li>
<li>同步函数不会改变其调用者的asyncId；</li>
<li>同一个函数，不同时刻进行异步调用，会分配不同的asyncId；</li>
<li>triggerAsyncId当前函数调用者的asyncId；</li>
<li>executionAsyncId当前函数的asyncId；</li>
</ol>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;)</span><br><span class="line">const async_hooks &#x3D; require(&#39;async_hooks&#39;)</span><br><span class="line"></span><br><span class="line">const eid &#x3D; async_hooks.executionAsyncId()</span><br><span class="line">const tid &#x3D; async_hooks.triggerAsyncId()</span><br><span class="line">console.log(&#96;executionAsyncId: $&#123;eid&#125;, triggerAsyncId: $&#123;tid&#125;&#96;)</span><br><span class="line"></span><br><span class="line">const asyncHooks &#x3D; async_hooks.createHook(&#123;</span><br><span class="line">    &#x2F;&#x2F; fs.writeSync向控制台打印消息，不可用console.log，因为它是一个异步调用，再次使用会触发hook事件，造成无限循环。</span><br><span class="line">    init(asyncId, type, triggerAsyncId, resource) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;init start: asyncId-$&#123;asyncId&#125;, type-$&#123;type&#125;, triggerAsyncId-$&#123;triggerAsyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    before(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;before: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    after(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;after: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroy(asyncId) &#123;</span><br><span class="line">        fs.writeSync(1, &#96;destroy: asyncId-$&#123;asyncId&#125;\n &#96;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 启动跟踪</span><br><span class="line">asyncHooks.enable()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; asyncHooks.disable()</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="https://img-blog.csdnimg.cn/20191218171717821.png" alt="在这里插入图片描述"></p>
<ul>
<li><p>async_hooks.createHook(callbacks)<br>  创建一个hook，初始化hook的声明周期的工厂方法。<br>  用来跟踪应用中的异步资源，当资源在被初始化，回调之前，回调之后，销毁后，自动触发init，before，after，destory。</p>
</li>
<li><p>asyncHooks.enable()<br>  启用跟踪</p>
</li>
<li><p>asyncHooks.disable()<br>  关闭跟踪</p>
</li>
<li><p>init(asyncId, type, triggerAsyncId, resource)<br>  asyncId：代表当前异步资源的ID，每个异步资源都会生成一个唯一性标志；<br>  type：表示该资源的类型；<br>  triggerAsyncId：调用者的asyncId，即触发当前异步资源被创建的对应的async scope的asyncid；<br>  resource：被初始化的异步资源包含的一些信息；</p>
</li>
<li><p>before(asyncId)<br>  在asyncId对应的异步资源操作完成后，准备执行回调函数前被调用，由回调的次数决定执行的次数。</p>
</li>
<li><p>after(asyncId)<br>  异步资源操作完成后立即被调用。</p>
</li>
<li><p>destroy(asyncId)<br>  asyncid被销毁时调用</p>
</li>
<li><p>promiseResolve(asyncId)</p>
</li>
<li><p>async_hooks.executionAsyncId()<br>  当前异步资源的ID</p>
</li>
<li><p>async_hooks.triggerAsyncId()<br>  调用者的ID</p>
</li>
</ul>
<ul>
<li>Promise执行跟踪<br>  PromiseResolve(asyncId)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Promise.resolve(1729).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;Promise resolve: executionAsyncId: $&#123;async_hooks.executionAsyncId()&#125;, triggerAsyncId: $&#123;async_hooks.triggerAsyncId()&#125;&#96;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>NodeJs之assert</title>
    <url>/2020-02-01-node-assert.html</url>
    <content><![CDATA[<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p>断言模块，断言测试、用于测试不变量；<br>发现代码问题、定位问题；<br>对代码的可维护性、代码重构及后期功能扩展有重要意义；</p>
<a id="more"></a>

<ul>
<li><p>assert.AssertionError类<br>表明断言的失败，assert所有的错误都是AssertionError类的实例。</p>
</li>
<li><p>严格模式：严格相等和不相等判断<br>严格相等满足‘===’<br>assert.deepEqual(actual, expected[, message])</p>
</li>
<li><p>相等和不相等判断<br>assert.equal(actual, expected[, message])</p>
</li>
<li><p>深度匹配和不匹配判断<br>assert.deepEqual(actual, expected[,message])<br>assert.notDeepEqual(actual, expected[,message])</p>
</li>
<li><p>错误：抛出断言异常<br>assert.fail([message])</p>
</li>
<li><p>抛出异常<br>assert.throws(fn[, error][,message])</p>
</li>
<li><p>判断是否为假<br>assert.ifError(value)</p>
</li>
<li><p>判断是否为真<br>assert.ok(value[, message])</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AssertionError: 假值</span><br><span class="line">assert.ok(false, &#39;假值&#39;);</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>编程常用的工具汇总</title>
    <url>/2020-01-31-code-tools.html</url>
    <content><![CDATA[<p>1、在线工具汇总：<a href="https://tool.lu；" target="_blank" rel="noopener">https://tool.lu；</a><br>2、草料二维码生成器：<a href="https://cli.im/text；" target="_blank" rel="noopener">https://cli.im/text；</a><br>3、正则表达式工具：<a href="https://tool.lu/regex/；" target="_blank" rel="noopener">https://tool.lu/regex/；</a><br>4、JSON在线解析及格式化验证：<a href="https://www.json.cn；" target="_blank" rel="noopener">https://www.json.cn；</a><br>5、在线编码转换：<a href="http://tool.oschina.net/encode?type=4；" target="_blank" rel="noopener">http://tool.oschina.net/encode?type=4；</a></p>
]]></content>
      <categories>
        <category>code-tools</category>
      </categories>
      <tags>
        <tag>code-tools</tag>
      </tags>
  </entry>
  <entry>
    <title>解决出现Cannot find module &#39;XXX’的错误</title>
    <url>/2020-01-31-node-cannot-find-module.html</url>
    <content><![CDATA[<p>在进行webpack打包的时候，会出现Cannot find module ‘XXX’的错误，找不到某个模块的错误，今天给出解决方法：</p>
<p>1、直接进行npm install重新打包；<br>2、如果npm install重新打包之后，仍然出现这个问题，可以进行删除node_modules文件夹，同时清除缓存，如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line"></span><br><span class="line">npm cache clean --force</span><br><span class="line"></span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>删除node_modules文件夹</title>
    <url>/2020-01-31-node-modules.html</url>
    <content><![CDATA[<p>有时候很难直接删除node_modules文件夹，以下提供两种删除node_modules文件夹的方法：<br>1、如果能够直接右击鼠标删除文件夹，则直接执行删除 ；<br>2、否则</p>
<ul>
<li><p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cnpm install rimraf -g</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rimraf node_modules</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>node_modules</category>
      </categories>
      <tags>
        <tag>node_modules</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2020-01-30-git.html</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clone远程工程：</span><br><span class="line">    git clone https:&#x2F;&#x2F;xxxx.git</span><br><span class="line"></span><br><span class="line">fetch远程分支到本地某分支：</span><br><span class="line">    git fetch origin &lt;originname&gt;:&lt;clonename&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看分支：</span><br><span class="line">    git branch</span><br><span class="line"></span><br><span class="line">查看远程所有分支：</span><br><span class="line">    git branch -r</span><br><span class="line"></span><br><span class="line">查看本地和远程所有分支：</span><br><span class="line">    git branch -a</span><br><span class="line"></span><br><span class="line">创建分支：</span><br><span class="line">    git branch &lt;name&gt;</span><br><span class="line"></span><br><span class="line">切换分支：</span><br><span class="line">    git checkout &lt;name&gt;</span><br><span class="line"></span><br><span class="line">创建并切换分支：</span><br><span class="line">    git checkout -b &lt;name&gt;</span><br><span class="line"></span><br><span class="line">合并某分支到当前分支：</span><br><span class="line">    git merge &lt;name&gt;</span><br><span class="line"></span><br><span class="line">把分支推送到远程：</span><br><span class="line">    git push origin &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除本地分支：</span><br><span class="line">    git branch (-d|-D) &lt;name&gt;</span><br><span class="line"></span><br><span class="line">删除远程分支：</span><br><span class="line">    git push origin -d &lt;name&gt;</span><br><span class="line"></span><br><span class="line">分支重命名：</span><br><span class="line">    git branch (-m|-M) &lt;oldbranch&gt; &lt;newbranch&gt;</span><br><span class="line"></span><br><span class="line">查看分支最近一次的修改列表：</span><br><span class="line">    git status</span><br><span class="line"></span><br><span class="line">查看分支的commit信息（倒序）：</span><br><span class="line">    git log: (commit id,Author,Date,Commit info)；</span><br><span class="line">    git shortlog:按提交者分类显示所有提交信息；</span><br><span class="line">    git log --online:只输出commit id和commit info；</span><br><span class="line">    git log --stat：查看增删改查了哪些文件；</span><br><span class="line"></span><br><span class="line">版本回退：</span><br><span class="line">    回退到上一版本：git reset --hard HEAD^</span><br><span class="line">    回退到上上版本：git reset --hard HEAD^^</span><br><span class="line">                 git reset --hard HEAD~2</span><br><span class="line">    回退到某个版本：git reset --hard &lt;commit id&gt;</span><br><span class="line">    强制推送到远程分支：git push -f</span><br><span class="line"></span><br><span class="line">    注意：</span><br><span class="line">        HEAD：指向的版本是当前版本，^表示上一个版本，~N表示上N个版本，&lt;commit id&gt;可简写</span><br><span class="line">        git log：查看&lt;commit id&gt;</span><br><span class="line">        git reflog:查看命令历史，回退到某个未来的版本；</span><br><span class="line"></span><br><span class="line">文件增加、提交、拉取、推送、比对、合并</span><br><span class="line">    添加新增文件：git add README.md</span><br><span class="line">    添加所有新增文件：git add .</span><br><span class="line">    暂存变更文件：git stash [save &quot;暂存备注&quot;]</span><br><span class="line">    恢复暂存文件：git stash pop</span><br><span class="line">    提交变更文件：git commit -m &quot;变更备注&quot;</span><br><span class="line">    拉取远程代码：git pull [origin &lt;name&gt;]</span><br><span class="line">    推送到远程：git push origin &lt;name&gt;</span><br><span class="line">    比对两个分支：git diff &lt;name1&gt; &lt;name2&gt;</span><br><span class="line">    比对两个分支变更的文件列表：git diff &lt;name1&gt; &lt;name2&gt; --stat</span><br><span class="line">    比对本地和远程分支：git diff &lt;name&gt; origin&#x2F;&lt;name&gt;</span><br><span class="line">    合并某个分支：git merge &lt;name&gt;</span><br><span class="line">    强制覆盖本地分支：  </span><br><span class="line">        git fetch --all</span><br><span class="line">        git reset  --hard origin&#x2F;&lt;name&gt;</span><br><span class="line">        git pull</span><br><span class="line"></span><br><span class="line">常用选项和其他命令</span><br><span class="line">    git中部分选项解释</span><br><span class="line">        -f --force：强制</span><br><span class="line">        -d --delete：删除</span><br><span class="line">        -D --delete --force</span><br><span class="line">        -m --move：移动或重命名</span><br><span class="line">        -M --remote：远程</span><br><span class="line">        -a --all：所有</span><br><span class="line"></span><br><span class="line">    其他命令</span><br><span class="line">        清空工程：</span><br><span class="line">            $ git rm -rf .</span><br><span class="line">        每隔X秒运行一次git pull：</span><br><span class="line">            $ for((i&#x3D;1;i&lt;&#x3D;10000;i+&#x3D;1)); do sleep X &amp;&amp; git pull; done</span><br><span class="line">        使用git rebase将一个feature分支变基到master分支</span><br><span class="line">            $ git checkout feature</span><br><span class="line">            $ git rebase master</span><br><span class="line"></span><br><span class="line">配置相关:</span><br><span class="line">    查看当前配置：  git config --list</span><br><span class="line">    修改git的name和email：</span><br><span class="line">        git config --global user.name &lt;name&gt;</span><br><span class="line">        git config --global user.email &lt;email&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo+github进行搭建博客</title>
    <url>/2020-01-29-hexo.html</url>
    <content><![CDATA[<p>Hexo+github搭建博客步骤：</p>
<ol>
<li>git账号创建</li>
<li>node环境搭建</li>
<li>安装Hexo</li>
<li>github创建个人仓库</li>
<li>hexo部署到github</li>
<li>个人域名</li>
<li>发布文章<a id="more"></a>

</li>
</ol>
<h4 id="1-git账号创建"><a href="#1-git账号创建" class="headerlink" title="1. git账号创建"></a>1. git账号创建</h4><p>git官网上可以注册创建一个账号。</p>
<h4 id="2-node环境搭建"><a href="#2-node环境搭建" class="headerlink" title="2. node环境搭建"></a>2. node环境搭建</h4><p>安装node和npm，查看node是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install nodejs</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure>
<h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3. 安装Hexo"></a>3. 安装Hexo</h4><ul>
<li><p>安装hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo -v</span><br></pre></td></tr></table></figure></li>
<li><p>初始化一个boke</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line">cd my-blog</span><br></pre></td></tr></table></figure></li>
<li><p>成功后，可看到文件目录<br>node_modules: 依赖包<br>public：存放生成的页面<br>scaffolds：生成文章的一些模板<br>source：用来存放你的文章<br>themes：主题<br>_config.yml: 博客的配置文件</p>
</li>
<li><p>部署后，打开服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
<p>本地的<a href="localhost:4000">localhost:4000</a>就可以访问你生成的博客了。</p>
</li>
</ul>
<h4 id="4-github创建个人仓库"><a href="#4-github创建个人仓库" class="headerlink" title="4. github创建个人仓库"></a>4. github创建个人仓库</h4><p>github官网创建好账号之后，新建一个仓库：用户名.github.io</p>
<h4 id="5-hexo部署到github"><a href="#5-hexo部署到github" class="headerlink" title="5. hexo部署到github"></a>5. hexo部署到github</h4><ul>
<li><p>将hexo和github关联起来，需要修改配置文件_config.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: https:&#x2F;&#x2F;github.com&#x2F;git名&#x2F;git用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时需要安装deploy-git，即部署命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &#x2F;&#x2F; 清除之前的东西</span><br><span class="line">hexo g  &#x2F;&#x2F; 生成静态文章</span><br><span class="line">hexo d  &#x2F;&#x2F; 部署文章</span><br></pre></td></tr></table></figure>
<p>执行完成后，就可以在<a href="https://github.com/git名/git用户名.github.io.git" target="_blank" rel="noopener">https://github.com/git名/git用户名.github.io.git</a>看到博客了。</p>
</li>
</ul>
<h4 id="6-个人域名"><a href="#6-个人域名" class="headerlink" title="6. 个人域名"></a>6. 个人域名</h4><p>需要自己去买个域名，在阿里云，买好域名后：<br>需要进行解析域名，解析时把地址指向你的github的地址。</p>
<p>登录github后，进入刚刚创建的仓库，点击settings，设置Custom domain，输入你的域名地址。<br>并且在my-blog项目下的source中创建一个名为CNAME的文件，把域名加入。<br>最后一步再进行部署，此时访问你的域名就可以看到你的博客了</p>
<h4 id="7-发布文章"><a href="#7-发布文章" class="headerlink" title="7. 发布文章"></a>7. 发布文章</h4><p>创建标签或自定义文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &#39;name&#39;</span><br></pre></td></tr></table></figure>
<p>写文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new pageName</span><br></pre></td></tr></table></figure>
<p>部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
