<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my-blog</title>
  <icon>https://www.gravatar.com/avatar/e3033211f497dbeb0d82dedb049dddbd</icon>
  <subtitle>关于学习 关于成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gpp-note.top/"/>
  <updated>2020-02-06T14:12:02.658Z</updated>
  <id>http://gpp-note.top/</id>
  
  <author>
    <name>Guopp</name>
    <email>2474986040@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NodeJs之timer</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-timer.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-timer.html</id>
    <published>2020-02-06T14:11:32.000Z</published>
    <updated>2020-02-06T14:12:02.658Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>定时器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;timer&quot;&gt;&lt;a href=&quot;#timer&quot; class=&quot;headerlink&quot; title=&quot;timer&quot;&gt;&lt;/a&gt;timer&lt;/h2&gt;&lt;p&gt;定时器。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之string_decoder</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-string-decoder.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-string-decoder.html</id>
    <published>2020-02-06T14:04:27.000Z</published>
    <updated>2020-02-06T14:11:06.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string-decoder"><a href="#string-decoder" class="headerlink" title="string_decoder"></a>string_decoder</h2><p>字符串解码器。</p><p>提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);</span><br><span class="line">const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);</span><br><span class="line"></span><br><span class="line">const cent &#x3D; Buffer.from([0xC2, 0xA2]);</span><br><span class="line">console.log(decoder.write(cent));</span><br><span class="line"></span><br><span class="line">const euro &#x3D; Buffer.from([0xE2, 0x82, 0xAC]);</span><br><span class="line">console.log(decoder.write(euro));</span><br></pre></td></tr></table></figure><p>将Buffer实例写入StringDecoder实例时，将使用内部缓冲区来确保已解码的字符串不包含任何不完整的多字节字符。它们保存在缓冲区中，直到下一次调用stringDecoder.write()或调用stringDecoder.end()为止。</p><h4 id="StringDecoder类"><a href="#StringDecoder类" class="headerlink" title="StringDecoder类"></a>StringDecoder类</h4><h5 id="new-StringDecoder-encoding"><a href="#new-StringDecoder-encoding" class="headerlink" title="new StringDecoder([encoding])"></a>new StringDecoder([encoding])</h5><p>创建一个新的StringDecoder实例。</p><h5 id="stringDecoder-end-buffer"><a href="#stringDecoder-end-buffer" class="headerlink" title="stringDecoder.end([buffer])"></a>stringDecoder.end([buffer])</h5><p>以字符串形式返回存储在内部缓冲区中的任何剩余输入。 表示不完整的 UTF-8 和 UTF-16 字符的字节将替换为适合字符编码的替换字符。</p><p>如果提供了 buffer 参数，则在返回剩余的输入之前再最后一次调用 stringDecoder.write()</p><h5 id="stringDecoder-write-buffer"><a href="#stringDecoder-write-buffer" class="headerlink" title="stringDecoder.write(buffer)"></a>stringDecoder.write(buffer)</h5><p>返回一个已解码的字符串，确保在返回的字符串不包含 Buffer、 TypedArray 或 DataView 末尾的任何不完整的多字节字符，并将其存储在内部缓冲区中，以便下次调用 stringDecoder.write() 或 stringDecoder.end()。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string-decoder&quot;&gt;&lt;a href=&quot;#string-decoder&quot; class=&quot;headerlink&quot; title=&quot;string_decoder&quot;&gt;&lt;/a&gt;string_decoder&lt;/h2&gt;&lt;p&gt;字符串解码器。&lt;/p&gt;
&lt;p&gt;提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const &amp;#123; StringDecoder &amp;#125; &amp;#x3D; require(&amp;#39;string_decoder&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之stream</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-stream.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-stream.html</id>
    <published>2020-02-06T14:04:10.000Z</published>
    <updated>2020-02-06T14:05:32.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;stream&quot;&gt;&lt;a href=&quot;#stream&quot; class=&quot;headerlink&quot; title=&quot;stream&quot;&gt;&lt;/a&gt;stream&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之repl</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-repl.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-repl.html</id>
    <published>2020-02-06T13:41:23.000Z</published>
    <updated>2020-02-06T14:03:43.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="repl"><a href="#repl" class="headerlink" title="repl"></a>repl</h2><p>交互式解释器</p><p>repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="设计与特性"><a href="#设计与特性" class="headerlink" title="设计与特性"></a>设计与特性</h4><p>repl模块导出了repl.REPLServer类。当repl.REPLServer实例运行时，它接收用户输入的每一行，根据用户定义的解释函数解释这些输入，然后输出结果。<br>repl.REPLServer实例支持输入的自动补全、精简Emacs风格的行编辑、多行输入、ANSI风格的输出、当前REPL会话状态的保存于恢复、错误校正、以及可定制的解释函数。</p><h4 id="命令与特殊键"><a href="#命令与特殊键" class="headerlink" title="命令与特殊键"></a>命令与特殊键</h4><ul><li>.break - 在输入一个多行表达式的过程中，输入 .break 命令（或按下 <ctrl>-C 组合键）将终止表达式的继续输入。</li><li>.clear - 重置 REPL 的 context 为一个空对象，并清除当前正输入的所有多行表达式。</li><li>.exit - 关闭输入输出流，退出 REPL。</li><li>.help - 显示特定命令的帮助列表。</li><li>.save - 保存当前 REPL 会话到一个文件： &gt; .save ./file/to/save.js</li><li>.load - 读取一个文件到当前 REPL 会话。 &gt; .load ./file/to/load.js</li><li>.editor 进入编辑模式（<ctrl>-D 完成， <ctrl>-C 取消）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; .editor</span><br><span class="line">&#x2F;&#x2F; 进入编辑模式（^D 完成，^C 取消）</span><br><span class="line">function welcome(name) &#123;</span><br><span class="line">  return &#96;你好 $&#123;name&#125;！&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">welcome(&#39;Node.js 用户&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ^D</span><br><span class="line">&#39;你好 Node.js 用户！&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="默认的解释器"><a href="#默认的解释器" class="headerlink" title="默认的解释器"></a>默认的解释器</h4><p>默认情况下，所有repl.REPLServer实例使用了一个解释函数，它可以解释JavaScript表达式、提供对Nodejs内置模块的访问。当repl.REPLServer实例被创建时可以传入一个替换的解释函数，覆盖其默认的功能。</p><h5 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1 + 1</span><br><span class="line">2</span><br><span class="line">&gt; const m &#x3D; 2</span><br><span class="line">undefined</span><br><span class="line">&gt; m + 1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="全局作用域与局部作用域"><a href="#全局作用域与局部作用域" class="headerlink" title="全局作用域与局部作用域"></a>全局作用域与局部作用域</h5><p>默认的解释器提供了获取存在于全局作用域中的任何变量的途径。 可以通过给每个 REPLServer 绑定的 context 对象指定变量，来显式地把变量暴露给 REPL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">repl.start(&#39;&gt; &#39;).context.m &#x3D; msg;</span><br></pre></td></tr></table></figure><p>context 对象的属性表现为 REPL 中的局部变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node repl_test.js</span><br><span class="line">&gt; m</span><br><span class="line">&#39;message&#39;</span><br></pre></td></tr></table></figure><p>默认情况下 context 的属性不是只读的。 要指定只读的全局变量， context 的属性必须使用 Object.defineProperty() 来定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">const r &#x3D; repl.start(&#39;&gt; &#39;);</span><br><span class="line">Object.defineProperty(r.context, &#39;m&#39;, &#123;</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  value: msg</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="访问Nodejs核心模块"><a href="#访问Nodejs核心模块" class="headerlink" title="访问Nodejs核心模块"></a>访问Nodejs核心模块</h5><p>默认的解释器会自动加载被调用的 Node.js 核心模块到 REPL 环境中。 例如，除非被声明为一个全局变量或一个有限范围的变量，否则输入 fs 会被解释为 global.fs = require(‘fs’)。</p><figure class="highlight plain"><figcaption><span>fs.createReadStream('./some/file');```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 全局的未捕获异常</span><br><span class="line">REPL 使用 domain 模块来捕获该 REPL 会话的所有未捕获的异常。</span><br><span class="line"></span><br><span class="line">在 REPL 中对 domain 模块的这种使用具有以下的副作用：</span><br><span class="line"></span><br><span class="line">* 未捕获的异常仅在独立的 REPL 中触发 &#39;uncaughtException&#39; 事件。 在另一个 Node.js 程序的 REPL 中添加此事件的监听器会抛出 ERR_INVALID_REPL_INPUT。</span><br><span class="line"></span><br><span class="line">* 尝试使用 process.setUncaughtExceptionCaptureCallback() 会抛出 ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE 错误。</span><br><span class="line"></span><br><span class="line">作为独立程序：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));</p><p>throw new Error(‘foobar’);<br>// 未捕获的异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当在另一个应用程序中使用时：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));<br>// TypeError [ERR_INVALID_REPL_INPUT]: Listeners for <code>uncaughtException</code><br>// cannot be used in the REPL</p><p>throw new Error(‘foobar’);<br>// 抛出:<br>// Error: foobar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _ 变量的赋值</span><br><span class="line"></span><br><span class="line">默认的解释器会把最近一次解释的表达式的结果赋值给变量 _ （下划线）。 显式地设置 _ 为某个值能禁用该特性。</span><br></pre></td></tr></table></figure><blockquote><p>[ ‘a’, ‘b’, ‘c’ ]<br>[ ‘a’, ‘b’, ‘c’ ]<br>_.length<br>3<br>_ += 1<br>Expression assignment to _ now disabled.<br>4<br>1 + 1<br>2<br>_<br>4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同样， _error 将指向最后一次看到的错误（如果有的话）。 将 _error 显式设置为值将禁用此行为</span><br></pre></td></tr></table></figure><blockquote><p>throw new Error(‘foo’);<br>Error: foo<br>_error.message<br>‘foo’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### await关键词</span><br><span class="line">使用 --experimental-repl-await 命令行选项，将启用对 await 关键字的实验性支持。</span><br></pre></td></tr></table></figure><blockquote><p>await Promise.resolve(123)<br>123<br>await Promise.reject(new Error(‘REPL await’))<br>Error: REPL await<br>    at repl:1:45<br>const timeout = util.promisify(setTimeout);<br>undefined<br>const old = Date.now(); await timeout(1000); console.log(Date.now() - old);<br>1002<br>undefined</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义的解释函数</span><br><span class="line">当创建一个新的 repl.REPLServer 时，可以提供一个自定义的解释函数。 这可以用于实现完全定制化的 REPL 应用。</span><br><span class="line"></span><br><span class="line">以下是 REPL 的一个假设的示例，执行从一种语言到另一种语言的文本转换：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);<br>const { Translator } = require(‘translator’);</p><p>const myTranslator = new Translator(‘en’, ‘fr’);</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, myTranslator.translate(cmd));<br>}</p><p>repl.start({ prompt: ‘&gt; ‘, eval: myEval });</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 可恢复的错误</span><br><span class="line">当用户正在 REPL 中输入时，按下 &lt;enter&gt; 键会把当前行的输入发送到 eval 函数。 为了支持多行输入， eval 函数可以返回一个 repl.Recoverable 实例给提供的回调函数：</span><br></pre></td></tr></table></figure><p>function myEval(cmd, context, filename, callback) {<br>  let result;<br>  try {<br>    result = vm.runInThisContext(cmd);<br>  } catch (e) {<br>    if (isRecoverableError(e)) {<br>      return callback(new repl.Recoverable(e));<br>    }<br>  }<br>  callback(null, result);<br>}</p><p>function isRecoverableError(error) {<br>  if (error.name === ‘SyntaxError’) {<br>    return /^(Unexpected end of input|Unexpected token)/.test(error.message);<br>  }<br>  return false;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义REPL输出</span><br><span class="line">默认情况下，在把输出写入到提供的可写流（默认为 process.stdout）之前，repl.REPLServer 实例会使用 util.inspect() 方法对输出进行格式化。 showProxy 检查选项会默认设置为 true， colors 选项会设置为 true，具体取决于 REPL 的 useColors 选项。</span><br><span class="line"></span><br><span class="line">可以在构造时指定 useColors 布尔值选项，以指示默认的编写器使用 ANSI 样式代码来着色来自 util.inspect() 方法的输出。</span><br><span class="line"></span><br><span class="line">如果 REPL 作为独立程序运行，则还可以使用 inspect.replDefaults 属性从 REPL 内部更改 REPL 的检查默认值util.inspect()，该属性是 util.inspect() 中的 defaultOptions 的镜像。</span><br></pre></td></tr></table></figure><blockquote><p>util.inspect.replDefaults.compact = false;<br>false<br>[1]<br>[<br>  1<br>]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在构造时，通过在 writer 选项传入一个新的函数，可以完全地自定义一个 repl.REPLServer 实例的输出。 例子，把输入的任何文本转换为大写：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>const r = repl.start({ prompt: ‘&gt; ‘, eval: myEval, writer: myWriter });</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, cmd);<br>}</p><p>function myWriter(output) {<br>  return output.toUpperCase();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### REPLServer类</span><br><span class="line">repl.REPLServer 的实例是使用 repl.start() 方法创建的，不能直接地使用 JavaScript 的 new 关键字创建。</span><br><span class="line"></span><br><span class="line">##### exit事件</span><br><span class="line">当接收到 .exit 命令、或按下两次 &lt;ctrl&gt;-C 发出 SIGINT 信号、或按下 &lt;ctrl&gt;-D 发出 &#39;end&#39; 信号而使 REPL 被退出时，触发 &#39;exit&#39; 事件。 监听器的回调函数被调用时不带任何参数。</span><br></pre></td></tr></table></figure><p>replServer.on(‘exit’, () =&gt; {<br>  console.log(‘从 REPL 接收到 “exit” 事件！’);<br>  process.exit();<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### reset事件</span><br><span class="line">当 REPL 的上下文被重置时，触发 &#39;reset&#39; 事件。 每当接收到 .clear 命令时会触发该事件，除非 REPL 正在使用默认的解释器并且 repl.REPLServer 实例被创建时 useGlobal 选项被设为 true。 监听器的回调函数被调用时会带上 context 对象作为惟一的参数。</span><br><span class="line"></span><br><span class="line">这主要被用于重新初始化 REPL 上下文，使之达到某些预定义的状态，如下面的例子：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>function initializeContext(context) {<br>  context.m = ‘test’;<br>}</p><p>const r = repl.start({ prompt: ‘&gt; ‘ });<br>initializeContext(r.context);</p><p>r.on(‘reset’, initializeContext);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当代码被执行时，全局的 &#39;m&#39; 变量可以被修改，但随后的 .clear 命令会把它重置回初始值：</span><br></pre></td></tr></table></figure><p>$ ./node example.js</p><blockquote><p>m<br>‘test’<br>m = 1<br>1<br>m<br>1<br>.clear<br>Clearing context…<br>m<br>‘test’</p></blockquote><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;repl&quot;&gt;&lt;a href=&quot;#repl&quot; class=&quot;headerlink&quot; title=&quot;repl&quot;&gt;&lt;/a&gt;repl&lt;/h2&gt;&lt;p&gt;交互式解释器&lt;/p&gt;
&lt;p&gt;repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const repl &amp;#x3D; require(&amp;#39;repl&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之readline</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-readline.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-readline.html</id>
    <published>2020-02-06T13:02:01.000Z</published>
    <updated>2020-02-06T13:41:00.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>逐行读取。<br>提供了一个接口，用于一次一行的读取可读流中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;);</span><br><span class="line"></span><br><span class="line">const rl &#x3D; readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.question(&#39;你如何看待 Node.js 中文网？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO：将答案记录在数据库中。</span><br><span class="line">  console.log(&#96;感谢您的宝贵意见：$&#123;answer&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  rl.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦调用此代码，Nodejs应用程序将不会终止，直到readline.Interface关闭，<br>因为接口在Input流上等待接收数据。</p><h4 id="Interface类"><a href="#Interface类" class="headerlink" title="Interface类"></a>Interface类</h4><p>readline.Interface类的实例是使用readline.createInterface()方法构造的。<br>每个实例都关联一个input可读流和一个output可写流。<br>output流用于为到达的用户输入打印提示，并从input流读取。</p><h4 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h4><p>当发生以下任一情况时会触发close事件：</p><ul><li>调用rl.close()方法，且readline.Interface实例放弃对input流和output流的控制；</li><li>input流接收到其end事件；</li><li>input流接收到<ctrl>-D以发信号传输结束；</li><li>input流接收到<ctrl>-C以发信号SIGINT，并且readline.Interface实例上没有注册SIGINT事件监听器。<br>调用监听器函数不传入任何参数。</li></ul><p>一旦触发close事件，则readline.Interface实例就完成了。</p><h5 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h5><p>每当input流接收到行尾输入（\n, \r, \r\n）时会触发line事件。</p><h5 id="pause事件"><a href="#pause事件" class="headerlink" title="pause事件"></a>pause事件</h5><p>当发生以下任一情况时会触发pause事件：</p><ul><li>input流被暂停</li><li>input流未暂停，且接收到SIGCONT事件</li></ul><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;pause&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 暂停&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="resume事件"><a href="#resume事件" class="headerlink" title="resume事件"></a>resume事件</h5><p>每当input流恢复时，就会触发resume事件。<br>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;resume&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 恢复&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGCONT事件"><a href="#SIGCONT事件" class="headerlink" title="SIGCONT事件"></a>SIGCONT事件</h5><p>当先前使用<ctrl>-Z移入后台的Nodejs进程使用fg返回到前台时，就会触发SIGCONT事件。<br>如果input流在SIGTSTP请求之前被暂停，则不会触发此事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGCONT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;prompt&#96; 将自动恢复流。</span><br><span class="line">  rl.prompt();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGCONT事件。</p><h5 id="SIGINT事件"><a href="#SIGINT事件" class="headerlink" title="SIGINT事件"></a>SIGINT事件</h5><p>每当input流接收到<ctrl>-C输入时，就会触发SIGINT事件。<br>如果当input流接收到SIGINT时没有注册SIGINT事件监听器，则会触发pause事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  rl.question(&#39;确定要退出吗？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">    if (answer.match(&#x2F;^y(es)?$&#x2F;i)) rl.pause();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGTSTP事件"><a href="#SIGTSTP事件" class="headerlink" title="SIGTSTP事件"></a>SIGTSTP事件</h5><p>每当input流接收到<ctrl>-Z输入时，就会触发SIGTSTP事件。<br>如果当input流接收SIGTSTP时没有注册SIGTSTP事件监听器，则Nodejs进程将被发送到后台。</p><p>当使用fg(1p)恢复程序时，将触发pause和SIGCONT事件，这可用于恢复input流。</p><p>如果在将进程发送到后台之前暂停input，则不会触发pause和SIGCONT事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGTSTP&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这将覆盖 SIGTSTP 并阻止程序进入后台。</span><br><span class="line">  console.log(&#39;捕获 SIGTSTP&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGTSTP事件。</p><h5 id="rl-close"><a href="#rl-close" class="headerlink" title="rl.close()"></a>rl.close()</h5><p>会关闭readline.Interface实例，并放弃对input和output流的控制。<br>当调用时，将触发close事件。</p><p>调用rl.close()不会立即停止readline.Interface实例触发的其他事件。</p><h5 id="rl-pause"><a href="#rl-pause" class="headerlink" title="rl.pause()"></a>rl.pause()</h5><p>会暂停input流，允许稍后在必要时恢复它。<br>调用rl.pause()不会立刻暂停readline.Interfac实例触发的其他事件。</p><h5 id="rl-prompt-preserveCursor"><a href="#rl-prompt-preserveCursor" class="headerlink" title="rl.prompt([preserveCursor])"></a>rl.prompt([preserveCursor])</h5><p>将readline.Interface实例配置的提示写入putput中的新一行，以便为用户提供一个可供输入位置。</p><p>当调用时，如果input流已暂停，则rl.prompt()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入提示。</p><h5 id="rl-question-query-callback"><a href="#rl-question-query-callback" class="headerlink" title="rl.question(query, callback)"></a>rl.question(query, callback)</h5><p>通过将query写入output来显示它，并等待用户在input上提供输入，然后调用callback函数将提供的输入作为第一个参数传入。</p><p>当调用时，如果input流已暂停，则rl.question()将恢复input流。</p><p>如果readline.Interface创建时output将被设置为null或undefined，则不会写入query。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.question(&#39;你最喜欢的食物是什么？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;你最喜欢的食物是 $&#123;answer&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="rl-resume"><a href="#rl-resume" class="headerlink" title="rl.resume()"></a>rl.resume()</h5><p>如果input流已暂停，则rl.resume方法将恢复它。</p><h5 id="rl-setPrompt-prompt"><a href="#rl-setPrompt-prompt" class="headerlink" title="rl.setPrompt(prompt)"></a>rl.setPrompt(prompt)</h5><p>设置每当调用rl.prompt()时将写入output的提示。</p><h5 id="rl-write-data-key"><a href="#rl-write-data-key" class="headerlink" title="rl.write(data[, key])"></a>rl.write(data[, key])</h5><p>将data或key标识的按键序列写入output。<br>仅当output是TTY文本终端时才支持key参数。<br>如果指定了key，则忽略data。<br>当调用时，如果input流已暂停，则rl.write()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入data和key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.write(&#39;删除这个！&#39;);</span><br><span class="line">&#x2F;&#x2F; 模拟 Ctrl+u 删除先前写入的行。</span><br><span class="line">rl.write(null, &#123; ctrl: true, name: &#39;u&#39; &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;readline&quot;&gt;&lt;a href=&quot;#readline&quot; class=&quot;headerlink&quot; title=&quot;readline&quot;&gt;&lt;/a&gt;readline&lt;/h2&gt;&lt;p&gt;逐行读取。&lt;br&gt;提供了一个接口，用于一次一行的读取可读流中的数据。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const readline &amp;#x3D; require(&amp;#39;readline&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之querystring</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-querystring.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-querystring.html</id>
    <published>2020-02-06T12:53:13.000Z</published>
    <updated>2020-02-06T13:01:26.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><p>查询字符串。<br>querystring模块提供用于解析和格式化URL查询字符串的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const querystring &#x3D; require(&#39;querystring&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="querystring-decode"><a href="#querystring-decode" class="headerlink" title="querystring.decode()"></a>querystring.decode()</h4><p>是querystring.parse()的别名。</p><h4 id="querystring-encode"><a href="#querystring-encode" class="headerlink" title="querystring.encode()"></a>querystring.encode()</h4><p>是querystring.stringify()的别名。</p><h4 id="querystring-escape-str"><a href="#querystring-escape-str" class="headerlink" title="querystring.escape(str)"></a>querystring.escape(str)</h4><p>以对URL查询字符串的特定要求进行了优化的方式对给定的str执行URL百分比编码。</p><h4 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[,sep[,eq[, options]]])"></a>querystring.parse(str[,sep[,eq[, options]]])</h4><p>将URL查询字符串str解析为键值对的集合。</p><h4 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[,sep[,eq[, options]]])"></a>querystring.stringify(obj[,sep[,eq[, options]]])</h4><p>通过迭代对象的自身属性从给定的obj生成URL查询字符串。</p><h4 id="querystring-unescape-str"><a href="#querystring-unescape-str" class="headerlink" title="querystring.unescape(str)"></a>querystring.unescape(str)</h4><p>在给定的str上执行URL百分比编码字符的解码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;querystring&quot;&gt;&lt;a href=&quot;#querystring&quot; class=&quot;headerlink&quot; title=&quot;querystring&quot;&gt;&lt;/a&gt;querystring&lt;/h2&gt;&lt;p&gt;查询字符串。&lt;br&gt;querystring模块提供用于解析和格式化URL查询字符串的实用工具。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const querystring &amp;#x3D; require(&amp;#39;querystring&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之process</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-process.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-process.html</id>
    <published>2020-02-06T11:42:00.000Z</published>
    <updated>2020-02-06T12:52:49.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>进程。<br>process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。<br>作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const process &#x3D; require(&#39;process&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h4><p>process对象是EventEmitter的实例。</p><h5 id="beforeExit事件"><a href="#beforeExit事件" class="headerlink" title="beforeExit事件"></a>beforeExit事件</h5><p>当Nodejs清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。<br>通常，Nodejs进程将在没有调度工作时退出，但在beforeExit事件上注册的监听器可以进行异步调用，从而导致Nodejs进程继续。</p><p>调用监听器回调函数时会将process.exitCode的值作为唯一参数传入。</p><p>对于导致显示终止的条件，不会触发beforeExit事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;beforeExit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 beforeExit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 exit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;此消息最新显示&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印:</span><br><span class="line">&#x2F;&#x2F; 此消息最新显示</span><br><span class="line">&#x2F;&#x2F; 进程 beforeExit 事件的代码: 0</span><br><span class="line">&#x2F;&#x2F; 进程 exit 事件的代码: 0</span><br></pre></td></tr></table></figure><h5 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h5><p>如果使用IPC通道衍生Nodejs进程，则在IPC通道关闭时将触发disconnect事件。</p><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><p>当Nodejs进程因以下原因之一即将退出时，则会触发exit事件：</p><ul><li>显示调用process.exit()方法</li><li>Nodejs事件循环不再需要执行任何其他工作<br>此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，nodejs进程将终止。</li></ul><p>用process.exitCode属性指定的退出码或传给process.exit()方法的exitCode参数调用监听器回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;退出码: $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>监听器函数必须只执行同步操作。<br>在调用exit事件监听器之后，Nodejs进程将立即退出，从而导致在事件循环中仍排队的任何其他工作被放弃。</p><h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><p>如果使用IPC通道衍生Nodejs进程，则只要子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件。</p><p>消息会进行序列化和解析。生成的消息可能与最初发送的消息不同。</p><h5 id="multipleResolves事件"><a href="#multipleResolves事件" class="headerlink" title="multipleResolves事件"></a>multipleResolves事件</h5><p>只要Promise有以下情况，将会触发multipleResolves事件：</p><ul><li>解决不止一次</li><li>拒绝不止一次</li><li>解决后拒绝</li><li>拒绝后解决</li></ul><h5 id="rejectionHandled事件"><a href="#rejectionHandled事件" class="headerlink" title="rejectionHandled事件"></a>rejectionHandled事件</h5><p>每当Promise被拒绝且错误处理函数附加到它晚于一个Nodejs事件循环时，就会触发rejectHandled事件。</p><p>Promise对象之前已经在unhandledRejection事件中触发，但在处理过程中获得了拒绝处理函数。</p><p>Promise链中没有顶层的概念，总是可以处理拒绝。本质上自身是异步的，可以在未来的某个时间点处理Promise拒绝，可能比触发unhandledRejection事件所需的事件循环更晚。</p><p>在同步代码中，当未处理的异常列表增长时，会触发uncaughtexption事件。<br>在异步代码中，当未处理的异常列表增长时，会触发unhandledRejection事件，并且当未处理的拒绝列表缩小时会触发rejectionHandled事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const unhandledRejections &#x3D; new Map();</span><br><span class="line">process.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.set(promise, reason);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&#39;rejectionHandled&#39;, (promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.delete(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="uncaughtException事件"><a href="#uncaughtException事件" class="headerlink" title="uncaughtException事件"></a>uncaughtException事件</h5><p>当未捕获的JavaScript异常一直冒泡回到事件循环时，会触发uncaughtExpection事件。</p><h5 id="unhandledRejection事件"><a href="#unhandledRejection事件" class="headerlink" title="unhandledRejection事件"></a>unhandledRejection事件</h5><p>如果在事件循环的一次轮询中，一个Promise被拒绝，并且此Promise没有绑定错误处理器，unhandledRejection事件会被触发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;process&quot;&gt;&lt;a href=&quot;#process&quot; class=&quot;headerlink&quot; title=&quot;process&quot;&gt;&lt;/a&gt;process&lt;/h2&gt;&lt;p&gt;进程。&lt;br&gt;process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。&lt;br&gt;作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const process &amp;#x3D; require(&amp;#39;process&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之perf_hooks</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-perf-hooks.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-perf-hooks.html</id>
    <published>2020-02-06T11:08:11.000Z</published>
    <updated>2020-02-06T11:41:24.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="perf-hooks"><a href="#perf-hooks" class="headerlink" title="perf_hooks"></a>perf_hooks</h2><p>性能钩子。</p><p>性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; PerformanceObserver, performance &#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((items) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(items.getEntries()[0].duration);</span><br><span class="line">  performance.clearMarks();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;measure&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;A&#39;);</span><br><span class="line">doSomeLongRunningProcess(() &#x3D;&gt; &#123;</span><br><span class="line">  performance.mark(&#39;B&#39;);</span><br><span class="line">  performance.measure(&#39;A to B&#39;, &#39;A&#39;, &#39;B&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Performance类"><a href="#Performance类" class="headerlink" title="Performance类"></a>Performance类</h4><h5 id="performance-clearMarks-name"><a href="#performance-clearMarks-name" class="headerlink" title="performance.clearMarks([name])"></a>performance.clearMarks([name])</h5><h5 id="performance-mark-name"><a href="#performance-mark-name" class="headerlink" title="performance.mark([name])"></a>performance.mark([name])</h5><p>创建一个新的PerformanceMark实体。</p><h5 id="performance-measure-name-startMark-endMark"><a href="#performance-measure-name-startMark-endMark" class="headerlink" title="performance.measure(name, startMark, endMark)"></a>performance.measure(name, startMark, endMark)</h5><h5 id="performance-nodeTiming"><a href="#performance-nodeTiming" class="headerlink" title="performance.nodeTiming"></a>performance.nodeTiming</h5><h5 id="performance-now"><a href="#performance-now" class="headerlink" title="performance.now()"></a>performance.now()</h5><h5 id="performance-timeOrigin"><a href="#performance-timeOrigin" class="headerlink" title="performance.timeOrigin"></a>performance.timeOrigin</h5><h5 id="performance-timerify-fn"><a href="#performance-timerify-fn" class="headerlink" title="performance.timerify(fn)"></a>performance.timerify(fn)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">function someFunction() &#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped &#x3D; performance.timerify(someFunction);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries()[0].duration);</span><br><span class="line">  obs.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;function&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A performance timeline entry will be created</span><br><span class="line">wrapped();</span><br></pre></td></tr></table></figure><h4 id="PerformanceEntry类"><a href="#PerformanceEntry类" class="headerlink" title="PerformanceEntry类"></a>PerformanceEntry类</h4><h5 id="performanceEntry-duration"><a href="#performanceEntry-duration" class="headerlink" title="performanceEntry.duration"></a>performanceEntry.duration</h5><h5 id="performanceEntry-name"><a href="#performanceEntry-name" class="headerlink" title="performanceEntry.name"></a>performanceEntry.name</h5><h5 id="performanceEntry-startTime"><a href="#performanceEntry-startTime" class="headerlink" title="performanceEntry.startTime"></a>performanceEntry.startTime</h5><h5 id="performanceEntry-entryType"><a href="#performanceEntry-entryType" class="headerlink" title="performanceEntry.entryType"></a>performanceEntry.entryType</h5><h5 id="performanceEntry-kind"><a href="#performanceEntry-kind" class="headerlink" title="performanceEntry.kind"></a>performanceEntry.kind</h5><h4 id="PerformanceObserver类"><a href="#PerformanceObserver类" class="headerlink" title="PerformanceObserver类"></a>PerformanceObserver类</h4><h5 id="new-PerformanceObserver-callback"><a href="#new-PerformanceObserver-callback" class="headerlink" title="new PerformanceObserver(callback)"></a>new PerformanceObserver(callback)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries());</span><br><span class="line">  observer.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;test&#39;);</span><br></pre></td></tr></table></figure><h5 id="performanceObserver-disconnect"><a href="#performanceObserver-disconnect" class="headerlink" title="performanceObserver.disconnect()"></a>performanceObserver.disconnect()</h5><h5 id="performanceObserver-observe-options"><a href="#performanceObserver-observe-options" class="headerlink" title="performanceObserver.observe(options)"></a>performanceObserver.observe(options)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called three times synchronously. &#96;list&#96; contains one item.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buffered是false的时候，callback会在每次PerformanceEntry的时候回调。</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called once. &#96;list&#96; contains three items.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br></pre></td></tr></table></figure><h5 id="PerformanceObserverEntryList类"><a href="#PerformanceObserverEntryList类" class="headerlink" title="PerformanceObserverEntryList类"></a>PerformanceObserverEntryList类</h5><h5 id="performanceObserverEntryList-getEntries"><a href="#performanceObserverEntryList-getEntries" class="headerlink" title="performanceObserverEntryList.getEntries()"></a>performanceObserverEntryList.getEntries()</h5><h5 id="performanceObserverEntryList-getEntriesByName-name-type"><a href="#performanceObserverEntryList-getEntriesByName-name-type" class="headerlink" title="performanceObserverEntryList.getEntriesByName(name[,type])"></a>performanceObserverEntryList.getEntriesByName(name[,type])</h5><h4 id="Histogram类"><a href="#Histogram类" class="headerlink" title="Histogram类"></a>Histogram类</h4><h5 id="histogram-disable"><a href="#histogram-disable" class="headerlink" title="histogram.disable()"></a>histogram.disable()</h5><h5 id="histogram-enable"><a href="#histogram-enable" class="headerlink" title="histogram.enable()"></a>histogram.enable()</h5><h5 id="histogram-exceeds"><a href="#histogram-exceeds" class="headerlink" title="histogram.exceeds"></a>histogram.exceeds</h5><h5 id="histogram-max"><a href="#histogram-max" class="headerlink" title="histogram.max"></a>histogram.max</h5><h5 id="histogram-mean"><a href="#histogram-mean" class="headerlink" title="histogram.mean"></a>histogram.mean</h5><h5 id="histogram-min"><a href="#histogram-min" class="headerlink" title="histogram.min"></a>histogram.min</h5><h5 id="histogram-reset"><a href="#histogram-reset" class="headerlink" title="histogram.reset()"></a>histogram.reset()</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;perf-hooks&quot;&gt;&lt;a href=&quot;#perf-hooks&quot; class=&quot;headerlink&quot; title=&quot;perf_hooks&quot;&gt;&lt;/a&gt;perf_hooks&lt;/h2&gt;&lt;p&gt;性能钩子。&lt;/p&gt;
&lt;p&gt;性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之path</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-path.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-path.html</id>
    <published>2020-02-06T08:57:18.000Z</published>
    <updated>2020-02-06T11:07:20.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>路径。<br>path模块提供用于处理文件路径和目录路径的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h4><p>返回path的目录名。</p><h4 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h4><p>返回path的扩展名。</p><h4 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h4><p>从对象返回路径字符串。</p><h4 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h4><p>检测path是否为绝对路径。</p><h4 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h4><p>使用平台特定的分隔符作为定界符将所有给定的path片段连接在一起，然后规范化生成的路径。</p><h4 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h4><p>规范化给定的path，解析’..’和’.’片段。</p><h4 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h4><p>返回一个对象，其属性表示path的重要元素。尾部的目录分隔符将被忽略。</p><h4 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h4><p>根据当前工作目录返回from到to的相对路径。<br>如果from和to各自解析到相同的路径，则返回零长度的字符串。</p><h4 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h4><p>将路径或路径片段的序列解析为绝对路径。</p><h4 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h4><p>提供pingt特定的路径片段分隔符。</p><h4 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h4><p>提供对特定于Windows的path方法的实现的访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;path&quot;&gt;&lt;a href=&quot;#path&quot; class=&quot;headerlink&quot; title=&quot;path&quot;&gt;&lt;/a&gt;path&lt;/h2&gt;&lt;p&gt;路径。&lt;br&gt;path模块提供用于处理文件路径和目录路径的实用工具。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const path &amp;#x3D; require(&amp;#39;path&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之os</title>
    <link href="http://gpp-note.top/tags/2020-02-06-node-os.html"/>
    <id>http://gpp-note.top/tags/2020-02-06-node-os.html</id>
    <published>2020-02-06T08:41:50.000Z</published>
    <updated>2020-02-06T08:56:58.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>操作系统。</p><p>os模块提供了与操作系统相关的实用方法和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const os &#x3D; require(&#39;os&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="os-EOL"><a href="#os-EOL" class="headerlink" title="os.EOL"></a>os.EOL</h4><p>操作系统特定的行末标志。</p><ul><li>在POSIX上是\n</li><li>在Windows上是\r\n</li></ul><h4 id="os-constants"><a href="#os-constants" class="headerlink" title="os.constants"></a>os.constants</h4><p>包含错误码、进程信号等常用的操作系统特定的常量。<br>定义的特定常量在os常量中定义。</p><h4 id="os-cpus"><a href="#os-cpus" class="headerlink" title="os.cpus()"></a>os.cpus()</h4><p>返回一个对象数组，其中包含有关每个逻辑CPU内核的信息。</p><h4 id="os-endianness"><a href="#os-endianness" class="headerlink" title="os.endianness()"></a>os.endianness()</h4><p>返回一个字符串，该字符串标识为其编译Nodejs二进制文件的CPU的字节序。<br>可能的值有，BE用于大端字节序，LE用于小端字节序。</p><h4 id="os-freemem"><a href="#os-freemem" class="headerlink" title="os.freemem()"></a>os.freemem()</h4><p>以整数的形式返回空闲的系统内存量。</p><h4 id="os-getPriority-pid"><a href="#os-getPriority-pid" class="headerlink" title="os.getPriority([pid])"></a>os.getPriority([pid])</h4><p>返回由pid指定的进程的调度优先级。如果未提供pid或为0，则返回当前进程的优先级。</p><h4 id="os-homedir"><a href="#os-homedir" class="headerlink" title="os.homedir()"></a>os.homedir()</h4><p>返回当前用户的主目录的字符串路径。</p><h4 id="os-hostname"><a href="#os-hostname" class="headerlink" title="os.hostname()"></a>os.hostname()</h4><p>以字符串的形式返回操作系统的主机名。</p><h4 id="os-platform"><a href="#os-platform" class="headerlink" title="os.platform()"></a>os.platform()</h4><p>返回标识操作系统平台的字符串。</p><h4 id="os-release"><a href="#os-release" class="headerlink" title="os.release()"></a>os.release()</h4><p>以字符串的形式返回操作系统。</p><h4 id="os-tmpdir"><a href="#os-tmpdir" class="headerlink" title="os.tmpdir()"></a>os.tmpdir()</h4><p>以字符串的形式返回操作系统的默认临时文件目录。</p><h4 id="os-totalmem"><a href="#os-totalmem" class="headerlink" title="os.totalmem()"></a>os.totalmem()</h4><p>以整数的形式返回系统的内存总量。</p><h4 id="os-type"><a href="#os-type" class="headerlink" title="os.type()"></a>os.type()</h4><p>返回与uname(3)返回一样的操作系统名字。</p><h4 id="os-uptime"><a href="#os-uptime" class="headerlink" title="os.uptime()"></a>os.uptime()</h4><p>返回系统的正常运行时间</p><h4 id="os-userInfo-options"><a href="#os-userInfo-options" class="headerlink" title="os.userInfo([options])"></a>os.userInfo([options])</h4><p>返回关于当前有效的用户信息。</p><h4 id="os常量"><a href="#os常量" class="headerlink" title="os常量"></a>os常量</h4><p>并不是所有的常量在每一个操作系统上都是可用的。<br>下面的常量被os.constants所输出。</p><h5 id="信号常量"><a href="#信号常量" class="headerlink" title="信号常量"></a>信号常量</h5><p>os.constants.signals</p><h5 id="错误常量"><a href="#错误常量" class="headerlink" title="错误常量"></a>错误常量</h5><p>os.constants.errno</p><h5 id="POSIX错误常量"><a href="#POSIX错误常量" class="headerlink" title="POSIX错误常量"></a>POSIX错误常量</h5><h5 id="Windows系统特有的错误常量"><a href="#Windows系统特有的错误常量" class="headerlink" title="Windows系统特有的错误常量"></a>Windows系统特有的错误常量</h5><h5 id="dlopen常量"><a href="#dlopen常量" class="headerlink" title="dlopen常量"></a>dlopen常量</h5><h5 id="优先级常量"><a href="#优先级常量" class="headerlink" title="优先级常量"></a>优先级常量</h5><h5 id="libuv常量"><a href="#libuv常量" class="headerlink" title="libuv常量"></a>libuv常量</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;os&quot;&gt;&lt;a href=&quot;#os&quot; class=&quot;headerlink&quot; title=&quot;os&quot;&gt;&lt;/a&gt;os&lt;/h2&gt;&lt;p&gt;操作系统。&lt;/p&gt;
&lt;p&gt;os模块提供了与操作系统相关的实用方法和属性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const os &amp;#x3D; require(&amp;#39;os&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之net</title>
    <link href="http://gpp-note.top/tags/2020-02-05-node-net.html"/>
    <id>http://gpp-note.top/tags/2020-02-05-node-net.html</id>
    <published>2020-02-05T13:59:35.000Z</published>
    <updated>2020-02-06T08:41:26.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络。</p><p>net模块用于创建基于流的TCP或IPC的服务器与客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const net &#x3D; require(&#39;net&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="IPC支持"><a href="#IPC支持" class="headerlink" title="IPC支持"></a>IPC支持</h4><p>net模块在windows上支持命名管道IPC，在其他操作系统上支持Unix域套接字。</p><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><p>此类用于创建TCP或IPC服务器。</p><h5 id="new-net-Server-options-connectionListener"><a href="#new-net-Server-options-connectionListener" class="headerlink" title="new net.Server([options][,connectionListener])"></a>new net.Server([options][,connectionListener])</h5><p>net.Server是一个EventEmitter，实现了以下事件：</p><ul><li><p>close事件<br>  当Server关闭的时候触发，如果有连接存在，直到所有的连接结束才会触发这个事件。</p></li><li><p>connection事件<br>  当一个新的连接建立的时候触发。socket是一个net.Socket实例。</p></li><li><p>error事件<br>  当错误出现的时候触发。</p></li><li><p>listening事件<br>  当调用server.listen()绑定服务器之后触发。</p></li></ul><h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><p>如果在IP socket上监听，则返回操作系统报告的绑定的address、地址family名称、以及服务器port（<br>用于查找在获取操作系统分配的地址时分配的端口）：<code>{port:12346, family:&#39;IPv4&#39;, address:&#39;127.0.0.1&#39;}</code></p><p>对于在管道或Unix域套接字上监听的server，该名称返回为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; net.createServer((socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.end(&#39;再见\n&#39;);</span><br><span class="line">&#125;).on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取任意未使用的端口。</span><br><span class="line">server.listen(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;打开服务器&#39;, server.address());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不要在listening事件触发之前调用server.address()</p><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><p>组织server接受新的连接并保持现有的连接。<br>该函数是异步的，server将在所有连接结束后关闭并触发close事件。<br>可选的callback将在close事件发生时被调用。</p><h5 id="server-getConnections-callback"><a href="#server-getConnections-callback" class="headerlink" title="server.getConnections(callback)"></a>server.getConnections(callback)</h5><p>异步获取服务器的当前并发连接数。当socket被传递给子进程时工作。<br>回调函数的两个参数是err和count。</p><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><p>启动一个服务器来监听连接。</p><h5 id="server-listening"><a href="#server-listening" class="headerlink" title="server.listening"></a>server.listening</h5><p>表明server是否正在监听连接。</p><h5 id="server-maxConnections"><a href="#server-maxConnections" class="headerlink" title="server.maxConnections"></a>server.maxConnections</h5><p>该属性使得server连接数过多时拒绝连接。</p><h5 id="server-ref"><a href="#server-ref" class="headerlink" title="server.ref()"></a>server.ref()</h5><p>与unref()相反，在一个已经调用unref的server中调用ref，如果server是仅存的server，<br>则程序不会退出。对一个已经调用ref的server再次调用ref()将不会再有效果。</p><h5 id="server-unref"><a href="#server-unref" class="headerlink" title="server.unref()"></a>server.unref()</h5><p>如果这个server在事件系统中是唯一有效的，那么对server调用unref()将允许程序退出。<br>如果这个server已经调用过unref那么再次调用unref()将不会再有效果。</p><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><p>net.Socket可以由用户创建并且直接与服务器进行交互。<br>也可以由Nodejs创建，并在收到连接时传给用户。</p><h5 id="new-net-Socket-options"><a href="#new-net-Socket-options" class="headerlink" title="new net.Socket([options])"></a>new net.Socket([options])</h5><p>创建一个socket对象。</p><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><p>一旦socket完全关闭就发出该事件。</p><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><p>当一个socket连接成功建立的时候触发该事件。</p><h5 id="data事件"><a href="#data事件" class="headerlink" title="data事件"></a>data事件</h5><p>当接收到数据的时候触发该事件。<br>data参数是一个Buffer或String<br>当Socket触发data事件的时候，如果没有监听器则数据将会丢失。</p><h5 id="drain事件"><a href="#drain事件" class="headerlink" title="drain事件"></a>drain事件</h5><p>当写入缓冲区变为空时触发。可以用来做上传节流。</p><h5 id="end事件"><a href="#end事件" class="headerlink" title="end事件"></a>end事件</h5><p>当socket的另一端发送一个FIN包的时候触发，从而结束socket的可读流。</p><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><p>当错误发生时触发。close事件也会紧接着该事件被触发。</p><h5 id="lookup事件"><a href="#lookup事件" class="headerlink" title="lookup事件"></a>lookup事件</h5><p>当找到主机之后创建连接之前触发。</p><h5 id="ready事件"><a href="#ready事件" class="headerlink" title="ready事件"></a>ready事件</h5><p>套接字准备好使用时触发。<br>connect后立即触发。</p><h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><p>当socket超时的时候触发。</p><h5 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect()"></a>socket.connect()</h5><h5 id="socket-connecting"><a href="#socket-connecting" class="headerlink" title="socket.connecting()"></a>socket.connecting()</h5><h5 id="socket-destrory-exception"><a href="#socket-destrory-exception" class="headerlink" title="socket.destrory([exception])"></a>socket.destrory([exception])</h5><h5 id="socket-destroyed"><a href="#socket-destroyed" class="headerlink" title="socket.destroyed"></a>socket.destroyed</h5><p>指示连接是否已经被销毁。<br>一旦连接被销毁就不能再使用它传输任何数据。</p><h5 id="socket-end-data-encoding-callback"><a href="#socket-end-data-encoding-callback" class="headerlink" title="socket.end([data[,encoding]][, callback])"></a>socket.end([data[,encoding]][, callback])</h5><p>半关闭socket。</p><h4 id="net-isIP-input"><a href="#net-isIP-input" class="headerlink" title="net.isIP(input)"></a>net.isIP(input)</h4><p>测试输入是否是IP地址。<br>无效的字符串则返回0<br>IPv4地址则返回4<br>IPv6的地址则返回6</p><h4 id="net-isIPv4-input"><a href="#net-isIPv4-input" class="headerlink" title="net.isIPv4(input)"></a>net.isIPv4(input)</h4><p>如果输入是IPv4地址返回true，否则返回false</p><h4 id="net-isIPv6-input"><a href="#net-isIPv6-input" class="headerlink" title="net.isIPv6(input)"></a>net.isIPv6(input)</h4><p>如果输入是IPv6地址返回true，否则返回false</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;net&quot;&gt;&lt;a href=&quot;#net&quot; class=&quot;headerlink&quot; title=&quot;net&quot;&gt;&lt;/a&gt;net&lt;/h2&gt;&lt;p&gt;网络。&lt;/p&gt;
&lt;p&gt;net模块用于创建基于流的TCP或IPC的服务器与客户端。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const net &amp;#x3D; require(&amp;#39;net&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之module</title>
    <link href="http://gpp-note.top/tags/2020-02-05-node-module.html"/>
    <id>http://gpp-note.top/tags/2020-02-05-node-module.html</id>
    <published>2020-02-05T12:41:18.000Z</published>
    <updated>2020-02-05T13:58:12.274Z</updated>
    
    <content type="html"><![CDATA[<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>模块。</p><p>在Nodejs模块系统中，每个文件都被视为一个独立的模块。</p><a id="more"></a><h4 id="访问主模块"><a href="#访问主模块" class="headerlink" title="访问主模块"></a>访问主模块</h4><p>当Nodejs直接运行一个文件时mrequire.main会被视为module。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>模块在第一次加载后会被缓存。<br>每次调用相同的模块都解析到同一个文件，则返回相同的对象。</p><h5 id="模块缓存的注意事项"><a href="#模块缓存的注意事项" class="headerlink" title="模块缓存的注意事项"></a>模块缓存的注意事项</h5><p>模块是基于其解析的文件名进行缓存的。由于调用模块的位置不同，模块可能被解析成不同的<br>文件名，这样就不能保证总能返回完全相同的对象。</p><p>此外，在不区分大小写的文件系统或操作系统中，被解析成不同的文件名可以指向同一文件，<br>但缓存仍然会将它们视为不同的模块，并多次重新加载。</p><h4 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h4><p>核心模块定义在Nodejs原代码的lib/目录下。<br>require()总是会优先加载核心模块。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>当循环调用require()时，一个模块可能在未完成执行时被返回。</p><h4 id="目录作为模块"><a href="#目录作为模块" class="headerlink" title="目录作为模块"></a>目录作为模块</h4><p>提供一个单一的入口来指向它。</p><h4 id="从node-modules目录加载"><a href="#从node-modules目录加载" class="headerlink" title="从node_modules目录加载"></a>从node_modules目录加载</h4><h4 id="从全局目录加载"><a href="#从全局目录加载" class="headerlink" title="从全局目录加载"></a>从全局目录加载</h4><h4 id="模块封装器"><a href="#模块封装器" class="headerlink" title="模块封装器"></a>模块封装器</h4><p>在指向模块代码之前，Nodejs会使用一个如下的函数封装器将其封装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function(exports, require, module, __filename, __dirname) &#123;</span><br><span class="line">&#x2F;&#x2F; 模块的代码实际上在这里</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过这样做，Nodejs实现了以下几点：</p><ul><li>它保持了顶层的变量（用var、const或let定义）作用在模块范围内，而不是全局对象；</li><li>它有助于提高一些看似全局但实际是模块特定的变量；</li></ul><h4 id="模块作用域"><a href="#模块作用域" class="headerlink" title="模块作用域"></a>模块作用域</h4><h5 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h5><p>当前模块的目录名。</p><h5 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h5><p>当前模块的文件名。</p><h5 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h5><h5 id="module-1"><a href="#module-1" class="headerlink" title="module"></a>module</h5><p>对当前模块的引用。</p><h5 id="require-id"><a href="#require-id" class="headerlink" title="require(id)"></a>require(id)</h5><h5 id="require-cache"><a href="#require-cache" class="headerlink" title="require.cache"></a>require.cache</h5><p>被引入的模块江北诶缓存在这个对象中，从此对象中删除键值对将会导致下一次require重新加载<br>被删除的模块。这不适用原生插件，因为它们的重载将会导致错误。</p><h4 id="module对象"><a href="#module对象" class="headerlink" title="module对象"></a>module对象</h4><p>module的自由变量是对表示当前模块的对象的引用。</p><h5 id="module-children"><a href="#module-children" class="headerlink" title="module.children"></a>module.children</h5><p>被该模块引用的模块对象。</p><h5 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h5><p>module.exports对象由Module系统创建。</p><h5 id="exports快捷方式"><a href="#exports快捷方式" class="headerlink" title="exports快捷方式"></a>exports快捷方式</h5><p>exports变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给module。exports。</p><h5 id="module-filename"><a href="#module-filename" class="headerlink" title="module.filename"></a>module.filename</h5><p>模块的完全解析后的文件名。</p><h5 id="module-id"><a href="#module-id" class="headerlink" title="module.id"></a>module.id</h5><p>模块的标识符。通常是完全解析后的文件名。</p><h5 id="module-loaded"><a href="#module-loaded" class="headerlink" title="module.loaded"></a>module.loaded</h5><p>模块是否已经加载完成，或正在加载中。</p><h5 id="module-parent"><a href="#module-parent" class="headerlink" title="module.parent"></a>module.parent</h5><p>最先引用该模块的模块。</p><h5 id="module-paths"><a href="#module-paths" class="headerlink" title="module.paths"></a>module.paths</h5><p>模块的搜索路径。</p><h5 id="module-require-id"><a href="#module-require-id" class="headerlink" title="module.require(id)"></a>module.require(id)</h5><p>提供一种加载模块的方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;module&quot;&gt;&lt;a href=&quot;#module&quot; class=&quot;headerlink&quot; title=&quot;module&quot;&gt;&lt;/a&gt;module&lt;/h2&gt;&lt;p&gt;模块。&lt;/p&gt;
&lt;p&gt;在Nodejs模块系统中，每个文件都被视为一个独立的模块。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之inspector</title>
    <link href="http://gpp-note.top/tags/2020-02-05-node-inspector.html"/>
    <id>http://gpp-note.top/tags/2020-02-05-node-inspector.html</id>
    <published>2020-02-05T12:25:11.000Z</published>
    <updated>2020-02-05T12:41:02.149Z</updated>
    
    <content type="html"><![CDATA[<h2 id="inspector"><a href="#inspector" class="headerlink" title="inspector"></a>inspector</h2><p>检查器。</p><p>inspector模块提供了一个用户与V8 inspector交互的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const inspector &#x3D; require(&#39;inspector&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="inspector-close"><a href="#inspector-close" class="headerlink" title="inspector.close()"></a>inspector.close()</h4><h4 id="inspector-close-1"><a href="#inspector-close-1" class="headerlink" title="inspector.close"></a>inspector.close</h4><h4 id="inspector-open-port-host-wait"><a href="#inspector-open-port-host-wait" class="headerlink" title="inspector.open([port[, host[, wait]]])"></a>inspector.open([port[, host[, wait]]])</h4><h4 id="inspector-url"><a href="#inspector-url" class="headerlink" title="inspector.url()"></a>inspector.url()</h4><h4 id="inspector-waitForDebugger"><a href="#inspector-waitForDebugger" class="headerlink" title="inspector.waitForDebugger()"></a>inspector.waitForDebugger()</h4><h4 id="inspector-Session类"><a href="#inspector-Session类" class="headerlink" title="inspector.Session类"></a>inspector.Session类</h4><h5 id="new-inspector-Session"><a href="#new-inspector-Session" class="headerlink" title="new inspector.Session()"></a>new inspector.Session()</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;inspector&quot;&gt;&lt;a href=&quot;#inspector&quot; class=&quot;headerlink&quot; title=&quot;inspector&quot;&gt;&lt;/a&gt;inspector&lt;/h2&gt;&lt;p&gt;检查器。&lt;/p&gt;
&lt;p&gt;inspector模块提供了一个用户与V8 inspector交互的API。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const inspector &amp;#x3D; require(&amp;#39;inspector&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之HTTPS</title>
    <link href="http://gpp-note.top/tags/2020-02-05-node-HTTPS.html"/>
    <id>http://gpp-note.top/tags/2020-02-05-node-HTTPS.html</id>
    <published>2020-02-05T11:40:37.000Z</published>
    <updated>2020-02-05T12:24:46.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="https-HTTPS"><a href="#https-HTTPS" class="headerlink" title="https(HTTPS)"></a>https(HTTPS)</h2><p>HTTPS是基于TLS/SSL的HTTP协议。在NodeJS中，作为一个单独的模块实现。</p><a id="more"></a><h4 id="https-Agent类"><a href="#https-Agent类" class="headerlink" title="https.Agent类"></a>https.Agent类</h4><p>HTTPS的Agent对象，类似于http.Agent.</p><h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><h4 id="https-Server类"><a href="#https-Server类" class="headerlink" title="https.Server类"></a>https.Server类</h4><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h5 id="server-headersTimeout"><a href="#server-headersTimeout" class="headerlink" title="server.headersTimeout"></a>server.headersTimeout</h5><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><h5 id="server-maxHeadersCount"><a href="#server-maxHeadersCount" class="headerlink" title="server.maxHeadersCount"></a>server.maxHeadersCount</h5><h5 id="server-setTimeout-msecs-callback"><a href="#server-setTimeout-msecs-callback" class="headerlink" title="server.setTimeout([msecs][,callback])"></a>server.setTimeout([msecs][,callback])</h5><h5 id="server-timeout"><a href="#server-timeout" class="headerlink" title="server.timeout"></a>server.timeout</h5><h5 id="server-keepAliveTimeout"><a href="#server-keepAliveTimeout" class="headerlink" title="server.keepAliveTimeout"></a>server.keepAliveTimeout</h5><h5 id="heeps-createServer-options-requestListener"><a href="#heeps-createServer-options-requestListener" class="headerlink" title="heeps.createServer([options][,requestListener])"></a>heeps.createServer([options][,requestListener])</h5><h5 id="https-get-options-callback"><a href="#https-get-options-callback" class="headerlink" title="https.get(options[,callback])"></a>https.get(options[,callback])</h5><h5 id="https-get-url-options-callback"><a href="#https-get-url-options-callback" class="headerlink" title="https.get(url[,options][,callback])"></a>https.get(url[,options][,callback])</h5><h5 id="https-request-options-callback"><a href="#https-request-options-callback" class="headerlink" title="https.request(options[,callback])"></a>https.request(options[,callback])</h5><h5 id="https-request-url-options-callback"><a href="#https-request-url-options-callback" class="headerlink" title="https.request(url[,options][,callback])"></a>https.request(url[,options][,callback])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const https &#x3D; require(&#39;https&#39;);</span><br><span class="line"></span><br><span class="line">const options &#x3D; &#123;</span><br><span class="line">  hostname: &#39;encrypted.google.com&#39;,</span><br><span class="line">  port: 443,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  method: &#39;GET&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const req &#x3D; https.request(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;状态码:&#39;, res.statusCode);</span><br><span class="line">  console.log(&#39;请求头:&#39;, res.headers);</span><br><span class="line"></span><br><span class="line">  res.on(&#39;data&#39;, (d) &#x3D;&gt; &#123;</span><br><span class="line">    process.stdout.write(d);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">req.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(e);</span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;https-HTTPS&quot;&gt;&lt;a href=&quot;#https-HTTPS&quot; class=&quot;headerlink&quot; title=&quot;https(HTTPS)&quot;&gt;&lt;/a&gt;https(HTTPS)&lt;/h2&gt;&lt;p&gt;HTTPS是基于TLS/SSL的HTTP协议。在NodeJS中，作为一个单独的模块实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJS之HTTP/2</title>
    <link href="http://gpp-note.top/tags/2020-02-05-node-Http-2.html"/>
    <id>http://gpp-note.top/tags/2020-02-05-node-Http-2.html</id>
    <published>2020-02-05T11:38:10.000Z</published>
    <updated>2020-02-05T12:17:36.965Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http2-HTTP-2"><a href="#http2-HTTP-2" class="headerlink" title="http2 (HTTP/2)"></a>http2 (HTTP/2)</h2><p>http2模块提供了HTTP/2协议的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="核心API"><a href="#核心API" class="headerlink" title="核心API"></a>核心API</h4><p>核心API提供了专门针对支持HTTP/2协议的特性而设计的底层接口。</p><p>http2核心API在客户端和服务器之间比http API更加对称。</p><h4 id="Http2Session类"><a href="#Http2Session类" class="headerlink" title="Http2Session类"></a>Http2Session类</h4><p>Http2Session类的实例代表了HTTP/2客户端与服务器之间的一个活跃的通信会话。</p><p>每个Http2Session实例会有略有不同的行为，这取决于它是作为服务器还是客户端运行。<br>Http2Session.type属性可用于判断Http2Session的运行模式。</p><p>用户代码不会直接的创建Http2Session实例。<br>当接收到新的http/2连接时，服务端的Http2Session实例由Http2Server实例创建。</p><h5 id="Http2Session与Socket"><a href="#Http2Session与Socket" class="headerlink" title="Http2Session与Socket"></a>Http2Session与Socket</h5><p>每个Http2Session实例在创建时都会与一个net.Socket或tls.TLSSocket关联。<br>当Socket或Http2Session被销毁时，两者都会被销毁。</p><p>一旦将Socket绑定到Http2Session，则用户代码应仅依赖于Http2Session的API。</p><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="stream事件"><a href="#stream事件" class="headerlink" title="stream事件"></a>stream事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line">session.on(&#39;stream&#39;, (stream, headers, flags) &#x3D;&gt; &#123;</span><br><span class="line">  const method &#x3D; headers[&#39;:method&#39;];</span><br><span class="line">  const path &#x3D; headers[&#39;:path&#39;];</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;:status&#39;: 200,</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;plain&#39;</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.write(&#39;hello &#39;);</span><br><span class="line">  stream.end(&#39;world&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const http2 &#x3D; require(&#39;http2&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an unencrypted HTTP&#x2F;2 server</span><br><span class="line">const server &#x3D; http2.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&#39;stream&#39;, (stream, headers) &#x3D;&gt; &#123;</span><br><span class="line">  stream.respond(&#123;</span><br><span class="line">    &#39;content-type&#39;: &#39;text&#x2F;html&#39;,</span><br><span class="line">    &#39;:status&#39;: 200</span><br><span class="line">  &#125;);</span><br><span class="line">  stream.on(&#39;error&#39;, (error) &#x3D;&gt; console.error(error));</span><br><span class="line">  stream.end(&#39;&lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(80);</span><br></pre></td></tr></table></figure><h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><h4 id="ClientHttp2Session类"><a href="#ClientHttp2Session类" class="headerlink" title="ClientHttp2Session类"></a>ClientHttp2Session类</h4><h4 id="Http2Stream类"><a href="#Http2Stream类" class="headerlink" title="Http2Stream类"></a>Http2Stream类</h4><h5 id="Http2Stream的生命周期"><a href="#Http2Stream的生命周期" class="headerlink" title="Http2Stream的生命周期"></a>Http2Stream的生命周期</h5><p>创建、销毁、</p><h4 id="ClientHttp2Stream类"><a href="#ClientHttp2Stream类" class="headerlink" title="ClientHttp2Stream类"></a>ClientHttp2Stream类</h4><h4 id="ServerHttp2Stream类"><a href="#ServerHttp2Stream类" class="headerlink" title="ServerHttp2Stream类"></a>ServerHttp2Stream类</h4><h4 id="Http2Server类"><a href="#Http2Server类" class="headerlink" title="Http2Server类"></a>Http2Server类</h4><h4 id="Http2SecureServer类"><a href="#Http2SecureServer类" class="headerlink" title="Http2SecureServer类"></a>Http2SecureServer类</h4><h4 id="http2-Http2ServerRequest类"><a href="#http2-Http2ServerRequest类" class="headerlink" title="http2.Http2ServerRequest类"></a>http2.Http2ServerRequest类</h4><h4 id="http2-Http2ServerResponse类"><a href="#http2-Http2ServerResponse类" class="headerlink" title="http2.Http2ServerResponse类"></a>http2.Http2ServerResponse类</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;http2-HTTP-2&quot;&gt;&lt;a href=&quot;#http2-HTTP-2&quot; class=&quot;headerlink&quot; title=&quot;http2 (HTTP/2)&quot;&gt;&lt;/a&gt;http2 (HTTP/2)&lt;/h2&gt;&lt;p&gt;http2模块提供了HTTP/2协议的实现。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const http2 &amp;#x3D; require(&amp;#39;http2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之Http</title>
    <link href="http://gpp-note.top/tags/2020-02-02-node-Http.html"/>
    <id>http://gpp-note.top/tags/2020-02-02-node-Http.html</id>
    <published>2020-02-02T10:28:32.000Z</published>
    <updated>2020-02-05T11:38:37.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>要使用HTTP服务器和客户端，必须require(‘http’);</p><a id="more"></a><h4 id="http-Agent类"><a href="#http-Agent类" class="headerlink" title="http.Agent类"></a>http.Agent类</h4><p>Agent负责管理HTTP客户端的链接持久性和重用。</p><p>它为给定的主机和端口维护一个待处理请求队列，为每个请求重用单独的套接字连接，<br>直到队列为空，此时套接字被销毁或放入连接池，以便再次用于请求到同一个主机和端口。</p><p>销毁还是放入连接池取决于keepAlive选项。</p><p>连接池中的连接已启用TCP Keep-Alive，但服务器仍可能关闭空闲连接，<br>这种情况下，它们将从连接池中删除，并且当为该主机和端口发出新的HTTP请求时将建立新的连接。<br>服务器也可以拒绝通过同一连接允许多个请求，在这种情况下，必须为每个请求重新建立连接，<br>并且不能放入连接池。Agent仍将向该服务器发出请求，但每个请求都将通过新连接发生。</p><p>当客户端或服务器关闭连接时，它将从连接池中删除。连接池中任何未使用的套接字都将被销毁，<br>以便当没有未完成的请求时不用保持Nodejs进程运行。</p><p>当不再使用时最好destrory() Agent实例，因为未使用的套接字会消耗操作系统资源。</p><p>当套接字触发close事件或agentRemove事件时，则套接字从代理中删除。<br>当打算长时间保持一个HTTP请求打开而不将其保留在代理中时，可以执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">http.get(options, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 做些事情。</span><br><span class="line">&#125;).on(&#39;socket&#39;, (socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.emit(&#39;agentRemove&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>代理也可以用于单个请求，通过提供{agent:false}作为http.get()或http.request()<br>函数的选项，则将使用一次性的具有默认选项的Agent用于客户端的连接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http.get(&#123;</span><br><span class="line">  hostname: &#39;localhost&#39;,</span><br><span class="line">  port: 80,</span><br><span class="line">  path: &#39;&#x2F;&#39;,</span><br><span class="line">  agent: false  &#x2F;&#x2F; 仅为此一个请求创建一个新代理。</span><br><span class="line">&#125;, (res) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 用响应做些事情。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="new-Agent-options"><a href="#new-Agent-options" class="headerlink" title="new Agent([options])"></a>new Agent([options])</h5><p>options要在代理上设置的可配置选项集。</p><p>要配置其中任何一个，则必须创建自定义的http.Agent实例。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const http &#x3D; require(&#39;http&#39;);</span><br><span class="line">const keepAliveAgent &#x3D; new http.Agent(&#123; keepAlive: true &#125;);</span><br><span class="line">options.agent &#x3D; keepAliveAgent;</span><br><span class="line">http.request(options, onResponseCallback);</span><br></pre></td></tr></table></figure><h5 id="agent-createConnection-options-callback"><a href="#agent-createConnection-options-callback" class="headerlink" title="agent.createConnection(options[, callback])"></a>agent.createConnection(options[, callback])</h5><p>生成用于http请求的套接字或流。</p><h5 id="agent-keepSocketAlive-socket"><a href="#agent-keepSocketAlive-socket" class="headerlink" title="agent.keepSocketAlive(socket)"></a>agent.keepSocketAlive(socket)</h5><p>当socket与请求分离并且可以由Agent保留时调用，默认行为是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.setKeepAlive(true, this.keepAliveMsecs);</span><br><span class="line">socket.unref();</span><br><span class="line">return true;</span><br></pre></td></tr></table></figure><h5 id="agent-reuseSocket-socket-request"><a href="#agent-reuseSocket-socket-request" class="headerlink" title="agent.reuseSocket(socket, request)"></a>agent.reuseSocket(socket, request)</h5><p>由于keep-alive选项而在持久化后将socket附加到request时调用。<br>默认行为是<code>socket.ref()</code></p><h5 id="agent-destroy"><a href="#agent-destroy" class="headerlink" title="agent.destroy()"></a>agent.destroy()</h5><p>销毁代理当前使用的所有套接字。</p><h5 id="agent-maxSockets"><a href="#agent-maxSockets" class="headerlink" title="agent.maxSockets"></a>agent.maxSockets</h5><p>决定代理可以为每个来源打开多少并发套接字。</p><h5 id="agent-requests"><a href="#agent-requests" class="headerlink" title="agent.requests"></a>agent.requests</h5><p>一个对象，包含尚未分配给套接字的请求队列，不要修改。</p><h5 id="agent-sockets"><a href="#agent-sockets" class="headerlink" title="agent.sockets"></a>agent.sockets</h5><p>一个对象，包含当前代理正在使用的套接字数组，不要修改。</p><h4 id="http-ClientRequest类"><a href="#http-ClientRequest类" class="headerlink" title="http.ClientRequest类"></a>http.ClientRequest类</h4><h4 id="http-Server类"><a href="#http-Server类" class="headerlink" title="http.Server类"></a>http.Server类</h4><h4 id="http-ServerResponse类"><a href="#http-ServerResponse类" class="headerlink" title="http.ServerResponse类"></a>http.ServerResponse类</h4><h4 id="http-IncomingMessage类"><a href="#http-IncomingMessage类" class="headerlink" title="http.IncomingMessage类"></a>http.IncomingMessage类</h4><h4 id="http-METHODS"><a href="#http-METHODS" class="headerlink" title="http.METHODS"></a>http.METHODS</h4><h4 id="http-STATUS-CODES"><a href="#http-STATUS-CODES" class="headerlink" title="http.STATUS_CODES"></a>http.STATUS_CODES</h4><h4 id="http-createServer-options-requestListener"><a href="#http-createServer-options-requestListener" class="headerlink" title="http.createServer([options][, requestListener])"></a>http.createServer([options][, requestListener])</h4><h4 id="http-get-options-callback"><a href="#http-get-options-callback" class="headerlink" title="http.get(options[,callback])"></a>http.get(options[,callback])</h4><h4 id="http-get-url-options-callback"><a href="#http-get-url-options-callback" class="headerlink" title="http.get(url[,options][,callback])"></a>http.get(url[,options][,callback])</h4><h4 id="http-globalAgent"><a href="#http-globalAgent" class="headerlink" title="http.globalAgent"></a>http.globalAgent</h4><h4 id="http-maxHeaderSize"><a href="#http-maxHeaderSize" class="headerlink" title="http.maxHeaderSize"></a>http.maxHeaderSize</h4><h4 id="http-request-options-callback"><a href="#http-request-options-callback" class="headerlink" title="http.request(options[,callback])"></a>http.request(options[,callback])</h4><h4 id="http-request-url-options-callback"><a href="#http-request-url-options-callback" class="headerlink" title="http.request(url[,options][,callback])"></a>http.request(url[,options][,callback])</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;p&gt;要使用HTTP服务器和客户端，必须require(‘http’);&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之global</title>
    <link href="http://gpp-note.top/tags/2020-02-02-node-global.html"/>
    <id>http://gpp-note.top/tags/2020-02-02-node-global.html</id>
    <published>2020-02-02T10:17:08.000Z</published>
    <updated>2020-02-02T10:27:27.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="global"><a href="#global" class="headerlink" title="global"></a>global</h2><p>全局变量。</p><p>所有模块都提供这些对象。</p><h4 id="Buffer类"><a href="#Buffer类" class="headerlink" title="Buffer类"></a>Buffer类</h4><p>用于处理二进制数据。</p><h4 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><a id="more"></a><h4 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="clearImmediate-immediateObject"><a href="#clearImmediate-immediateObject" class="headerlink" title="clearImmediate(immediateObject)"></a>clearImmediate(immediateObject)</h4><h4 id="clearInterval-intervalObject"><a href="#clearInterval-intervalObject" class="headerlink" title="clearInterval(intervalObject)"></a>clearInterval(intervalObject)</h4><h4 id="clearTimeout-timeoutObject"><a href="#clearTimeout-timeoutObject" class="headerlink" title="clearTimeout(timeoutObject)"></a>clearTimeout(timeoutObject)</h4><h4 id="console"><a href="#console" class="headerlink" title="console"></a>console</h4><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="global-1"><a href="#global-1" class="headerlink" title="global"></a>global</h4><p>在浏览器中，顶层作用域是全局作用域。<br>在nodejs中，顶层作用于不是全局作用域，nodejs模块中的var something的作用域只在该模块内。</p><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="process"><a href="#process" class="headerlink" title="process"></a>process</h4><p>进程对象。</p><h4 id="require"><a href="#require" class="headerlink" title="require()"></a>require()</h4><p>此变量虽然看起来是全局的，但实际上不是。</p><h4 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h4><h4 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[,…args])"></a>setInterval(callback, delay[,…args])</h4><h4 id="setTimeout-callback-delay-…-args"><a href="#setTimeout-callback-delay-…-args" class="headerlink" title="setTimeout(callback, delay[, ….args])"></a>setTimeout(callback, delay[, ….args])</h4><h4 id="TextDecoder"><a href="#TextDecoder" class="headerlink" title="TextDecoder"></a>TextDecoder</h4><h4 id="TextEncoder"><a href="#TextEncoder" class="headerlink" title="TextEncoder"></a>TextEncoder</h4><h4 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h4>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;global&quot;&gt;&lt;a href=&quot;#global&quot; class=&quot;headerlink&quot; title=&quot;global&quot;&gt;&lt;/a&gt;global&lt;/h2&gt;&lt;p&gt;全局变量。&lt;/p&gt;
&lt;p&gt;所有模块都提供这些对象。&lt;/p&gt;
&lt;h4 id=&quot;Buffer类&quot;&gt;&lt;a href=&quot;#Buffer类&quot; class=&quot;headerlink&quot; title=&quot;Buffer类&quot;&gt;&lt;/a&gt;Buffer类&lt;/h4&gt;&lt;p&gt;用于处理二进制数据。&lt;/p&gt;
&lt;h4 id=&quot;dirname&quot;&gt;&lt;a href=&quot;#dirname&quot; class=&quot;headerlink&quot; title=&quot;__dirname&quot;&gt;&lt;/a&gt;__dirname&lt;/h4&gt;&lt;p&gt;此变量虽然看起来是全局的，但实际上不是。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之fs</title>
    <link href="http://gpp-note.top/tags/2020-02-01-node-fs.html"/>
    <id>http://gpp-note.top/tags/2020-02-01-node-fs.html</id>
    <published>2020-02-01T13:31:29.000Z</published>
    <updated>2020-02-02T10:16:30.613Z</updated>
    
    <content type="html"><![CDATA[<h2 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h2><p>文件系统</p><p>fs模块提供了一个API，用于模仿标准的POSIX函数的方式与文件系统进行交互。</p><p>引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br></pre></td></tr></table></figure><p>所有文件系统操作都具有同步和异步的形式；</p><a id="more"></a><h4 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h4><p>fs操作接受的文件路径可以指定为字符串、Buffer、或使用file：协议的URL对象。</p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>fs.open()方法用于分配新的文件描述符。一旦被分配，则文件描述符可用于从文件读取数据、写入数据或请求关于文件的信息。</p><h4 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h4><p>所有的文件系统API，除了fs.FSWatcher()和那些显示同步之外，都使用libuv的线程池。</p><h4 id="fs-Dir类"><a href="#fs-Dir类" class="headerlink" title="fs.Dir类"></a>fs.Dir类</h4><p>目录流的类。<br>由fs.opendir(), fs.opendirSync()和fsPromises.opendir()创建。</p><h5 id="dir-close"><a href="#dir-close" class="headerlink" title="dir.close()"></a>dir.close()</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>返回一个Promise，将会在关闭资源之后被解决。</p><h5 id="dir-close-callback"><a href="#dir-close-callback" class="headerlink" title="dir.close(callback)"></a>dir.close(callback)</h5><p>异步的关闭目录的底层资源句柄。随后的读取将会导致错误。<br>关闭资源句柄之后就会调用callback</p><h5 id="dir-closeSync"><a href="#dir-closeSync" class="headerlink" title="dir.closeSync()"></a>dir.closeSync()</h5><p>同步的关闭目录的底层资源句柄。</p><h5 id="dir-path"><a href="#dir-path" class="headerlink" title="dir.path"></a>dir.path</h5><p>此目录的只读路径。</p><h4 id="文件写入"><a href="#文件写入" class="headerlink" title="文件写入"></a>文件写入</h4><h5 id="同步文件的写入"><a href="#同步文件的写入" class="headerlink" title="同步文件的写入"></a>同步文件的写入</h5><p>代码逐条执行，会阻塞。</p><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.openSync(path, flags[,mode])</span><br></pre></td></tr></table></figure><p>写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.writeSync(fd, string[, position[,encoding]])</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.closeSync(fd)</span><br></pre></td></tr></table></figure><h5 id="异步文件写入"><a href="#异步文件写入" class="headerlink" title="异步文件写入"></a>异步文件写入</h5><p>代码会一起执行不会阻塞。</p><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.open(path, flags[,mode], callback)</span><br></pre></td></tr></table></figure><p>写入文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.write(fd, string[, position[,encoding]], callback)</span><br></pre></td></tr></table></figure><p>保存并关闭文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.close(fd, callback)</span><br></pre></td></tr></table></figure><h5 id="流式文件写入"><a href="#流式文件写入" class="headerlink" title="流式文件写入"></a>流式文件写入</h5><p>同步异步简单文件的写入不适合大文件的写入，性能较差，容易导致内存溢出，<br>而流式文件写入会一点一点的写进去，不会导致内存溢出的状况。</p><p>创建一个可写流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.createWriteStream(path[,options])</span><br></pre></td></tr></table></figure><p>打开文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const ws &#x3D; fs.createWriteStream(&#39;hello.txt&#39;)</span><br><span class="line"></span><br><span class="line">监听流可选：</span><br><span class="line">ws.once(&#39;open&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流打开了&#39;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ws.once(&#39;close&#39;, function() &#123;</span><br><span class="line">    console.log(&#39;流关闭了&#39;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过ws向文件中输出内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ws.write(&#39;hhhhhhhh&#39;)</span><br><span class="line">ws.write(&#39;gggggggg&#39;)</span><br></pre></td></tr></table></figure><p>关闭流</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws.end()</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h5><p>将可读流中的内容，直接输出到可写流里。</p><h5 id="fs-existsSync-path"><a href="#fs-existsSync-path" class="headerlink" title="fs.existsSync(path)"></a>fs.existsSync(path)</h5><p>检查一个文件是否存在。</p><h5 id="fs-stat-path-options-callback-fs-statSync-path-options"><a href="#fs-stat-path-options-callback-fs-statSync-path-options" class="headerlink" title="fs.stat(path[,options], callback) / fs.statSync(path[,options])"></a>fs.stat(path[,options], callback) / fs.statSync(path[,options])</h5><p>获取文件状态。</p><h5 id="fs-unlink-path-callback-fs-unlinkSync-path"><a href="#fs-unlink-path-callback-fs-unlinkSync-path" class="headerlink" title="fs.unlink(path, callback) / fs.unlinkSync(path)"></a>fs.unlink(path, callback) / fs.unlinkSync(path)</h5><p>删除文件。</p><h5 id="fs-readdir-path-options-callback-fs-readdirSync-path-options"><a href="#fs-readdir-path-options-callback-fs-readdirSync-path-options" class="headerlink" title="fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])"></a>fs.readdir(path[,options], callback) / fs.readdirSync(path[,options])</h5><p>读取一个目录的目录结构。</p><h5 id="fs-truncate-path-len-callback-fs-truncateSync-path-len"><a href="#fs-truncate-path-len-callback-fs-truncateSync-path-len" class="headerlink" title="fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])"></a>fs.truncate(path[, len], callback) / fs.truncateSync(path[, len])</h5><p>截断文件。</p><h5 id="fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode"><a href="#fs-mkdir-path-mode-callback-fs-mkdirSync-path-mode" class="headerlink" title="fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])"></a>fs.mkdir(path[, mode], callback) / fs.mkdirSync(path[, mode])</h5><p>创建一个文件夹。</p><h5 id="fs-rmdir-path-callback-fs-rmdirSync-path"><a href="#fs-rmdir-path-callback-fs-rmdirSync-path" class="headerlink" title="fs.rmdir(path, callback) / fs.rmdirSync(path)"></a>fs.rmdir(path, callback) / fs.rmdirSync(path)</h5><p>删除一个目录。</p><h5 id="fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath"><a href="#fs-rename-oldPath-newPath-callback-fs-renameSync-oldPath-newPath" class="headerlink" title="fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)"></a>fs.rename(oldPath, newPath, callback) / fs.renameSync(oldPath, newPath)</h5><p>重命名文件夹。</p><h5 id="fs-watchFile-filename-options-listener"><a href="#fs-watchFile-filename-options-listener" class="headerlink" title="fs.watchFile(filename[,options], listener)"></a>fs.watchFile(filename[,options], listener)</h5><p>监视文件的修改。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;fs&quot;&gt;&lt;a href=&quot;#fs&quot; class=&quot;headerlink&quot; title=&quot;fs&quot;&gt;&lt;/a&gt;fs&lt;/h2&gt;&lt;p&gt;文件系统&lt;/p&gt;
&lt;p&gt;fs模块提供了一个API，用于模仿标准的POSIX函数的方式与文件系统进行交互。&lt;/p&gt;
&lt;p&gt;引用&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const fs &amp;#x3D; require(&amp;#39;fs&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;所有文件系统操作都具有同步和异步的形式；&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之events</title>
    <link href="http://gpp-note.top/tags/2020-02-01-node-events.html"/>
    <id>http://gpp-note.top/tags/2020-02-01-node-events.html</id>
    <published>2020-02-01T08:26:59.000Z</published>
    <updated>2020-02-01T13:31:19.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="events"><a href="#events" class="headerlink" title="events"></a>events</h2><p>事件触发器。</p><p>eventEmitter.on()：用于注册监听器；<br>eventEmitter.emit()：用于触发事件；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line"></span><br><span class="line">class MyEmitter extends EventEmitter &#123;&#125;</span><br><span class="line"></span><br><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;触发事件&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="将参数和this传给监听器"><a href="#将参数和this传给监听器" class="headerlink" title="将参数和this传给监听器"></a>将参数和this传给监听器</h4><p>eventEmitter.emit()方法可以传任意数量的参数到监听器函数。<br>当监听器函数被调用时，this关键词被指向监听器所绑定的EventEmitter实例。<br>当使用ES6de箭头函数作为监听器，this不会指向EventEmitter实例。</p><h4 id="异步-VS-同步"><a href="#异步-VS-同步" class="headerlink" title="异步 VS 同步"></a>异步 VS 同步</h4><p>EventEmitter以注册的顺序同步调用所有监听器。<br>监听器函数可以使用setImmediate()和process.nextTick()方法切换到异步的操作模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;event&#39;, (a, b) &#x3D;&gt; &#123;</span><br><span class="line">  setImmediate(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;异步地发生&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;);</span><br></pre></td></tr></table></figure><h4 id="仅处理事件一次"><a href="#仅处理事件一次" class="headerlink" title="仅处理事件一次"></a>仅处理事件一次</h4><p>eventEmitter.on()注册监听器时，监听器会在每次触发命名事件时调用。<br>eventEmitter.once()可以注册最多可调用一次的监听器，当事件被触发时，监听器会被注销，然后再调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">let m &#x3D; 0;</span><br><span class="line">myEmitter.on(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 2</span><br><span class="line"></span><br><span class="line">myEmitter.once(&#39;event&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(++m);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 打印: 1</span><br><span class="line">myEmitter.emit(&#39;event&#39;);</span><br><span class="line">&#x2F;&#x2F; 不触发</span><br></pre></td></tr></table></figure><h4 id="错误事件"><a href="#错误事件" class="headerlink" title="错误事件"></a>错误事件</h4><p>EventEmitter实例出错时，应该触发error事件，<br>如果没有为error事件注册监听器，当error事件触发时，会抛出错误、打印堆栈跟踪、并退出Node进程。</p><p>为了防止崩溃Node进程，可以使用domain模块，不推荐。<br>最佳是应该始终为error事件注册监听器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const myEmitter &#x3D; new MyEmitter();</span><br><span class="line">myEmitter.on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  console.error(&#39;错误信息&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">myEmitter.emit(&#39;error&#39;, new Error(&#39;错误&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印: 错误信息</span><br></pre></td></tr></table></figure><h4 id="EventEmitter类"><a href="#EventEmitter类" class="headerlink" title="EventEmitter类"></a>EventEmitter类</h4><p>由events模块定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br></pre></td></tr></table></figure><p>当新增监听器时，会触发newListener事件；<br>当移除已存在的监听器时，则触发removeListener事件；</p><p>emitter.addListener(eventName, listener)：emitter.on(eventName, listener)的别名。<br>emitter.emit(eventName[, …args])：按照监听器注册的顺序，同步调用每个注册到名为eventName事件的监听器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const EventEmitter &#x3D; require(&#39;events&#39;);</span><br><span class="line">const myEmitter &#x3D; new EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第一个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function firstListener() &#123;</span><br><span class="line">  console.log(&#39;第一个监听器&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第二个监听器。</span><br><span class="line">myEmitter.on(&#39;event&#39;, function secondListener(arg1, arg2) &#123;</span><br><span class="line">  console.log(&#96;第二个监听器中的事件有参数 $&#123;arg1&#125;、$&#123;arg2&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 第三个监听器</span><br><span class="line">myEmitter.on(&#39;event&#39;, function thirdListener(...args) &#123;</span><br><span class="line">  const parameters &#x3D; args.join(&#39;, &#39;);</span><br><span class="line">  console.log(&#96;第三个监听器中的事件有参数 $&#123;parameters&#125;&#96;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(myEmitter.listeners(&#39;event&#39;));</span><br><span class="line"></span><br><span class="line">myEmitter.emit(&#39;event&#39;, 1, 2, 3, 4, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;   [Function: firstListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: secondListener],</span><br><span class="line">&#x2F;&#x2F;   [Function: thirdListener]</span><br><span class="line">&#x2F;&#x2F; ]</span><br><span class="line">&#x2F;&#x2F; 第一个监听器</span><br><span class="line">&#x2F;&#x2F; 第二个监听器中的事件有参数 1、2</span><br><span class="line">&#x2F;&#x2F; 第三个监听器中的事件有参数 1, 2, 3, 4, 5</span><br></pre></td></tr></table></figure><p>emitter.eventNames()：返回已注册监听器的事件名数组。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;events&quot;&gt;&lt;a href=&quot;#events&quot; class=&quot;headerlink&quot; title=&quot;events&quot;&gt;&lt;/a&gt;events&lt;/h2&gt;&lt;p&gt;事件触发器。&lt;/p&gt;
&lt;p&gt;eventEmitter.on()：用于注册监听器；&lt;br&gt;eventEmitter.emit()：用于触发事件；&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const EventEmitter &amp;#x3D; require(&amp;#39;events&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;class MyEmitter extends EventEmitter &amp;#123;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const myEmitter &amp;#x3D; new MyEmitter();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myEmitter.on(&amp;#39;event&amp;#39;, () &amp;#x3D;&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  console.log(&amp;#39;触发事件&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;myEmitter.emit(&amp;#39;event&amp;#39;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之error</title>
    <link href="http://gpp-note.top/tags/2020-02-01-node-error.html"/>
    <id>http://gpp-note.top/tags/2020-02-01-node-error.html</id>
    <published>2020-02-01T06:38:21.000Z</published>
    <updated>2020-02-01T08:24:36.903Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>错误。</p><p>NodeJs应用程序一般会有四种错误：</p><ul><li>标准的JavaScript错误；</li><li>由底层操作系统触发的系统错误；</li><li>由应用程序代码触发的用户自定义的错误；</li><li>AssertionError错误，当Node监测到不应该发生的异常逻辑时触发，这类错误通常来自assert模块；</li></ul><p>所有由Nodejs引起的Javascript错误与系统错误都继承自或实例化自标准的JavaScript<Error>类，<br>且保证至少提供类中的属性。</p><a id="more"></a><h4 id="错误的冒泡和捕获"><a href="#错误的冒泡和捕获" class="headerlink" title="错误的冒泡和捕获"></a>错误的冒泡和捕获</h4><p>异常捕获处理<code>try...catch</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 抛出一个 ReferenceError，因为 z 未定义。</span><br><span class="line">try &#123;</span><br><span class="line">  const m &#x3D; 1;</span><br><span class="line">  const n &#x3D; m + z;</span><br><span class="line">&#125; catch (err) &#123;</span><br><span class="line">  &#x2F;&#x2F; 在这里处理错误。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调中的Error参数"><a href="#回调中的Error参数" class="headerlink" title="回调中的Error参数"></a>回调中的Error参数</h4><p>大多数Nodejs核心API所提供的异步方法都遵从错误信息优先的回调模式惯例，这种模式有时也称为Nodejs回调。</p><p>但JavaScript的try…catch机制不能用来截获异步方法产生的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">     setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异常错误，这是因为异步函数执行上下文不同，所以捕获不到。</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了捕获异步产生的异常错误，可以用domain模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var domain &#x3D; require(&#39;domain&#39;);</span><br><span class="line">var d &#x3D; domain.create();</span><br><span class="line">d.run(function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;async error&#39;); &#x2F;&#x2F; 抛出一个异步异常</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">d.on(&#39;error&#39;, function (err) &#123;</span><br><span class="line">    console.log(err); &#x2F;&#x2F; 这里可以捕获异步异常</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或者express挂载接受error函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.use(function (err,req,res,next)&#123;</span><br><span class="line">   &#x2F;&#x2F;前面的中间件的错误next(err),都在这里接收。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Error类"><a href="#Error类" class="headerlink" title="Error类"></a>Error类</h4><p>new Error(message)：新建一个Error实例，创建一个异常错误对象；<br>throw new Error(message)：创建一个对象并抛出错误，如果不捕获则node崩溃；</p><p>error.code：标识错误类别的字符标签；<br>error.message：错误描述；<br>error.stack：一个字符串；</p><h4 id="AssertionError类"><a href="#AssertionError类" class="headerlink" title="AssertionError类"></a>AssertionError类</h4><p>表明断言的失败。</p><h4 id="ReferenceError类"><a href="#ReferenceError类" class="headerlink" title="ReferenceError类"></a>ReferenceError类</h4><p>表明试图访问一个未定义的变量。<br>此类错误通常表明代码有拼写错误或程序已损坏。</p><h4 id="SyntaxError类"><a href="#SyntaxError类" class="headerlink" title="SyntaxError类"></a>SyntaxError类</h4><p>表明程序不是有效的JavaScript。</p><h4 id="TypeError类"><a href="#TypeError类" class="headerlink" title="TypeError类"></a>TypeError类</h4><p>表明提供的参数不是被允许的类型。</p><h4 id="NodeJs中常用的异常处理方式"><a href="#NodeJs中常用的异常处理方式" class="headerlink" title="NodeJs中常用的异常处理方式"></a>NodeJs中常用的异常处理方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 每秒钟打印一次时间，确保程序没有奔溃</span><br><span class="line">(function loop() &#123;</span><br><span class="line">    console.log(new Date().getTime())</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        loop() </span><br><span class="line">    &#125;, 1000)</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 模拟同步代码块内出现异常</span><br><span class="line">let syncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    throw new Error(&#39;Sync Error&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 模拟异步代码块内出现异常</span><br><span class="line">let asyncError &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        throw new Error(&#39;Async Error&#39;)</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1. </span><br><span class="line">try &#123;</span><br><span class="line">    syncError()</span><br><span class="line">&#125; catch (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;异常被捕获了，我可以继续执行&#39;)</span><br><span class="line"></span><br><span class="line">2. callback方式</span><br><span class="line">fs.mkdir(&#39;&#x2F;dir&#39;, function (e) &#123;</span><br><span class="line">    if (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        console.log(&#39;创建目录成功&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">3. event方式</span><br><span class="line">let events &#x3D; require(&quot;events&quot;);</span><br><span class="line">&#x2F;&#x2F;创建一个事件监听对象</span><br><span class="line">let emitter &#x3D; new events.EventEmitter();</span><br><span class="line">&#x2F;&#x2F;监听error事件</span><br><span class="line">emitter.addListener(&quot;error&quot;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F;触发error事件</span><br><span class="line">emitter.emit(&quot;error&quot;, new Error(&#39;出错啦&#39;));</span><br><span class="line"></span><br><span class="line">4. Promise方式</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    syncError()</span><br><span class="line">    &#x2F;* or</span><br><span class="line">    try&#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;catch(e)&#123;</span><br><span class="line">        reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    *&#x2F;</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">Promise同样无法处理异步代码块中抛出的异常</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    asyncError()</span><br><span class="line">&#125;)</span><br><span class="line">.then(() &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;)</span><br><span class="line">.catch((e) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*异常无法被捕获,导致进程退出*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">5. Async&#x2F;Await方式</span><br><span class="line">var sleep &#x3D; function (time) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        syncError()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(async function () &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await sleep(100);</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        &#x2F;*处理异常*&#x2F;</span><br><span class="line">        console.log(e.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">6. process方式（可以捕获任何异常，但过于笨重）</span><br><span class="line">process.on(&#39;uncaughtException&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;);</span><br><span class="line">asyncError()</span><br><span class="line">syncError()</span><br><span class="line"></span><br><span class="line">7. domain方式（也可以处理任何异常模块）</span><br><span class="line">let domain &#x3D; require(&#39;domain&#39;)</span><br><span class="line">let d &#x3D; domain.create()</span><br><span class="line">d.on(&#39;error&#39;, function (e) &#123;</span><br><span class="line">    &#x2F;*处理异常*&#x2F;</span><br><span class="line">    console.log(e.message)</span><br><span class="line">&#125;)</span><br><span class="line">d.run(asyncError)</span><br><span class="line">d.run(syncError)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;/h2&gt;&lt;p&gt;错误。&lt;/p&gt;
&lt;p&gt;NodeJs应用程序一般会有四种错误：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准的JavaScript错误；&lt;/li&gt;
&lt;li&gt;由底层操作系统触发的系统错误；&lt;/li&gt;
&lt;li&gt;由应用程序代码触发的用户自定义的错误；&lt;/li&gt;
&lt;li&gt;AssertionError错误，当Node监测到不应该发生的异常逻辑时触发，这类错误通常来自assert模块；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有由Nodejs引起的Javascript错误与系统错误都继承自或实例化自标准的JavaScript&lt;Error&gt;类，&lt;br&gt;且保证至少提供类中的属性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
</feed>
