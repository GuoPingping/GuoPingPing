<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my-blog</title>
  <icon>https://www.gravatar.com/avatar/e3033211f497dbeb0d82dedb049dddbd</icon>
  <subtitle>关于学习 关于成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gpp-note.top/"/>
  <updated>2020-02-10T08:50:15.891Z</updated>
  <id>http://gpp-note.top/</id>
  
  <author>
    <name>Guopp</name>
    <email>2474986040@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>interview-javaScript</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-javaScript.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-javaScript.html</id>
    <published>2020-02-08T15:07:46.000Z</published>
    <updated>2020-02-10T08:50:15.891Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="let-var的区别"><a href="#let-var的区别" class="headerlink" title="let var的区别"></a>let var的区别</h4><p>let声明的变量，作用域为该语句所在的代码块内，不存在变量提升；<br>var声明的变量，作用域为该语句所在的函数内，存在变量提升；</p><h4 id="CommonJS中require-exports和ES6中import-export区别"><a href="#CommonJS中require-exports和ES6中import-export区别" class="headerlink" title="CommonJS中require/exports和ES6中import/export区别"></a>CommonJS中require/exports和ES6中import/export区别</h4><p>CommonJS模块的重要特性是加载时执行，及脚本代码在require的时候，就会全部执行。<br>一旦出现某个模块被“循环加载”就只输出已经执行的部分，还没有执行的部分是不输出的。</p><p>ES6模块的动态引用，如果使用import从一个模块加载变量，那些变量不会缓存，而是成为<br>一个指向被加载模块的引用。需要开发者自己保证，真正取值的时候能够取到值。</p><p>import/export最终都是编译为require/exports来执行的</p><p>CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。</p><p>export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><h4 id="几种常见模块化规范的简介"><a href="#几种常见模块化规范的简介" class="headerlink" title="几种常见模块化规范的简介"></a>几种常见模块化规范的简介</h4><p>CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的。<br>AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难。<br>CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Nodejs中运行。<br>ES6在语言标椎的层面上，实现了模块功能，而且实现的相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p><h4 id="模块化开发是怎么做的？"><a href="#模块化开发是怎么做的？" class="headerlink" title="模块化开发是怎么做的？"></a>模块化开发是怎么做的？</h4><p>使用命名空间</p><h4 id="WeakMap和Map的区别？"><a href="#WeakMap和Map的区别？" class="headerlink" title="WeakMap和Map的区别？"></a>WeakMap和Map的区别？</h4><p>WeakMap和Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。<br>最大的好处是可以避免内存泄漏。一个仅被WeakMap作为key而引用的对象，会被垃圾回收期回收掉。<br>WeakMap有和Map类似的set(key, value), get(key), has(key), delete(key)和clear()方法，没有任何与迭代有关的属性和方法。</p><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><h4 id="call-Apply-Bind"><a href="#call-Apply-Bind" class="headerlink" title="call Apply Bind"></a>call Apply Bind</h4><h4 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h4><h4 id="跨域请求？如何允许跨域？"><a href="#跨域请求？如何允许跨域？" class="headerlink" title="跨域请求？如何允许跨域？"></a>跨域请求？如何允许跨域？</h4><p>向不同的host的请求被称作跨域请求<br>通过设置Cors headers即Access-Control-Allow系列来允许跨域。</p><h4 id="闭包？"><a href="#闭包？" class="headerlink" title="闭包？"></a>闭包？</h4><p>所有函数都是闭包，闭包就是作用域范围，因为js是函数作用域，所以函数就是闭包。</p><p>是一种函数，能够读取其他函数内部变量的函数。<br>用途：可以读取函数内部的变量，并让这些变量的值始终保持在内存中。</p><h4 id="NaN-typeof后输出Number"><a href="#NaN-typeof后输出Number" class="headerlink" title="NaN typeof后输出Number"></a>NaN typeof后输出Number</h4><h4 id="js的隐形转换和显性转换"><a href="#js的隐形转换和显性转换" class="headerlink" title="js的隐形转换和显性转换"></a>js的隐形转换和显性转换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">隐性转换为： 1 + &#39;1&#39; &#x3D; &#39;11&#39;</span><br><span class="line">显性转换</span><br><span class="line">Number(&quot;24 cccc&quot;);&#x2F;&#x2F;结果：NaN</span><br><span class="line">ParseInt(&quot;24 cccc&quot;);&#x2F;&#x2F;结果：24</span><br><span class="line">备注：Number的显性转换比较严格，若无法强转则直接报错</span><br><span class="line"></span><br><span class="line">面试官后引伸了两个问题</span><br><span class="line">1 + -&#39;1&#39; + 1 等于什么</span><br><span class="line">等于 0 ，&#39;1&#39;前面的负号把其数字化，变为-1，则后值为1</span><br><span class="line">&#39;A&#39; - &#39;B&#39; 等于什么</span><br><span class="line">NaN</span><br></pre></td></tr></table></figure><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSON是一种轻量级的数据传输格式。<br>JSONP（JSON with padding填充式JSON）：<br>    是一种非官方跨域数据交互协议，是应用JSON的一种新方法。<br>    是用来解决跨域请求问题的。<br>    由回调函数和数据两部分组成。</p><p>原理：</p><ul><li>利用script标签的src属性来实现跨域；</li><li>通过将前端方法参数传递到服务端，然后由服务的注入参数之后再返回，实现服务器向客户端通信；</li><li>由于使用script标签的src属性，因此只支持get方法；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;GoJSONP&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;jquery-1.8.3.min.js&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    $(document).ready(function()&#123;</span><br><span class="line">        $.ajax(&#123;</span><br><span class="line">            type : &quot;get&quot;,</span><br><span class="line">            async: false,</span><br><span class="line">            url : &quot;http:&#x2F;&#x2F;www.practice-zhao.com&#x2F;student.php?id&#x3D;1&quot;,</span><br><span class="line">            dataType: &quot;jsonp&quot;,</span><br><span class="line">            jsonp:&quot;callback&quot;, &#x2F;&#x2F;请求php的参数名</span><br><span class="line">            jsonpCallback: &quot;jsonhandle&quot;,&#x2F;&#x2F;要执行的回调函数</span><br><span class="line">            success : function(data) &#123;</span><br><span class="line">                alert(&quot;age:&quot; + data.age + &quot;name:&quot; + data.name);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><h4 id="跨域问题如何解决"><a href="#跨域问题如何解决" class="headerlink" title="跨域问题如何解决"></a>跨域问题如何解决</h4><p>同源策略：浏览器安全策略，同协议、IP、端口的脚本才会执行；<br>只要协议、域名、端口有任何一个不同，都被当做是不同的域。</p><p>js跨域是指通过js在不同的域之间进行数据传输或通信。</p><ul><li>通过jsonp跨域：<br>jsonp在页面上引入不同域上的js脚本文件实现请求不同域上的数据。<br>（1）通过script标签引入js文件；<br>（2）js文件载入成功后会执行我们在url参数中指定的参数，并且会把需要的json数据作为参数传入</li><li>通过修改document.domain来跨子域；</li><li>使用window.name来跨域；</li></ul><h4 id="new的过程"><a href="#new的过程" class="headerlink" title="new的过程"></a>new的过程</h4><p>创建一个对象通常需要：</p><ul><li><p>定义构造函数</p></li><li><p>new创建对象实例</p><p>当使用new新建一个对象的时候，以new foo为例：</p></li><li><p>一个新的对象被创建，同时继承了对象类型的原型，即foo.prototype；</p></li><li><p>执行对象类型的构造函数，同时该实例的属性和方法被this引用，即this指向新构造的实例；</p></li><li><p>如果构造函数return了一个新的对象，那么这个对象就会取代整个new出来的结果。<br>  如果没有return对象，返回1所创建的对象，即隐式返回this</p></li></ul><h4 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h4><p>浏览器缓存机制可以极大的提升用户体验。</p><p>浏览器缓存就是把一个已经请求过的web资源拷贝一份到浏览器中。<br>缓存会根据进来的请求保存输入内容的副本，当下一个请求到来的时候，如果是相同的url，浏览器会根据缓存机制决定是直接使用副本响应访问请求还是向源服务器再次发起请求。</p><p>使用缓存原因：</p><ul><li>减少网络带宽消耗，降低运营成本；</li><li>降低服务器压力；</li><li>减少网络延迟；</li></ul><p>对于浏览器的缓存来讲，这些规则是在http协议头部和html页面的meta标签中定义的。<br>它们分别从新鲜度和校验值两个维度来规定浏览器是否可以直接使用缓存中的副本，还是需要去源服务器获取新版本。</p><p>过期机制：是缓存副本的有效期。<br>校验值：服务器返回资源的时候，有时在控制头信息带上这个资源的实体标签Etag，它们可以用来作为浏览器再次请求过程中的校验标识，如果不匹配，则资源已被修改或过期，浏览器需要重新获取资源内容。</p><h4 id="js实现判断一个变量是否为整数的函数"><a href="#js实现判断一个变量是否为整数的函数" class="headerlink" title="js实现判断一个变量是否为整数的函数"></a>js实现判断一个变量是否为整数的函数</h4><p> 先判断是否为Number类型，再判断除以1后是否与原值相等。</p><h4 id="JS作用域及This指向"><a href="#JS作用域及This指向" class="headerlink" title="JS作用域及This指向"></a>JS作用域及This指向</h4><p> 作用域:浏览器给js的一个生存环境（栈内存）。<br> 作用域链：js中的关键字var，function都可以提前声明和定义，放在内存地址（堆内存）中。<br>     然后从js从上到下逐行执行，遇到变量就去内存地址查找是否存在这个变量，如果有就用，没有就继续向父级作用域查找知道window下结束，这种查找机制就是作用域链。</p><p>this是js的一个关键字，指定一个对象然后去替代它。<br>看在什么情景下使用它。<br>函数内的this指向行为发生的主体。<br>函数外的this指向window，没有意义。</p><p>改变this的值：<br>call()、apply()、bind()</p><h4 id="事件捕获和冒泡"><a href="#事件捕获和冒泡" class="headerlink" title="事件捕获和冒泡"></a>事件捕获和冒泡</h4><p>捕获型事件：事件从最不精确的对象开始触发，然后到最精确（从上到下）。</p><p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标的顺序触发（从下到上）。</p><p>类似于把一个漂浮的水面上的物品向水里砸下去，下降再上升的过程。</p><p>两种方式阻止事件冒泡</p><ul><li><p>event.stopPropagation()：只阻止了事件往上冒泡，不阻止事件本身。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).mousedown(function(event)&#123;</span><br><span class="line">event.stopPropagation();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>return false：不仅阻止了事件往上冒泡，而且阻止了事件本身。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;#div1&quot;).mousedown(function(event)&#123;</span><br><span class="line">return false;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="原型、原型链"><a href="#原型、原型链" class="headerlink" title="原型、原型链"></a>原型、原型链</h4><p>原型指针<br>prototype：是函数独有的，每个函数上面都有一个属性prototype指向了函数的原型对象Person.pertotype；<br>总是被_proto_所指；<br>prototype对象默认有两个属性：constructor和_proto_；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person：构造函数</span><br><span class="line">Person.prototype：Person的原型对象，简称原型。</span><br><span class="line">function Person() &#123;&#125;</span><br><span class="line">console.log(Person.prototype);</span><br></pre></td></tr></table></figure><p>_proto_：每个实例上面都有一个隐式原型proto指向了函数的原型对象。<br>    是原型链查询中实际用到的，它总是指向prototype。<br>    所有对象都有_proto_属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    function Person(name, age) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName &#x3D; function() &#123;</span><br><span class="line">return this.name;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">console.log(p1.showName());</span><br></pre></td></tr></table></figure><p>实例访问属性或方法的时候，遵循以下原则：</p><ul><li>如果实例上面存在，就用实例本身的属性和方法；</li><li>如果实例上面不存在，就顺着_proto_的指向一直往上查找，查找就停止；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">    function Person(name, age) &#123;</span><br><span class="line">this.name &#x3D; name;</span><br><span class="line">this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.showName &#x3D; function() &#123;</span><br><span class="line">return &quot;你调用的原型上面的方法&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">p1.showName &#x3D; function() &#123;</span><br><span class="line">return &quot;你调用的是p2对象上面的方法&quot;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(p1.showName()); &#x2F;&#x2F;输出：你调用的是p1对象上面的方法</span><br><span class="line"></span><br><span class="line">var p2 &#x3D; new Person(&quot;SpringChang&quot;, 22);</span><br><span class="line">console.log(p2.showName()); &#x2F;&#x2F;输出：你调用的原型上面的方法</span><br></pre></td></tr></table></figure><p>constructor：每个函数的原型对象上面都有一个constructor属性，指向创建对象的构造函数本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor &#x3D;&#x3D; Person</span><br></pre></td></tr></table></figure><p>什么是原型链？</p><blockquote><p>每个对象都可以有一个原型_prop，这个原型可以有它自己的原型，以此类推，形成一个原型链。</p></blockquote><h4 id="JS中的继承方式"><a href="#JS中的继承方式" class="headerlink" title="JS中的继承方式"></a>JS中的继承方式</h4><p>面向对象的基本特征：封闭、继承、多态。</p><p>js中实现继承的方法：</p><ul><li>对象冒充</li><li>call()、apply()</li><li>原型链</li><li>混合方式</li></ul><h5 id="对象冒充"><a href="#对象冒充" class="headerlink" title="对象冒充"></a>对象冒充</h5><p> JavaScript对象冒充实现继承：本质上是改变this的指向。<br>原理：</p><blockquote><p>构造函数使用this关键字给所有属性和方法赋值，因为构造函数只是一个函数，所以可使classA的构造方法称为ClassB的方法，然后调用它。<br>ClassA就会收到ClassB的构造方法中定义的属性和方法。<br>对象冒充可以支持多重继承，即一个类可以继承多个类。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function ClassA(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.getName&#x3D;function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ClassB(name,password)&#123;</span><br><span class="line">    this.ClassA&#x3D;ClassA;</span><br><span class="line">    this.ClassA(name);</span><br><span class="line">    delete this.ClassA;</span><br><span class="line">    </span><br><span class="line">    this.password&#x3D;password;</span><br><span class="line">    this.getPassword&#x3D;function()&#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b &#x3D;new ClassB(&#39;wwww&#39;,&#39;1123&#39;);</span><br><span class="line">document.write(b.getName());</span><br></pre></td></tr></table></figure><h5 id="call实现对象冒充"><a href="#call实现对象冒充" class="headerlink" title="call实现对象冒充"></a>call实现对象冒充</h5><blockquote><p>它的第一个参数用做this的对象，其他参数都直接传递给函数自身。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">function ShowColor(param1,param2)&#123;</span><br><span class="line">    this.getColor&#x3D;function()&#123;</span><br><span class="line">        document.write(this.color+&quot;&lt;br&#x2F;&gt;Two Params : &quot;+param1+&quot; ; &quot;+param2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new Object;</span><br><span class="line">obj.color&#x3D;&#39;Red&#39;;</span><br><span class="line">ShowColor.call(obj,&quot;pm1&quot;,&#39;pm2&#39;);</span><br><span class="line"></span><br><span class="line">obj.getColor();</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">Red</span><br><span class="line">Two Params:pm1;pm2</span><br><span class="line"></span><br><span class="line">function ClassA(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">    this.getName&#x3D;function()&#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function ClassB(name,password)&#123;</span><br><span class="line">    &#x2F;&#x2F;this.ClassA&#x3D;ClassA;</span><br><span class="line">    &#x2F;&#x2F;this.ClassA(name);</span><br><span class="line">    &#x2F;&#x2F;delete this.ClassA;</span><br><span class="line">    ClassA.call(this,name);</span><br><span class="line">    </span><br><span class="line">    this.password&#x3D;password;</span><br><span class="line">    this.getPassword&#x3D;function()&#123;</span><br><span class="line">        return this.password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; new ClassB(&#39;www&#39;,&#39;111&#39;);</span><br><span class="line">b.getPassword();</span><br><span class="line">&#x2F;&#x2F; 此处ClassA.call(this, name)，即将ClassA的this指向了CalssB的this，从而实现了对象冒充。</span><br></pre></td></tr></table></figure><h5 id="apply方法实现对象冒充"><a href="#apply方法实现对象冒充" class="headerlink" title="apply方法实现对象冒充"></a>apply方法实现对象冒充</h5><blockquote><p>apply方法有两个参数，用作this的对象和要传递给函数的参数的数组。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ShowColor(param1,param2)&#123;</span><br><span class="line">    this.getColor&#x3D;function()&#123;</span><br><span class="line">        document.write(this.color+&quot;&lt;br&#x2F;&gt;Two Params : &quot;+param1+&quot; ; &quot;+param2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; new Object;</span><br><span class="line">obj.color&#x3D;&#39;Red&#39;;</span><br><span class="line">ShowColor.apply(obj,new Array(&quot;pm1&quot;,&#39;pm2&#39;));</span><br><span class="line"></span><br><span class="line">obj.getColor();</span><br></pre></td></tr></table></figure><h5 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Person(name)&#123;</span><br><span class="line">    this.name&#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.GetName&#x3D;function()&#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function User(name,password)&#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.password &#x3D; password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">User.prototype &#x3D; new Person();</span><br><span class="line">User.prototype.GetPassword&#x3D;function()&#123;</span><br><span class="line">    return this.password;</span><br><span class="line">&#125;</span><br><span class="line">User是对User对象构造函数的引用,new Person()使用person构造函数创建了一个Person对象,然后把Person对象的原型置为这个操作的结果.也就是说,当每次new User()时,得到的新User对象都会带有Person对象的所有方法。</span><br></pre></td></tr></table></figure><h4 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h4><h4 id="事件委托的概念你了解吗？您知道这个概念是怎样的？事件委托主要解决什么问题呢？"><a href="#事件委托的概念你了解吗？您知道这个概念是怎样的？事件委托主要解决什么问题呢？" class="headerlink" title="事件委托的概念你了解吗？您知道这个概念是怎样的？事件委托主要解决什么问题呢？"></a>事件委托的概念你了解吗？您知道这个概念是怎样的？事件委托主要解决什么问题呢？</h4><h4 id="null和undefined有什么区别？"><a href="#null和undefined有什么区别？" class="headerlink" title="null和undefined有什么区别？"></a>null和undefined有什么区别？</h4><p>普通函数和构造函数的区别<br>设计模式有了解吗？（比如观察者模式）？</p><p>CORS原理是什么？</p><p>JS有没有了解过函数式编程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;let-var的区别&quot;&gt;&lt;a href=&quot;#let-var的区别&quot; class=&quot;headerlink&quot; title=&quot;let var的区别&quot;&gt;&lt;/a&gt;let var的区别&lt;/h4&gt;&lt;p&gt;let声明的变量，作用域为该语句所在的
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-httpNet</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-httpNet.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-httpNet.html</id>
    <published>2020-02-08T15:03:10.000Z</published>
    <updated>2020-02-10T08:50:15.891Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="计算机网络的七层"><a href="#计算机网络的七层" class="headerlink" title="计算机网络的七层"></a>计算机网络的七层</h4><p>应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</p><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><p>TCP：<br>    面向连接、<br>    传输可靠(保证数据正确性，保证数据顺序)、<br>    用于传输大量数据(流模式)、<br>    速度慢、<br>    建立连接需要开销比较多（时间、系统资源）。</p><p>一般用于文件传输、发送接收邮件、远程登录等。</p><p>UDP：<br>    面向非连接、<br>    传输不可靠、<br>    用于传输少量数据(数据包模式)、<br>    速度快。</p><p>用于即时通信。</p><h4 id="http、https"><a href="#http、https" class="headerlink" title="http、https"></a>http、https</h4><p>http：超文本传输协议，是一个客户端和服务端请求和应答、无状态的、应用层的协议，<br>用于从www服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p>特点：</p><ul><li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作；</li><li>无连接：每次请求都要通过TCP三次握手四次挥手，和服务器重新建立连接。消耗不必要的时间和流量；</li><li>基于请求和响应：客户端发起请求，服务端响应；</li><li>简单快速、灵活；</li><li>通信使用明文、请求和响应不会对通信方进行确认、无法保证数据的完整性；</li></ul><p>https：是一种通过计算机网络进行安全通信的传输协议，是以安全为目标的Http通道，简单说是http的安全版，利用SSL/TLS建立全信道，加密数据包。</p><p>特点：</p><ul><li>内容加密：采用混合加密技术，中间者无法直接查看明文内容；</li><li>验证身份：通过证书认证客户端访问的是自己的服务器；</li><li>保护数据完整性：防止传输的内容被中间人冒充或篡改；</li></ul><h4 id="http和TCP的区别"><a href="#http和TCP的区别" class="headerlink" title="http和TCP的区别"></a>http和TCP的区别</h4><p>http对应于应用层，是在tcp协议之上建立的，http在发起请求时通过tcp协议建立起连接服务器的通道，请求结束后，立即断开tcp连接；</p><p>http是无状态的短连接，tcp是有状态的长连接；</p><p>tcp对应于传输层；</p><h4 id="几种常见的状态码"><a href="#几种常见的状态码" class="headerlink" title="几种常见的状态码"></a>几种常见的状态码</h4><ul><li>2XX：请求已成功被服务器接收、理解；</li><li>200：请求已成功；</li><li>201：请求成功并且服务器创建了新的资源；</li><li>3XX：需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址在本次响应的location域中声明；</li><li>301：重定向，被请求的资源已被永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置；</li><li>302：请求的资源临时从不同的URL响应请求，但请求者应继续使用原有位置来进行以后的请求；</li><li>304：自从上次请求，网页未修改过，服务器返回次响应，不会返回网页内容；</li><li>4XX：请求错误。</li><li>401：请求要求身份验证；</li><li>403：服务器以理解请求，但拒绝执行；</li><li>404：请求失败；</li><li>5XX：服务器异常</li></ul><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>线程是最小的执行单元，进程是由线程组成。<br>如何调度线程和进程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p><p>进程是计算机中已运行的程序。<br>线程是操作系统能够运行调度的最小单位。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>当两个以上的运算单元，双方都在等待对方停止运行，以获取系统资源，但没有一方愿意提前退出，就成为死锁。</p><h4 id="https说一下过程？"><a href="#https说一下过程？" class="headerlink" title="https说一下过程？"></a>https说一下过程？</h4><p>OSI七层协议？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;计算机网络的七层&quot;&gt;&lt;a href=&quot;#计算机网络的七层&quot; class=&quot;headerlink&quot; title=&quot;计算机网络的七层&quot;&gt;&lt;/a&gt;计算机网络的七层&lt;/h4&gt;&lt;p&gt;应用层、表示层、会话层、传输层、网络层、数据链路层、物
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-vue</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-vue.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-vue.html</id>
    <published>2020-02-08T15:00:28.000Z</published>
    <updated>2020-02-10T08:50:15.890Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><blockquote><p>Vue生命周期</p></blockquote><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Vue生命周期是Vue实例从创建到销毁的过程。</p><p>从开始创建、初始化数据、编译模板、挂在DOM-&gt;渲染、更新-&gt;渲染、销毁等一系列过程。</p><p>创建前/后、载入前/后、更新前/后、销毁前/后。</p><h4 id="生命周期线"><a href="#生命周期线" class="headerlink" title="生命周期线"></a>生命周期线</h4><ol><li>beforeCreate：创建前。新对象诞生，在对象初始化之前执行；</li><li>created：创建后。创建具有默认特性的对象；</li><li>beforeMount：载入前。在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html，此时还没有挂载html到页面上；</li><li>mounted：载入后。创建vm.$el替换，并挂载到实例上去之后调用，实例已完成：用上面编译好的html内容替换el指向的DOM对象，完成模板中的html渲染到html页面中；</li><li>beforeUpdate：更新前。数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步更改状态，不会触发附加的重渲染过程；</li><li>updated：更新后。调用时，组件DOM已经更新；</li><li>beforeDestory：销毁前。实例仍然完全可用；</li><li>destoryed：销毁后。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。</li></ol><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>控制整个Vue实例过程时更容易形成好的逻辑。</p><h4 id="第一次加载页面会触发几个钩子？"><a href="#第一次加载页面会触发几个钩子？" class="headerlink" title="第一次加载页面会触发几个钩子？"></a>第一次加载页面会触发几个钩子？</h4><p>四个，beforeCreated、created、beforeMount、mounted。</p><h4 id="Vue-router实现原理"><a href="#Vue-router实现原理" class="headerlink" title="Vue-router实现原理"></a>Vue-router实现原理</h4><p>vue-router通过hash与history两种方式实现前端路由，<strong>更新视图但不重新请求页面</strong>是前端路由原理的核心之一。</p><p>hash：利用URL中的hash（“#”）,在URL后加#，是url中的锚点，代表网页中的一个位置，单单改变#后的部分，浏览器只会加载相应位置的内容，不会重新加载页面。</p><p>history：是Html5新增的方法，不刷新整个页面实现URL跳转。</p><p>abstract：支持所有JavaScript运行环境，不依赖于浏览器的浏览历史虚拟管理后端。</p><p>vue-router通过mode参数来决定采用哪一种方式，默认是hash</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import Router from &#39;vue-router&#39;</span><br><span class="line">import routes from &#39;.&#x2F;routes&#39;</span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"></span><br><span class="line">export default new Router(&#123;</span><br><span class="line">  &#x2F;&#x2F; mode: &#39;history&#39;,</span><br><span class="line">  routes</span><br><span class="line">&#125;)</span><br><span class="line">mode：hash</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;#&#x2F;recommend</span><br><span class="line">mode：history</span><br><span class="line">http:&#x2F;&#x2F;localhost:8080&#x2F;recommend</span><br></pre></td></tr></table></figure><h4 id="MVVM框架"><a href="#MVVM框架" class="headerlink" title="MVVM框架"></a>MVVM框架</h4><ul><li>当前台显示的view发生变化，会实时反应到viewModel上，如果需要，viewModel会通过ajax等方法将改变的数据传递给后台model。</li><li>同时后台model获取过来的数据，通过vm将值响应到前台UI上。</li></ul><h4 id="vue-model双向绑定原理"><a href="#vue-model双向绑定原理" class="headerlink" title="vue-model双向绑定原理"></a>vue-model双向绑定原理</h4><p>透过MVVM模式实现vue的双向绑定数据。</p><p>当data变化时，通过Object.definePrototype()方法的set进行监控，并调用在此之前已经定义好的data和view，来通知view进行数据的改变。<br>view发生改变则是通过底层的input事件进行data的响应更改。</p><p>vue是通过Object.definePrototype()来实现数据劫持的。</p><p>实现方法：观察者模式</p><ul><li>数据监听器Obverser，对data中的数据进行监听，若有变化，通知响应的订阅者；</li><li>实现一个指令解析器compile，对于每个元素上的指令进行解析，根据指令替换数据，更新视图；</li><li>实现一个watcher，用来连接obverser和compile，并为每个属性绑定相应的订阅者，当数据发生变化，执行响应的回调函数，从而更新视图；</li><li>构造函数new Vue</li></ul><h4 id="options预检请求"><a href="#options预检请求" class="headerlink" title="options预检请求"></a>options预检请求</h4><p>cors：cross-origin resource sharing跨域资源共享，是一个系统，由一系列传输的http头组成，这些http头决定浏览器是否阻止前端JavaScript代码获取跨域请求的响应。</p><p>同源安全策略默认阻止“跨域”获取资源。但cors给了web服务器这样的权限，即服务器可以选择允许跨域请求访问到它们的资源。</p><h5 id="简单请求和非简单请求"><a href="#简单请求和非简单请求" class="headerlink" title="简单请求和非简单请求"></a>简单请求和非简单请求</h5><p>simple request:</p><blockquote><p>请求方法是以下三种之一：HEAD、GET、POST<br>HTTP头部信息不超出以下几种字段：Accept、Accept-Language、Content-Language、Last-Event-ID、Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain。</p></blockquote><p>   not-so-simple request：不满足以上条件的就是非简单请求。<br>   常见的非简单请求有：</p><blockquote><p>请求方法是put或delete<br>content-type类型为application/json<br>添加额外的http header</p></blockquote><h5 id="浏览器在什么情况下发起options预检请求？"><a href="#浏览器在什么情况下发起options预检请求？" class="headerlink" title="浏览器在什么情况下发起options预检请求？"></a>浏览器在什么情况下发起options预检请求？</h5><p>在跨域情况下，非简单请求会先发起一次空body的options请求，成为“预检”请求，用于向服务器请求权限信息，等预检请求被成功响应后，才发起真正的http请求。</p><blockquote><p>浏览器的预检请求结果可以通过设置Access-Control-Max-Age进行缓存。</p></blockquote><h4 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h4><p>实现ES6编译为ES5代码</p><h4 id="Vue-router跳转和Location-href区别？"><a href="#Vue-router跳转和Location-href区别？" class="headerlink" title="Vue router跳转和Location.href区别？"></a>Vue router跳转和Location.href区别？</h4><p>router是hash改变<br>href是页面跳转，刷新页面</p><h4 id="Vue双向绑定实现原理？"><a href="#Vue双向绑定实现原理？" class="headerlink" title="Vue双向绑定实现原理？"></a>Vue双向绑定实现原理？</h4><p>通过Object.defineProperty实现的。</p><h4 id="React和Vue有什么区别？"><a href="#React和Vue有什么区别？" class="headerlink" title="React和Vue有什么区别？"></a>React和Vue有什么区别？</h4><h4 id="怎么上手的vue，以及为啥用vue而不用其他框架？"><a href="#怎么上手的vue，以及为啥用vue而不用其他框架？" class="headerlink" title="怎么上手的vue，以及为啥用vue而不用其他框架？"></a>怎么上手的vue，以及为啥用vue而不用其他框架？</h4><h4 id="你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？"><a href="#你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？" class="headerlink" title="你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？"></a>你对vue的源码了解吗，给我讲讲双向绑定原理怎么实现的，详细描述什么时候监听变化的，什么时候触发变化的？</h4><h4 id="Vue双向绑定？"><a href="#Vue双向绑定？" class="headerlink" title="Vue双向绑定？"></a>Vue双向绑定？</h4><h4 id="Vuex整个触发过程（actions，state，view）？"><a href="#Vuex整个触发过程（actions，state，view）？" class="headerlink" title="Vuex整个触发过程（actions，state，view）？"></a>Vuex整个触发过程（actions，state，view）？</h4><h4 id="Vue和Vuex有什么差别？"><a href="#Vue和Vuex有什么差别？" class="headerlink" title="Vue和Vuex有什么差别？"></a>Vue和Vuex有什么差别？</h4><h4 id="知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？"><a href="#知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？" class="headerlink" title="知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？"></a>知道拷贝对象吧，拷贝一个对象能做吗（浅拷贝，深拷贝）？</h4><h4 id="为什么你们的页面要用到vue-router呢-，如果没有vue-router，你们还会做单页面应用吗？"><a href="#为什么你们的页面要用到vue-router呢-，如果没有vue-router，你们还会做单页面应用吗？" class="headerlink" title="为什么你们的页面要用到vue-router呢?，如果没有vue-router，你们还会做单页面应用吗？"></a>为什么你们的页面要用到vue-router呢?，如果没有vue-router，你们还会做单页面应用吗？</h4><h4 id="传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？"><a href="#传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？" class="headerlink" title="传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？"></a>传输模型：浏览器输入url到整个页面显示出来经历的过程？能介绍多细就多细？</h4><h4 id="Vue中Compile过程说一下？"><a href="#Vue中Compile过程说一下？" class="headerlink" title="Vue中Compile过程说一下？"></a>Vue中Compile过程说一下？</h4><p>Vue的设计思路你了解吗</p><p>Vue的响应式是怎么实现的？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;blockquote&gt;
&lt;p&gt;Vue生命周期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;p&gt;Vue生命周期是V
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-database</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-database.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-database.html</id>
    <published>2020-02-08T14:52:40.000Z</published>
    <updated>2020-02-10T08:50:15.890Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>什么是MongoDB？<br>是一个数据库，高性能、无模式、文档性、开源性、基于c++开发的、基于分布式文件存储的非关系型数据库。</p><p>特点：</p><ul><li>面向集合文档的存储，适合存储Bson(json)形式的数据；</li><li>格式自由，数据格式不固定，生产环境下修改结构都可以不影响程序运行；</li><li>强大的查询语句，面向对象的查询语言，基本覆盖sql语言所有能力；</li><li>完整的索引支持，支持查询计划；</li><li>支持复制和自动故障转移；</li><li>支持二进制数据及大型对象的高效存储；</li><li>使用分片集群提升系统扩展性；</li><li>使用内存映射存储引擎，把磁盘的IO操作转换为内存的操作；</li></ul><p>缺点：</p><ul><li>mongodb对事务的支持较弱：高度事务性系统；</li><li>不支持join和复杂查询；</li><li>磁盘空间占用比较大；</li><li>在集群分片中的数据分布不均匀；</li><li>单机可靠性比较差；</li><li>大数据量持续插入，写入性能有较大波动；</li></ul><h4 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h4><p>关系型数据库</p><p>优点：</p><ul><li><p>在不同的引擎上有不同的存储方式。</p></li><li><p>查询语句使用传统的sql语句，拥有比较成熟的体系，成熟度很高；</p><p>缺点：</p></li><li><p>在海量数据处理的时候效率会显著变慢；</p></li></ul><h4 id="left-join-right-join-inner-join"><a href="#left-join-right-join-inner-join" class="headerlink" title="left join /right join/ inner join"></a>left join /right join/ inner join</h4><p>left join：关键字会从左表返回所有的行，即使右表没有匹配的行；<br>right join：关键字会从右表返回所有的行，即使左表没有匹配的行；<br>inner join：在表中存在至少一个匹配时；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;MongoDB&quot;&gt;&lt;a href=&quot;#MongoDB&quot; class=&quot;headerlink&quot; title=&quot;MongoDB&quot;&gt;&lt;/a&gt;MongoDB&lt;/h4&gt;&lt;p&gt;什么是MongoDB？&lt;br&gt;是一个数据库，高性能、无模式、文
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-algorithm</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-algorithm.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-algorithm.html</id>
    <published>2020-02-08T14:46:44.000Z</published>
    <updated>2020-02-10T08:49:47.211Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h4><p>归并思路，维护一个堆就行。<br>nlgn</p><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr) &#123;</span><br><span class="line">  if(arr.length&lt;&#x3D;1) &#123;</span><br><span class="line">  return arr;</span><br><span class="line">  &#125;</span><br><span class="line">  var s &#x3D; Math.floor(arr.length&#x2F;2);</span><br><span class="line"> </span><br><span class="line">  var temp &#x3D; arr.splice(s,1);</span><br><span class="line">  </span><br><span class="line">  var left&#x3D;[];</span><br><span class="line">  var right&#x3D;[];</span><br><span class="line">  for(var i&#x3D;0;i&lt;arr.length;i++) &#123;</span><br><span class="line">    if(arr[i]&lt;temp) &#123;</span><br><span class="line">      left.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    if(arr[i]&gt;&#x3D;temp) &#123;</span><br><span class="line">      right.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return quickSort(left).concat(temp,quickSort(right));  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cxyxiaowu.com/7072.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/7072.html</a><br><a href="https://www.cxyxiaowu.com/7072.html" target="_blank" rel="noopener">https://www.cxyxiaowu.com/7072.html</a></p><p><a href="https://blog.csdn.net/Design407/article/details/103242874" target="_blank" rel="noopener">https://blog.csdn.net/Design407/article/details/103242874</a></p><p><a href="https://blog.csdn.net/hebtu666/article/details/103127563" target="_blank" rel="noopener">https://blog.csdn.net/hebtu666/article/details/103127563</a></p><p><a href="https://blog.csdn.net/m0_37907797/article/details/103252306" target="_blank" rel="noopener">https://blog.csdn.net/m0_37907797/article/details/103252306</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;多路归并&quot;&gt;&lt;a href=&quot;#多路归并&quot; class=&quot;headerlink&quot; title=&quot;多路归并&quot;&gt;&lt;/a&gt;多路归并&lt;/h4&gt;&lt;p&gt;归并思路，维护一个堆就行。&lt;br&gt;nlgn&lt;/p&gt;
&lt;h4 id=&quot;快速排序&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-koaExpress</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-koaExpress.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-koaExpress.html</id>
    <published>2020-02-08T14:13:23.000Z</published>
    <updated>2020-02-10T08:50:15.890Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="Koa和Express的区别和联系？"><a href="#Koa和Express的区别和联系？" class="headerlink" title="Koa和Express的区别和联系？"></a>Koa和Express的区别和联系？</h4><p>Koa是由Express原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的Web框架。<br>使用koa编写web应用，通过组合不同的generator，可以避免重复繁琐的回调函数嵌套，极大的提升错误处理的效率。<br>koa不在内核方法中绑定任何中间件，它仅提供了一个轻量优雅的函数库，使得编写Web应用变得得心应手。<br>koa是比express更精简，使用node新特性的中间件框架，有足够的扩展和中间件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;Koa和Express的区别和联系？&quot;&gt;&lt;a href=&quot;#Koa和Express的区别和联系？&quot; class=&quot;headerlink&quot; title=&quot;Koa和Express的区别和联系？&quot;&gt;&lt;/a&gt;Koa和Express的区
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-cssHtmlVue</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-cssHtml.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-cssHtml.html</id>
    <published>2020-02-08T13:20:52.000Z</published>
    <updated>2020-02-10T08:50:15.891Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h4 id="四种定位的区别"><a href="#四种定位的区别" class="headerlink" title="四种定位的区别"></a>四种定位的区别</h4><ul><li>static：默认值</li><li>relative：相对定位，相对于自身原有位置进行偏移，仍处于标准文档流中</li><li>absolute：绝对定位，相对于最近的已定位的祖先元素，有已定位祖先元素，以最近的祖先元素为标准。如果无已定位祖先元素，以body元素为偏移参照基准，完全脱离了标椎文档流</li><li>fixed：固定定位的元素会相对于视窗来定位，这意味着即便页面滚动，它还是会停留在相同的位置。一个固定定位元素不会保留它原来在页面应有的空隙</li></ul><h4 id="Flex布局用的多吗？"><a href="#Flex布局用的多吗？" class="headerlink" title="Flex布局用的多吗？"></a>Flex布局用的多吗？</h4><p>因为项目考虑兼容IE9 用的不多</p><h4 id="移动端适配怎么做的？"><a href="#移动端适配怎么做的？" class="headerlink" title="移动端适配怎么做的？"></a>移动端适配怎么做的？</h4><p>使用媒体查询做的响应式布局，根据不同屏幕宽度加载不同css</p><h3 id="四、Html"><a href="#四、Html" class="headerlink" title="四、Html"></a>四、Html</h3><h4 id="浏览器是怎么加载一个HTML的"><a href="#浏览器是怎么加载一个HTML的" class="headerlink" title="浏览器是怎么加载一个HTML的"></a>浏览器是怎么加载一个HTML的</h4><ul><li>加载HTML</li><li>解析器解析html</li><li>创建Dom树，加载css</li><li>解析器解析css，将css规则集应用于dom树节点</li><li>浏览器展示页面</li></ul><h3 id="五、css2与css3"><a href="#五、css2与css3" class="headerlink" title="五、css2与css3"></a>五、css2与css3</h3><h4 id="css2的水平居中与垂直居中"><a href="#css2的水平居中与垂直居中" class="headerlink" title="css2的水平居中与垂直居中"></a>css2的水平居中与垂直居中</h4><p>css2的水平居中：<br>    display为行内元素，text-align:center<br>    或：块级元素定义为一个宽度，再margin:0 auto；</p><p>垂直居中：<br>    单行内容的垂直通过设置相同的height和line-height<br>    多行且高度可变通过设置上下相同的padding<br>    行级盒子—-小图标和标题对齐设置vertical-aligh:middle<br>    绝对定位—-top:50%  left:50,需要已知块级的kuangao</p><p>css3水平居中：<br>display为flex，justify-content:center</p><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><p>BFC：Block Formatting Context 块格式化上下文</p><p>生成BFC：</p><ul><li><p>float:left/right</p></li><li><p>根元素html</p></li><li><p>overflow:hidden,auto,scoll</p></li><li><p>display:inline-block</p></li><li><p>position:fixed,absolute</p><p>BFC规则：</p></li><li><p>垂直方向上的距离由margin决定，属于同一个BFC的两个相邻的标签的margin会发生重叠；</p></li><li><p>每个标签的左外边距与包含块的左外边界相接触，即使浮动标签也是如此；</p></li><li><p>BFC的区域不会与浮动的标签区域重叠；</p></li><li><p>计算BFC高度的时候，浮动子元素也参与计算；</p></li><li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响外面的标签，反之亦然。</p><p>BFC能解决什么问题？</p></li><li><p>外边距重叠</p></li><li><p>自适应两栏或三栏布局</p></li><li><p>防止字体环绕</p></li><li><p>清除浮动</p></li></ul><h4 id="rem和em有什么去区别啊？"><a href="#rem和em有什么去区别啊？" class="headerlink" title="rem和em有什么去区别啊？"></a>rem和em有什么去区别啊？</h4><p>position和float的区别？</p><h4 id="用一个div模拟textarea的实现"><a href="#用一个div模拟textarea的实现" class="headerlink" title="用一个div模拟textarea的实现"></a>用一个div模拟textarea的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#textarea &#123;</span><br><span class="line">    width:300px;</span><br><span class="line">    border:1px solid #ccc;</span><br><span class="line">    min-height:150px;</span><br><span class="line">    max-height:300px;</span><br><span class="line">    overflow: auto;</span><br><span class="line">    font-size: 14px;</span><br><span class="line">    outline: none;</span><br><span class="line">&#125;</span><br><span class="line">&lt;div id&#x3D;&quot;textarea&quot; contenteditable&#x3D;&quot;true&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><h4 id="左右布局：左边定宽、右边自适应"><a href="#左右布局：左边定宽、右边自适应" class="headerlink" title="左右布局：左边定宽、右边自适应"></a>左右布局：左边定宽、右边自适应</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;left&quot;&gt;</span><br><span class="line">   &lt;p&gt;左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左左&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;right&quot;&gt;</span><br><span class="line">   &lt;p&gt;右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右右&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ol><li><p>左边左浮动，右边margin-left</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">   float: left;</span><br><span class="line">   width: 200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">   margin-left:200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左边绝对定位，右边margin-left</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   top: 0;</span><br><span class="line">   left: 0;</span><br><span class="line">   width: 200px;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    margin-left:200px;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">    word-break: break-all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左右两边都用绝对定位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">    position: absolute;</span><br><span class="line">    top: 0;</span><br><span class="line">    left: 0;</span><br><span class="line">    width: 200px;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">   position: absolute;</span><br><span class="line">   left: 200px;</span><br><span class="line">   top:0;</span><br><span class="line">   border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>左边左浮动，右边overflow:hidden</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">     float: left;</span><br><span class="line">     width: 200px;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">     overflow: hidden;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>弹性布局，左边固定宽度，右边flex</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">*&#123;margin: 0;padding: 0;&#125;</span><br><span class="line">.box&#123;</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br><span class="line">.left&#123;</span><br><span class="line">     width: 200px;</span><br><span class="line">     border: 1px solid #333;</span><br><span class="line">&#125;</span><br><span class="line">.right&#123;</span><br><span class="line">    flex:1;</span><br><span class="line">    width: 0;</span><br><span class="line">    border: 1px solid #333;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="CSS3有哪些新的特性？"><a href="#CSS3有哪些新的特性？" class="headerlink" title="CSS3有哪些新的特性？"></a>CSS3有哪些新的特性？</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h4 id=&quot;四种定位的区别&quot;&gt;&lt;a href=&quot;#四种定位的区别&quot; class=&quot;headerlink&quot; title=&quot;四种定位的区别&quot;&gt;&lt;/a&gt;四种定位的区别&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;static：默认值&lt;/li&gt;
&lt;li&gt;relat
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview-node</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview-node.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview-node.html</id>
    <published>2020-02-08T11:27:51.000Z</published>
    <updated>2020-02-10T08:48:30.251Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>一、node</p><h4 id="node？"><a href="#node？" class="headerlink" title="node？"></a>node？</h4><p>node既是开发平台，也是运行环境，也是新的语言。<br>本身是基于google的JavaScript V8引擎开发的。<br>一个运行在服务端的基于Chrome V8 engine的js运行环境(runtime)。</p><p>简单强大、轻量可扩展。</p><p>简单：node使用的是JavaScript，json来进行编码，人人都会；<br>强大：非阻塞IO，可以适应分块传输数据，较慢的网络环境，尤其擅长高并发访问；<br>轻量：node本身既是代码，又是服务器，前后端使用统一语言；<br>可扩展性：轻松应对多实例，多服务架构，同时拥有海量的第三方应用组件；</p><h4 id="node有哪些特质，与其他服务器端对比"><a href="#node有哪些特质，与其他服务器端对比" class="headerlink" title="node有哪些特质，与其他服务器端对比"></a>node有哪些特质，与其他服务器端对比</h4><p>特征：单线程、事件驱动、非阻塞I/O.<br>适合做一些如：<br>    聊天室、表单提交等不需要大量计算的功能<br>    做一些微信后端开发、或消息系统；</p><ul><li>node无法直接渲染静态页面，提供静态服务；</li><li>node没有根目录的概念；</li><li>node必须通过路由程序指定文件才能渲染文件；</li><li>node比其他服务端性能更好，速度更快；</li></ul><h4 id="node优点？"><a href="#node优点？" class="headerlink" title="node优点？"></a>node优点？</h4><p>高并发；<br>高效、轻量；<br>node是基于事件驱动和非阻塞的I/O模型，所以比较适合处理并发请求，执行效率非常高；</p><h4 id="node的缺点？"><a href="#node的缺点？" class="headerlink" title="node的缺点？"></a>node的缺点？</h4><ul><li>Node是一个相对新的开源项目，不太稳定，总是在变，而且缺少足够的第三方库的支持；</li><li>不适合CPU密集型应用，会导致主线程阻塞，阻止后续程序运行<br>原因：<br>因为JavaScript单线程原因，如果长时间运行的计算，将会导致cpu时间片不能释放，使得后续I/O无法发起）。<br>解决方案：<br>分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起；</li><li>只支持单核CPU，不能充分利用CPU<br>解决方案：<br>（1）Nnigx反向代理，负载均衡，开多个进程，绑定多个端口；<br>（2）开多个进程监听同一个端口，使用cluster模块；</li></ul><h4 id="node的组成？"><a href="#node的组成？" class="headerlink" title="node的组成？"></a>node的组成？</h4><ul><li>v8 engine<br>  两个作用：<br>  一是作为虚拟机，负责js的解释执行；<br>  二是提供c++函数接口，为node提供v8初始化，创建context、scope等；</li><li>libuv<br>libuv是基于事件驱动的异步I/O模型库，nodejs中事件、线程、I/O等操作都依赖于libuv实现。</li><li>builtiin modules内置模块<br>  内置模块是由c++编写的模块，一般用于native modules调用。</li><li>native modules<br>  native modules是由js编写的模块，如http、crypto、zlib、buffer、fs等，同时这些模块又依赖builtin modules等来获取相应的服务支持。</li></ul><p>运行原理：<br>把nodejs看做一个黑匣子，暴露给开发者的接口则是native modules，当发起请求时，请求自上而下，穿越native modules，通过builtin modules将请求传送至v8，libuv和其它辅助服务，请求结束，则从下回溯到上，最终调用我们的回调函数。</p><h4 id="node的构架是什么样子的？"><a href="#node的构架是什么样子的？" class="headerlink" title="node的构架是什么样子的？"></a>node的构架是什么样子的？</h4><p>主要分三层：应用app 》》 V8及node内置架构 》》操作系统。<br>V8是node运行环境，可以理解为node虚拟机<br>node内置架构又分为三层：核心模块（JavaScript实现） 》》c++绑定 》》libuv + CAes + http</p><h4 id="node的同步、异步、阻塞、非阻塞"><a href="#node的同步、异步、阻塞、非阻塞" class="headerlink" title="node的同步、异步、阻塞、非阻塞"></a>node的同步、异步、阻塞、非阻塞</h4><p>同步：调用者等待被调用者这个过程，如果被调用者一直不返回结果，调用者就会一直等待。<br>        同步有返回值。<br>异步：调用者不等待被调用者是否返回，被调用者执行问了就会通过状态、通知或回调函数给调用者。<br>        异步没有返回值。<br>阻塞：指代当前线程在结果返回之前会被挂起，不会继续执行下去。<br>非阻塞：即当前线程不管返回什么，都会继续往下执行。</p><h4 id="node的进程与线程"><a href="#node的进程与线程" class="headerlink" title="node的进程与线程"></a>node的进程与线程</h4><p>进程是操作系统分配资源和调度任务的基本单位<br>线程是建立在进程上的一次程序运行单位，一个进程上可以有多个线程。</p><h4 id="node核心模块"><a href="#node核心模块" class="headerlink" title="node核心模块"></a>node核心模块</h4><p>EventEmitter，Stream，FS，Net和全局对象</p><h4 id="node全局对象？"><a href="#node全局对象？" class="headerlink" title="node全局对象？"></a>node全局对象？</h4><p>process,console,Buffer,exports</p><h4 id="process有哪些常用方法？"><a href="#process有哪些常用方法？" class="headerlink" title="process有哪些常用方法？"></a>process有哪些常用方法？</h4><p>process.stdin, process.stdout, process,stderr, process.on, process.env, </p><h4 id="Stream有什么好处？"><a href="#Stream有什么好处？" class="headerlink" title="Stream有什么好处？"></a>Stream有什么好处？</h4><p>非阻塞式数据处理提升效率，片段处理节省内存，管道处理方便可扩展等。</p><h4 id="Stream有哪些典型应用？"><a href="#Stream有哪些典型应用？" class="headerlink" title="Stream有哪些典型应用？"></a>Stream有哪些典型应用？</h4><p>文件、网络、数据转换、音频视频等。</p><h4 id="nodejs中的Stream和Buffer区别？"><a href="#nodejs中的Stream和Buffer区别？" class="headerlink" title="nodejs中的Stream和Buffer区别？"></a>nodejs中的Stream和Buffer区别？</h4><p>Buffer：数据缓冲对象，是一个类似数组结构的对象，可以通过指定开始写入的位置及写入的数据长度，往其中写入二进制数据。<br>Stream：是对buffer对象的高级封装，其操作的底层还是buffer对象，stream可以设置为可读、可写，或可读可写，在nodejs中继承了EventEmitter接口，可以监听读入、写入的过程，具体实现有文件流等。</p><h4 id="fs-watch和fs-watchFile有什么区别？"><a href="#fs-watch和fs-watchFile有什么区别？" class="headerlink" title="fs.watch和fs.watchFile有什么区别？"></a>fs.watch和fs.watchFile有什么区别？</h4><p>fs.watch利用操作系统原生机制来监听，可能不适用网络文件系统<br>fs.watchFile则是定期检查文件状态变更，适用于网络文件系统，但是相比fs.watch有些慢，因为不适实时机制；</p><h4 id="node的网络模块架构是什么样子的？"><a href="#node的网络模块架构是什么样子的？" class="headerlink" title="node的网络模块架构是什么样子的？"></a>node的网络模块架构是什么样子的？</h4><p>node全面支持各种网络服务器和客户端，包括tcp, http/https, tcp, udp, dns, tls/ssl等。</p><h4 id="node是如何支持https-tls的？"><a href="#node是如何支持https-tls的？" class="headerlink" title="node是如何支持https, tls的？"></a>node是如何支持https, tls的？</h4><ul><li>openSSL生成公钥私钥；</li><li>服务器或客户端使用https替代http</li><li>服务器或客户端加载公钥私钥证书</li></ul><h4 id="为什么需要child-process"><a href="#为什么需要child-process" class="headerlink" title="为什么需要child-process?"></a>为什么需要child-process?</h4><p>node是异步非阻塞的，这对高并发非常有效，但有些其他的需求，比如操作系统shell命令交互，调用可执行文件，创建子进程进行阻塞式访问或高CPU计算等，child-process就是为满足这些需求而生的，child-process顾名思义，就是把node阻塞的工作交给子进程去做。</p><h4 id="exec-execFile-spawn-fork都是做什么的？"><a href="#exec-execFile-spawn-fork都是做什么的？" class="headerlink" title="exec, execFile, spawn, fork都是做什么的？"></a>exec, execFile, spawn, fork都是做什么的？</h4><p>exec可以用操作系统原生的方式执行各种命令，如管道cat ab.txt | grep hello<br>execFile是执行文件<br>spawn是流式和操作系统进行交互<br>fork是两个node程序(JavaScript)之间时行交互</p><h4 id="两个node程序之间怎样交互？"><a href="#两个node程序之间怎样交互？" class="headerlink" title="两个node程序之间怎样交互？"></a>两个node程序之间怎样交互？</h4><p>fork，原理是：子进程用process.on, process.send，父程序里用child.on, child.send进行交互。</p><h4 id="怎样充分利用多个CPU？"><a href="#怎样充分利用多个CPU？" class="headerlink" title="怎样充分利用多个CPU？"></a>怎样充分利用多个CPU？</h4><p>一个CPU运行一个node实例。</p><h4 id="有哪些常用方法可以防止程序崩溃？"><a href="#有哪些常用方法可以防止程序崩溃？" class="headerlink" title="有哪些常用方法可以防止程序崩溃？"></a>有哪些常用方法可以防止程序崩溃？</h4><ul><li>try-catch-finally</li><li>EventEmitters/Stream error事件处理</li><li>domain统一控制</li><li>jshint静态检查</li><li>mocha进行单元测试</li></ul><h4 id="调试node程序？"><a href="#调试node程序？" class="headerlink" title="调试node程序？"></a>调试node程序？</h4><p>node-inspector<br>node –debug app.js</p><h4 id="async常用的方法？"><a href="#async常用的方法？" class="headerlink" title="async常用的方法？"></a>async常用的方法？</h4><p>async是一个js类库，目的是解决js中异常流程难以控制问题，async不仅适用nodejs里，浏览器中也可以适用。</p><ul><li>async.parallel并行执行多个函数后，调用结束函数</li><li>async.series串行执行多个函数后，调用结束函数</li><li>async.waterfall依次执行多个函数，后一个函数以前面函数的结果作为输入参数</li><li>async.map异步执行多个数组，返回结果数组</li><li>async.filter异步过滤多个数组，返回结果数组</li></ul><h4 id="async-await内部机制"><a href="#async-await内部机制" class="headerlink" title="async await内部机制"></a>async await内部机制</h4><p>async函数就是generator函数的语法糖；<br>async函数是将generator函数的*换成async，将yield替换成await；<br>async是对generator的改进：</p><ul><li>内置执行器，不需要使用next()手动执行；</li><li>await命令后面可以是Promise对象或原始类型的值；</li><li>返回值是promise；</li></ul><p>作用：异步编程的终极解决方案。</p><p>执行顺序：<br>函数执行时，一旦遇到await就会返回。等到触发的异步操作完成，再接着执行函数体内后面的语句。</p><h4 id="promise内部实现机制"><a href="#promise内部实现机制" class="headerlink" title="promise内部实现机制"></a>promise内部实现机制</h4><p>Promise内部实现机制：<br>promise用来实现一步操作，解决了回调地域的问题。<br>相当于一个容器，里面保存了某些未来才结束的事件的结果。<br>promise对象的状态不受外部的影响。</p><p>babel或者coffee Script的这些编译到JS的语言是如何工作的？<br>关于babel的递归引用JS文件处理的东西<br>JavaScript的Async库基本原理是什么？<br>你写的Functional.js中monad, curry, lazy的解释和意义？<br>JS的东西，什么闭包，Node.js的require依赖顺序什么的<br>说一下关于Node.js的文件读写方式和实现<br>说一下JavaScript几种异步方法和原理？<br>说明addEventListener使用？作用域？<br>谈谈冒泡和捕获事件的区别，应用？</p><h4 id="什么是错误优先的回调函数？"><a href="#什么是错误优先的回调函数？" class="headerlink" title="什么是错误优先的回调函数？"></a>什么是错误优先的回调函数？</h4><p>错误优先的回调函数用于传递错误和数据。<br>第一个参数始终是一个错误对象，用于检查程序是否发生了错误<br>其余的参数用于传递数据</p><h4 id="如何避免回调地狱？"><a href="#如何避免回调地狱？" class="headerlink" title="如何避免回调地狱？"></a>如何避免回调地狱？</h4><h4 id="简述同步和异步的区别，如何避免回调地狱"><a href="#简述同步和异步的区别，如何避免回调地狱" class="headerlink" title="简述同步和异步的区别，如何避免回调地狱"></a>简述同步和异步的区别，如何避免回调地狱</h4><p>同步方法调用一旦开始，调用者必须等到方法调用返回之后，才能继续后续的行为；<br>异步方法调用一旦开始，方法调用就会立即返回，调用者就会继续后续的操作，而异步方法通常会在另外一个线程中，整个过程，不会阻碍调用者的工作。<br>避免回调地狱：</p><ul><li>Promsie</li><li>async/await</li><li>generator</li><li>事件发布/监听模式</li></ul><p>如何用Node来监听80端口？</p><h4 id="堆、栈和队列"><a href="#堆、栈和队列" class="headerlink" title="堆、栈和队列"></a>堆、栈和队列</h4><p>堆heap：堆是存放对象的一个空间（Object，function）；<br>队列loop：是指存放所有异步请求操作的结果，直到有一个异步操作完成它的使命，<br>        就会在loop中添加一个事件，队列是先进先出的；<br>栈stack：栈本身是存储基础的变量。<br>        栈里面的存放的引用变量是指向堆里面的引用对象的地址，只是一串地址。<br>        这里栈代表的是执行栈，我们js的主线程。<br>        栈是先进后出的。</p><h4 id="什么是事件循环eventloop"><a href="#什么是事件循环eventloop" class="headerlink" title="什么是事件循环eventloop"></a>什么是事件循环eventloop</h4><ul><li>所有同步任务都是在主线程上执行，形成一个执行栈；</li><li>当主线程中的执行栈为空时，检查事件队列是否为空，如果为空，则继续检查；否则，则执行3</li><li>取出任务队列的首部，加入执行栈</li><li>执行任务</li><li>检查执行栈，如果执行栈为空，调回第2步；否则继续检查<br>node中的event loop是在libuv里面的，libuv里面有个事件环机制，他会在启动node时，初始化事件环。<br>Eventloop永远不会断。</li></ul><h4 id="微任务、宏任务"><a href="#微任务、宏任务" class="headerlink" title="微任务、宏任务"></a>微任务、宏任务</h4><p>宏任务macro-task：setTimeout、setImmediate、MessageChannnel<br>微任务micro-task：原生的Promise，Object.reserve(已废弃)、MutationObserve<br>微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别是它们的执行顺序，Eventloop的走向和取值。</p><h4 id="哪些工具可以用来保证一致的编程风格？"><a href="#哪些工具可以用来保证一致的编程风格？" class="headerlink" title="哪些工具可以用来保证一致的编程风格？"></a>哪些工具可以用来保证一致的编程风格？</h4><ul><li>ESLint</li></ul><h4 id="运算错误与程序员错误的区别？"><a href="#运算错误与程序员错误的区别？" class="headerlink" title="运算错误与程序员错误的区别？"></a>运算错误与程序员错误的区别？</h4><p>运算错误并不是bug，这是和程序相关的问题，例如请求超时或硬件故障；<br>程序错误就是所谓的bug</p><h4 id="使用NPM有哪些好处？"><a href="#使用NPM有哪些好处？" class="headerlink" title="使用NPM有哪些好处？"></a>使用NPM有哪些好处？</h4><p>通过NPM，可以安装和管理项目的依赖，并且能够指明依赖项的具体版本号，可以通过package.json文件来管理项目信息，配置脚本。</p><h4 id="什么是stub？举个使用场景？"><a href="#什么是stub？举个使用场景？" class="headerlink" title="什么是stub？举个使用场景？"></a>什么是stub？举个使用场景？</h4><p>Stub是用于模拟一个组件或模块的函数或程序。<br>在测试用例中，简单来说，你可以用Stub去模拟一个方法，从而避免调用真实的方法，使用Stub你可以返回虚构的结果。</p><h4 id="什么是测试金字塔？对于HTTP-API，如何利用测试金字塔？"><a href="#什么是测试金字塔？对于HTTP-API，如何利用测试金字塔？" class="headerlink" title="什么是测试金字塔？对于HTTP API，如何利用测试金字塔？"></a>什么是测试金字塔？对于HTTP API，如何利用测试金字塔？</h4><p>是当我们在编写测试用例时，底层的单元测试应该比上层的端到端的测试要多。</p><h4 id="module-exports与exports的区别？"><a href="#module-exports与exports的区别？" class="headerlink" title="module.exports与exports的区别？"></a>module.exports与exports的区别？</h4><p>exports是一个引用，直接赋值给它，只是让这个变量等于另外一个引用<br>只有通过module.exports才能真正修改到exports本身</p><h4 id="介绍一下Session和Cookie？服务端如何清除cookie？"><a href="#介绍一下Session和Cookie？服务端如何清除cookie？" class="headerlink" title="介绍一下Session和Cookie？服务端如何清除cookie？"></a>介绍一下Session和Cookie？服务端如何清除cookie？</h4><p>主要区别在于session存在服务端，cookie存在客户端，session比cookie更安全。<br>且cookie不一定能能一直用(可能被浏览器关掉)，<br>服务端可以通过设置cookie的值为空并设置一个及时的expires来清除存在客户端上的cookie。</p><p>session：<br>    用户第一次通过浏览器使用用户名和密码访问服务器时，服务器会验证用户数据，成功后悔在服务器端写入session数据，向客户端浏览器返回sessionid，浏览器将sessionid保存在cookie中，当用户再次访问服务器时，会携带sessionid，服务器会拿着sessionid从数据库获取session数据，然后进行用户信息查询，查询到，将信息返回，从而保持状态。</p><p>session弊端<br>1、服务器压力增大</p><pre><code>通常session是存储在内存中的，当用户量增大时，服务器的压力增大。</code></pre><p>2、CSRF跨站伪造请求攻击<br>    session是基于cookie进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p><p>3、扩展性不强<br>    如果搭建多台服务器，session数据保存在内存中，不能共享，用户访问服务器1，当用户再次请求访问的可能是服务器2，服务器2获取不到session信息，就判断用户没有登录过。</p><p>token<br>token与session不同在于认证成功后，会对当前用户数据进行加密，生成一个加密字符串token，返回客户端，服务器不进行保存。<br>浏览器接收到token的值存储在local storage中<br>再次访问服务器对token值进行解密，解密后进行数据查询，成功则通过认证，实现登录状态保持，即使有多台服务器，服务器也只是做了token的解密和数据的查询，不需要在服务端去保留用户的认证信息或会话信息，为扩展提供了便利，解决了session扩展性的弊端。</p><p>你最喜欢的HTTP框架，并说明原因？</p><h4 id="JS和NodeJs区别？"><a href="#JS和NodeJs区别？" class="headerlink" title="JS和NodeJs区别？"></a>JS和NodeJs区别？</h4><p>JS运行在浏览器端，用于用户的交互效果；<br>Nodejs运行在服务端，用于服务器的操作；</p><p>JS运行在浏览器端，存在多个JS解释器，存在兼容性的问题；<br>Nodejs只有V8引擎一种解释器，不存在兼容问题；</p><p>两者都有内置对象、自定义对象，有不同的宿主对象；</p><p>【<br>JavaScript内置对象：<br>    Array Boolean Date Function Global Math Number Object RegExp String及各种错误类对象。</p><p>JavaScript宿主对象：<br>    宿主对象就是执行Js脚本的环境提供的对象，对于嵌入到网页中的Js来说，宿主对象就是浏览器提供的对象，即浏览器对象。<br>如：Window和Document，Element，form，image等。</p><p>JavaScript自定义对象：即开发人员自己定义的对象。<br> 】</p><ol start="3"><li>谈谈对nodejs npm webpack的理解<br>webpack能够把vue后缀名的文件打包成浏览器能够识别的js，而这个vue文件装换需要打包器vue-loader;<br>vue-loader打包器是可以从npm上下载的，npm下载文件之后，webpack打包文件时需要在node环境去运行；</li></ol><ol start="5"><li><p>AMD CMD规范的区别<br>CommonJS和AMD都是JavaScript模块化的规范<br>CMD依赖就近，AMD依赖前置<br>CMD是延迟执行的，AMD是提前执行的<br>AMD的API默认是一个当多个用，CMD的API严格区分，推崇职责单一</p></li><li><p>如何判断当前脚本运行在浏览器还是在node环境中<br>通过判断Global对象是否为Window，如果不是，当前脚本没有在浏览器中。</p></li></ol><ol start="10"><li>app.use和app.get的区别<br>app.use(path, callback)中的callback既可以是router对象又可以是函数。<br>app.get(path, callback)中的callback只能是函数。</li></ol><ol start="12"><li>node如何与MongoDB建立连接</li></ol><ul><li>引入mongoose</li><li>使用mongoose.connect()方法连接到MongoDB数据库</li><li>监听连接是否成功</li><li>通过node， 书写接口，对数据库进行增删改查</li></ul><ol start="13"><li>node和前端项目怎么解决跨域的？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;解决跨域问题</span><br><span class="line">        app.use(async(ctx, next) &#x3D;#### &#123;</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;指定服务器端允许进行跨域资源访问的来源域。可以用通配符*表示允许任何域的JavaScript访问资源，但是在响应一个携带身份信息(Credential)的HTTP请求时，必需指定具体的域，不能用通配符</span><br><span class="line">            ctx.set(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;可选。它的值是一个布尔值，表示是否允许客户端跨域请求时携带身份信息(Cookie或者HTTP认证信息)。默认情况下，Cookie不包括在CORS请求之中。当设置成允许请求携带cookie时，需要保证&quot;Access-Control-Allow-Origin&quot;是服务器有的域名，而不能是&quot;*&quot;;如果没有设置这个值，浏览器会忽略此次响应。</span><br><span class="line">            ctx.set(&quot;Access-Control-Allow-Credentials&quot;, true);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上</span><br><span class="line">            ctx.set(&quot;Access-Control-Allow-Methods&quot;, &quot;OPTIONS, GET, PUT, POST, DELETE&quot;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;必需。指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上</span><br><span class="line">            ctx.set(&quot;Access-Control-Allow-Headers&quot;, &quot;x-requested-with, accept, origin, content-type&quot;);</span><br><span class="line">            &#x2F;&#x2F; ctx.set(&quot;X-Powered-By&quot;, &#39; 3.2.1&#39;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;告诉客户端返回数据的MIME的类型，这只是一个标识信息,并不是真正的数据文件的一部分</span><br><span class="line">            ctx.set(&quot;Content-Type&quot;, &quot;application&#x2F;json;charset&#x3D;utf-8&quot;);</span><br><span class="line">            </span><br><span class="line">            &#x2F;&#x2F;如果不设置mode，直接设置content-type为application&#x2F;json，则fetch会默认这是跨域模式（mode:&#39;cors&#39;），在跨域POST之前，客户端会先发一条OPTIONS请求来”探探路”，如果服务器允许，再继续POST数据。对于这种OPTIONS请求，需要在服务器配置允许接受OPTIONS请求，这样写就是直接允许了所有的OPTIONS请求，也可以按照需求来判断OPTIONS请求中更详细的信息</span><br><span class="line">            if (ctx.request.method &#x3D;&#x3D; &quot;OPTIONS&quot;) &#123;</span><br><span class="line">                ctx.response.status &#x3D; 200</span><br><span class="line">            &#125;</span><br><span class="line">            await next();</span><br><span class="line">        &#125;);</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;一、node&lt;/p&gt;
&lt;h4 id=&quot;node？&quot;&gt;&lt;a href=&quot;#node？&quot; class=&quot;headerlink&quot; title=&quot;node？&quot;&gt;&lt;/a&gt;node？&lt;/h4&gt;&lt;p&gt;node既是开发平台，也是运行环境，也是新的语言。
      
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>interview</title>
    <link href="http://gpp-note.top/articles/2020-02-08-interview.html"/>
    <id>http://gpp-note.top/articles/2020-02-08-interview.html</id>
    <published>2020-02-08T11:20:20.000Z</published>
    <updated>2020-02-10T08:52:07.345Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>Node： <a href="https://www.gpp-note.top/articles/2020-02-08-interview-node.html" target="_blank">[Node]</a> </p><p>Koa/Express：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-koaExpress.html" target="_blank">[Koa/Express]</a> </p><p>Vue：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-vue.html" target="_blank">[Vue]</a> </p><p>CSS：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-cssHtml.html" target="_blank">[Css]</a> </p><p>Html：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-cssHtml.html" target="_blank">[Html]</a> </p><p>JavaScript：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-javaScript.html" target="_blank">[JavaScript]</a> </p><p>Database：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-database.html" target="_blank">[Database]</a> </p><p>Algorithm：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-algorithm.html" target="_blank">[Algorithm]</a> </p><p>Http/Net：<a href="https://www.gpp-note.top/articles/2020-02-08-interview-httpNet.html" target="_blank">[Http/Net]</a> </p>]]></content>
    
    <summary type="html">
    
      Welcome to my-blog!!!
    
    </summary>
    
    
      <category term="Interview" scheme="http://gpp-note.top/categories/Interview/"/>
    
    
      <category term="Interview" scheme="http://gpp-note.top/tags/Interview/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之zlib</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-zlib.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-zlib.html</id>
    <published>2020-02-07T10:19:32.000Z</published>
    <updated>2020-02-08T09:36:55.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>压缩。<br>zlib模块提供通过Gzip</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;zlib&quot;&gt;&lt;a href=&quot;#zlib&quot; class=&quot;headerlink&quot; title=&quot;zlib&quot;&gt;&lt;/a&gt;zlib&lt;/h2&gt;&lt;p&gt;压缩。&lt;br&gt;zlib模块提供通过Gzip&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之worker_threads</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-worker-threads.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-worker-threads.html</id>
    <published>2020-02-07T10:18:58.000Z</published>
    <updated>2020-02-08T03:10:05.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="worker-threads"><a href="#worker-threads" class="headerlink" title="worker_threads"></a>worker_threads</h2><p>工作线程。<br>worker_threads模块允许使用并行的执行JavaScript的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const worker &#x3D; require(&#39;worker_threads&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>工作线程对于执行CPU密集型的JavaScript操作非常有用。<br>它们在I/O密集型的工作中用途不大。<br>Nodejs的内置的异步I/O操作比工作线程效率更高。</p><p>与child_process或cluster不同，worker_threads可以共享内存，它们通过传输ArrayBuffer实例或共享SharedArrayBuffer实例来实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  Worker, isMainThread, parentPort, workerData</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  module.exports &#x3D; function parseJSAsync(script) &#123;</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      const worker &#x3D; new Worker(__filename, &#123;</span><br><span class="line">        workerData: script</span><br><span class="line">      &#125;);</span><br><span class="line">      worker.on(&#39;message&#39;, resolve);</span><br><span class="line">      worker.on(&#39;error&#39;, reject);</span><br><span class="line">      worker.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">        if (code !&#x3D;&#x3D; 0)</span><br><span class="line">          reject(new Error(&#96;工作线程使用退出码 $&#123;code&#125; 停止&#96;));</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  const &#123; parse &#125; &#x3D; require(&#39;一些 js 解析库&#39;);</span><br><span class="line">  const script &#x3D; workerData;</span><br><span class="line">  parentPort.postMessage(parse(script));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例为每个parse()调用衍生一个工作进程。在实际的实践中，应使用工作线程池代替这些任务。<br>否则，创建工作线程的开销可能会超出其收益。</p><p>当实现工作线程池时，可使用AsyncResource API来通知诊断的工具有关任务极其结果之间的相关性。</p><h4 id="worker-isMainThread"><a href="#worker-isMainThread" class="headerlink" title="worker.isMainThread"></a>worker.isMainThread</h4><p>如果代码不在Worker线程内运行，则为True。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread &#125; &#x3D; require(&#39;worker_threads)</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">    &#x2F;&#x2F; 这会在工作线程实例中重新加载当前文件。</span><br><span class="line">    new Worker(__filename)</span><br><span class="line">&#125;else &#123;</span><br><span class="line">    console.log(&#39;在工作线程中&#39;)</span><br><span class="line">    console.log(isMainThread)  &#x2F;&#x2F; 打印false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="worker-moveMessagePortToContext-port-contextifiedSandbox"><a href="#worker-moveMessagePortToContext-port-contextifiedSandbox" class="headerlink" title="worker.moveMessagePortToContext(port, contextifiedSandbox)"></a>worker.moveMessagePortToContext(port, contextifiedSandbox)</h4><h4 id="worker-parentPort"><a href="#worker-parentPort" class="headerlink" title="worker.parentPort"></a>worker.parentPort</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, parentPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  worker.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(message);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">  &#125;);</span><br><span class="line">  worker.postMessage(&#39;Hello, world!&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; When a message from the parent thread is received, send it back:</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    parentPort.postMessage(message);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="worker-receiveMessageOnPort-port"><a href="#worker-receiveMessageOnPort-port" class="headerlink" title="worker.receiveMessageOnPort(port)"></a>worker.receiveMessageOnPort(port)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel, receiveMessageOnPort &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.postMessage(&#123; hello: &#39;world&#39; &#125;);</span><br><span class="line"></span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; message: &#123; hello: &#39;world&#39; &#125; &#125;</span><br><span class="line">console.log(receiveMessageOnPort(port2));</span><br><span class="line">&#x2F;&#x2F; Prints: undefined</span><br></pre></td></tr></table></figure><h4 id="worker-SHARE-ENV"><a href="#worker-SHARE-ENV" class="headerlink" title="worker.SHARE_ENV"></a>worker.SHARE_ENV</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, SHARE_ENV &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">new Worker(&#39;process.env.SET_IN_WORKER &#x3D; &quot;foo&quot;&#39;, &#123; eval: true, env: SHARE_ENV &#125;)</span><br><span class="line">  .on(&#39;exit&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(process.env.SET_IN_WORKER);  &#x2F;&#x2F; Prints &#39;foo&#39;.</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h4 id="worker-workerData"><a href="#worker-workerData" class="headerlink" title="worker.workerData"></a>worker.workerData</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const &#123; Worker, isMainThread, workerData &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename, &#123; workerData: &#39;Hello, world!&#39; &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(workerData);  &#x2F;&#x2F; Prints &#39;Hello, world!&#39;.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MessageChannel类"><a href="#MessageChannel类" class="headerlink" title="MessageChannel类"></a>MessageChannel类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(&#39;received&#39;, message));</span><br><span class="line">port2.postMessage(&#123; foo: &#39;bar&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; Prints: received &#123; foo: &#39;bar&#39; &#125; from the &#96;port1.on(&#39;message&#39;)&#96; listener</span><br></pre></td></tr></table></figure><h4 id="MessagePort类"><a href="#MessagePort类" class="headerlink" title="MessagePort类"></a>MessagePort类</h4><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints:</span><br><span class="line">&#x2F;&#x2F;   foobar</span><br><span class="line">&#x2F;&#x2F;   closed!</span><br><span class="line">port2.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line">port2.on(&#39;close&#39;, () &#x3D;&gt; console.log(&#39;closed!&#39;));</span><br><span class="line"></span><br><span class="line">port1.postMessage(&#39;foobar&#39;);</span><br><span class="line">port1.close();</span><br></pre></td></tr></table></figure><h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><h5 id="port-close"><a href="#port-close" class="headerlink" title="port.close()"></a>port.close()</h5><h5 id="port-postMessage-value-transferList"><a href="#port-postMessage-value-transferList" class="headerlink" title="port.postMessage(value[, transferList])"></a>port.postMessage(value[, transferList])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const &#123; MessageChannel &#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">const &#123; port1, port2 &#125; &#x3D; new MessageChannel();</span><br><span class="line"></span><br><span class="line">port1.on(&#39;message&#39;, (message) &#x3D;&gt; console.log(message));</span><br><span class="line"></span><br><span class="line">const circularData &#x3D; &#123;&#125;;</span><br><span class="line">circularData.foo &#x3D; circularData;</span><br><span class="line">&#x2F;&#x2F; Prints: &#123; foo: [Circular] &#125;</span><br><span class="line">port2.postMessage(circularData);</span><br></pre></td></tr></table></figure><h5 id="port-ref"><a href="#port-ref" class="headerlink" title="port.ref()"></a>port.ref()</h5><h5 id="port-start"><a href="#port-start" class="headerlink" title="port.start()"></a>port.start()</h5><h5 id="port-unref"><a href="#port-unref" class="headerlink" title="port.unref()"></a>port.unref()</h5><h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>Worker类代表一个独立的JavaScript执行线程。大多数Nodejs API都在其中可用。</p><p>可以在其它Worker实例中创建Worker实例。</p><p>与Web工作线程和cluster模块一样，可以通过线程间的消息传递来实现双向通信。<br>在内部，一个Worker具有一对内置的MessagePort，在创建该Worker时他们已经相互关联。<br>虽然父端的MessagePort对象没有直接公开，但其功能是通过父线程的Worker对象上的worker.postMessage()和worker.on(‘message’)事件公开的。</p><p>要创建自定义的消息传递通道，用户可以在任一线程上创建一个MessageChannel对象，并将该Messagechannel上的MessagePort中的一个通过预先存在的通道传给另一个线程，例如全局通道。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const assert &#x3D; require(&#39;assert&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker, MessageChannel, MessagePort, isMainThread, parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line">  const subChannel &#x3D; new MessageChannel();</span><br><span class="line">  worker.postMessage(&#123; hereIsYourPort: subChannel.port1 &#125;, [subChannel.port1]);</span><br><span class="line">  subChannel.port2.on(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;接收到:&#39;, value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (value) &#x3D;&gt; &#123;</span><br><span class="line">    assert(value.hereIsYourPort instanceof MessagePort);</span><br><span class="line">    value.hereIsYourPort.postMessage(&#39;工作线程正在发送此消息&#39;);</span><br><span class="line">    value.hereIsYourPort.close();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="new-Worker-filename-options"><a href="#new-Worker-filename-options" class="headerlink" title="new Worker(filename[, options])"></a>new Worker(filename[, options])</h5><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><h5 id="message事件-1"><a href="#message事件-1" class="headerlink" title="message事件"></a>message事件</h5><h5 id="online事件"><a href="#online事件" class="headerlink" title="online事件"></a>online事件</h5><h5 id="worker-postMessage-value-transferList"><a href="#worker-postMessage-value-transferList" class="headerlink" title="worker.postMessage(value[, transferList])"></a>worker.postMessage(value[, transferList])</h5><h5 id="worker-ref"><a href="#worker-ref" class="headerlink" title="worker.ref()"></a>worker.ref()</h5><h5 id="worker-stderr"><a href="#worker-stderr" class="headerlink" title="worker.stderr"></a>worker.stderr</h5><h5 id="worker-stdin"><a href="#worker-stdin" class="headerlink" title="worker.stdin"></a>worker.stdin</h5><h5 id="worker-stdout"><a href="#worker-stdout" class="headerlink" title="worker.stdout"></a>worker.stdout</h5><h5 id="worker-terminate"><a href="#worker-terminate" class="headerlink" title="worker.terminate()"></a>worker.terminate()</h5><h5 id="worker-threadld"><a href="#worker-threadld" class="headerlink" title="worker.threadld"></a>worker.threadld</h5><h5 id="worker-unref"><a href="#worker-unref" class="headerlink" title="worker.unref()"></a>worker.unref()</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;worker-threads&quot;&gt;&lt;a href=&quot;#worker-threads&quot; class=&quot;headerlink&quot; title=&quot;worker_threads&quot;&gt;&lt;/a&gt;worker_threads&lt;/h2&gt;&lt;p&gt;工作线程。&lt;br&gt;worker_threads模块允许使用并行的执行JavaScript的线程&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const worker &amp;#x3D; require(&amp;#39;worker_threads&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之vm</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-vm.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-vm.html</id>
    <published>2020-02-07T10:18:21.000Z</published>
    <updated>2020-02-07T15:01:39.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>虚拟机。</p><p>vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。<br>vm模块不是一个安全的虚拟机。<br>不要用它来运行不受信任的代码。</p><p>JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。</p><p>一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。</p><p>可以通过上下文隔离化一个沙箱对象来提供上下文。<br>沙盒代码将沙盒中的任何属性视为全局对象。<br>由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; x: 2 &#125;;</span><br><span class="line">vm.createContext(sandbox); &#x2F;&#x2F; 上下文隔离化一个沙盒。</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#39;x +&#x3D; 40; var y &#x3D; 17;&#39;;</span><br><span class="line">&#x2F;&#x2F; &#96;x&#96; and &#96;y&#96; 是沙盒环境中的全局变量。</span><br><span class="line">&#x2F;&#x2F; 最初，x 的值为 2，因为这是 sandbox.x 的值。</span><br><span class="line">vm.runInContext(code, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(sandbox.x); &#x2F;&#x2F; 42</span><br><span class="line">console.log(sandbox.y); &#x2F;&#x2F; 17</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; 1; y 没有定义。</span><br></pre></td></tr></table></figure><h4 id="vm-Script类"><a href="#vm-Script类" class="headerlink" title="vm.Script类"></a>vm.Script类</h4><p>vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或上下文）中被运行。</p><h5 id="new-vm-Script-code-options"><a href="#new-vm-Script-code-options" class="headerlink" title="new vm.Script(code[, options])"></a>new vm.Script(code[, options])</h5><p>如果options是字符串，则它指定文件名。</p><p>创建一个新的vm.Script对象只编译code但不会执行它。<br>编译过的vm.Script此后可以被多次执行。<br>code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。</p><h5 id="script-createCachedData"><a href="#script-createCachedData" class="headerlink" title="script.createCachedData()"></a>script.createCachedData()</h5><p>创建一个可以被Script构造函数中cachedData选项使用的代码缓存，返回Buffer。<br>可以在任何时候不限次数的调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const script &#x3D; new vm.Script(&#96;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x &#x3D; add(1, 2);</span><br><span class="line">&#96;);</span><br><span class="line"></span><br><span class="line">const cacheWithoutX &#x3D; script.createCachedData();</span><br><span class="line"></span><br><span class="line">script.runInThisContext();</span><br><span class="line"></span><br><span class="line">const cacheWithX &#x3D; script.createCachedData();</span><br></pre></td></tr></table></figure><h5 id="script-runInContext-contextifiedSandbox-options"><a href="#script-runInContext-contextifiedSandbox-options" class="headerlink" title="script.runInContext(contextifiedSandbox[, options])"></a>script.runInContext(contextifiedSandbox[, options])</h5><p>在指定的contextifiedSandbox中执行vm.Script对象中被编译后的代码并返回结果。<br>被执行的代码无法获取本地作用域。</p><h5 id="script-runInNewContext-sandbox-options"><a href="#script-runInNewContext-sandbox-options" class="headerlink" title="script.runInNewContext([sandbox[, options]])"></a>script.runInNewContext([sandbox[, options]])</h5><p>首先给指定的sandbox提供一个隔离的上下文，再在此上下文执行vm.Script中被编译的代码，最后返回结果。运行中的代码无法获取本地作用域。</p><h5 id="script-runInThisContext-options"><a href="#script-runInThisContext-options" class="headerlink" title="script.runInThisContext([options])"></a>script.runInThisContext([options])</h5><p>在指定的global对象的上下文中执行vm.Script对象里被编译的代码并返回结果。被执行的代码无法获取本地作用域，但能获取global对象。</p><h4 id="vm-SourceTextModule类"><a href="#vm-SourceTextModule类" class="headerlink" title="vm.SourceTextModule类"></a>vm.SourceTextModule类</h4><h5 id="new-vm-SourceTextModule-code-options"><a href="#new-vm-SourceTextModule-code-options" class="headerlink" title="new vm.SourceTextModule(code[, options])"></a>new vm.SourceTextModule(code[, options])</h5><h5 id="module-dependencySpecifiers"><a href="#module-dependencySpecifiers" class="headerlink" title="module.dependencySpecifiers"></a>module.dependencySpecifiers</h5><h5 id="module-error"><a href="#module-error" class="headerlink" title="module.error"></a>module.error</h5><h5 id="module-evaluate-options"><a href="#module-evaluate-options" class="headerlink" title="module.evaluate([options])"></a>module.evaluate([options])</h5><h5 id="module-link-linker"><a href="#module-link-linker" class="headerlink" title="module.link(linker)"></a>module.link(linker)</h5><h5 id="module-namespace"><a href="#module-namespace" class="headerlink" title="module.namespace"></a>module.namespace</h5><h5 id="module-status"><a href="#module-status" class="headerlink" title="module.status"></a>module.status</h5><h5 id="module-identifier"><a href="#module-identifier" class="headerlink" title="module.identifier"></a>module.identifier</h5><h4 id="vm-compileFunction-code-params-options"><a href="#vm-compileFunction-code-params-options" class="headerlink" title="vm.compileFunction(code[, params[, options]])"></a>vm.compileFunction(code[, params[, options]])</h4><p>将给定的代码编译到提供的上下文/沙箱中（如果没有提供上下文，则使用当前上下文），并返回包装了给定params的函数。</p><h4 id="vm-createContext-sandbox-options"><a href="#vm-createContext-sandbox-options" class="headerlink" title="vm.createContext([sandbox[, options]])"></a>vm.createContext([sandbox[, options]])</h4><p>给定一个sandbox对象，vm.createContext()会设置此沙盒，从而让它具备在vm.runInContext()或者script.runInContext()中被使用的能力。对于此二方法中所调用的脚本，他们的全局对象不仅拥有我们提供的sandbox对象的所有属性，同时还有任何全局对象所拥有的属性。对于这些脚本之外的所有代码，他们的全局变量将保持不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">global.globalVar &#x3D; 3;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(sandbox)); &#x2F;&#x2F; &#123; globalVar: 2 &#125;</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(globalVar)); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>如果未提供sanbox或传入undefined，那么会返回一个全新的空的上下文隔离化后的sandbox对象。</p><p>vm.createContext()主要是用于创建一个能运行的多个脚本的沙盒。</p><h4 id="vm-isContext-sandbox"><a href="#vm-isContext-sandbox" class="headerlink" title="vm.isContext(sandbox)"></a>vm.isContext(sandbox)</h4><p>当给定的sanbox对象已经被vm.createContext()上下文隔离化，则返回true。</p><h4 id="vm-runInContext-code-contextifiedSandbox-options"><a href="#vm-runInContext-code-contextifiedSandbox-options" class="headerlink" title="vm.runInContext(code, contextifiedSandbox[, options])"></a>vm.runInContext(code, contextifiedSandbox[, options])</h4><p>vm.runInContext()方法会编译code，然后在指定的contextifiedSandbox的上下文里执行它并返回其结果。被执行的代码无法获取本地作用域。contextifiedSandbox必须是事先被vm.createContext()方法上下文隔离化过得对象。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line">&#125;</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; globalVar: 1024 &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInNewContext-code-sanbox-options"><a href="#vm-runInNewContext-code-sanbox-options" class="headerlink" title="vm.runInNewContext(code[, sanbox[, options]])"></a>vm.runInNewContext(code[, sanbox[, options]])</h4><p>vm.runInNewContext()首先给指定的sanbox（若为undefined，则会新建一个sandbox）提供一个隔离的上下文，再在此上下文中执行编译的code，最后返回结果。<br>运行中的代码无法获取本地作用域。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123;</span><br><span class="line">  animal: &#39;cat&#39;,</span><br><span class="line">  count: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.runInNewContext(&#39;count +&#x3D; 1; name &#x3D; &quot;kitty&quot;&#39;, sandbox);</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInThisContext-code-options"><a href="#vm-runInThisContext-code-options" class="headerlink" title="vm.runInThisContext(code[, options])"></a>vm.runInThisContext(code[, options])</h4><p>vm.runInThisContext()在当前的global对象的上下文中编译并执行code，最后返回结果。<br>运行中的代码无法获取本地作用域，但可以获取当前的global对象。</p><p>如果options是字符串，则它指定文件名。</p><h4 id="示例：在VM中运行HTTP-Server"><a href="#示例：在VM中运行HTTP-Server" class="headerlink" title="示例：在VM中运行HTTP Server"></a>示例：在VM中运行HTTP Server</h4><p>在私用script.runInThisContext()或者vm.runInThisContext()时，目标代码是在当前的V8quanju对象的上下文中执行的。被传入此虚拟机上下文的目标代码会有自己独立的作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#96;</span><br><span class="line">((require) &#x3D;&gt; &#123;</span><br><span class="line">  const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">  http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">    response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; &#125;);</span><br><span class="line">    response.end(&#39;你好世界\\n&#39;);</span><br><span class="line">  &#125;).listen(8124);</span><br><span class="line"></span><br><span class="line">  console.log(&#39;服务器运行在 http:&#x2F;&#x2F;127.0.0.1:8124&#x2F;&#39;);</span><br><span class="line">&#125;)&#96;;</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(code)(require);</span><br></pre></td></tr></table></figure><h4 id="上下文隔离化一个对象意味着什么？"><a href="#上下文隔离化一个对象意味着什么？" class="headerlink" title="上下文隔离化一个对象意味着什么？"></a>上下文隔离化一个对象意味着什么？</h4><p>所有用Nodejs所运行的JavaScript代码都是在一个上下文的作用域中被执行的。根据V8嵌入式指南：</p><blockquote><p>在V8中，一个上下文是一个执行环境，它允许分离的，无关的JavaScript应用在一个V8的单例中被运行。<br>必须明确的指定用于运行所有JavaScript代码的上下文。</p></blockquote><p>当调用vm.createContext()时，传入的sanbox对象在底层会和一个新的V8上下文实例联系上。<br>这个V8上下文在一个隔离的全局环境中，使用vm模块的方法运行code。<br>创建V8上下文和使之联系上sanbox的过程在此文档中被称作为“上下文隔离化”sandbox。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vm&quot;&gt;&lt;a href=&quot;#vm&quot; class=&quot;headerlink&quot; title=&quot;vm&quot;&gt;&lt;/a&gt;vm&lt;/h2&gt;&lt;p&gt;虚拟机。&lt;/p&gt;
&lt;p&gt;vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。&lt;br&gt;vm模块不是一个安全的虚拟机。&lt;br&gt;不要用它来运行不受信任的代码。&lt;/p&gt;
&lt;p&gt;JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。&lt;/p&gt;
&lt;p&gt;一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。&lt;/p&gt;
&lt;p&gt;可以通过上下文隔离化一个沙箱对象来提供上下文。&lt;br&gt;沙盒代码将沙盒中的任何属性视为全局对象。&lt;br&gt;由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之V8</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-V8.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-V8.html</id>
    <published>2020-02-07T10:17:54.000Z</published>
    <updated>2020-02-07T14:15:54.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>V8引擎。</p><p>v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const v8 &#x3D; require(&#39;v8&#39;)</span><br></pre></td></tr></table></figure><p>API和实现随时可能发生变化。</p><a id="more"></a><h4 id="v8-cachedDataVersionTag"><a href="#v8-cachedDataVersionTag" class="headerlink" title="v8.cachedDataVersionTag()"></a>v8.cachedDataVersionTag()</h4><p>返回一个整数，表示从V8版本、命令行标志、以及检测到的CPU特性派生的版本标记。<br>这对于判断vm.Script的cachedData buffer是否与此V8实例兼容非常有用。</p><h4 id="v8-getHeapSpaceStatistics"><a href="#v8-getHeapSpaceStatistics" class="headerlink" title="v8.getHeapSpaceStatistics()"></a>v8.getHeapSpaceStatistics()</h4><p>返回有关的V8堆空间的统计信息，即组成V8堆的片段。<br>由于统计信息是通过V8的GetHeapSpaceStatistics函数提供的，因此可以保证堆空间的排序以及堆控件的可用性，并且可以从一个V8版本更改为下一个版本。</p><h4 id="v8-getHeapSnapshot"><a href="#v8-getHeapSnapshot" class="headerlink" title="v8.getHeapSnapshot()"></a>v8.getHeapSnapshot()</h4><p>生成当前V8堆的快照，并返回可读流，该可读流用于读取JSON序列化表示。<br>此JSON流格式旨在与Chrome DevTools等工具一起使用。<br>JSON模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const stream &#x3D; v8.getHeapSnapshot();</span><br><span class="line">stream.pipe(process.stdout);</span><br></pre></td></tr></table></figure><h4 id="v8-getHeapStatistics"><a href="#v8-getHeapStatistics" class="headerlink" title="v8.getHeapStatistics()"></a>v8.getHeapStatistics()</h4><h4 id="v8-getHeapCodeStatistics"><a href="#v8-getHeapCodeStatistics" class="headerlink" title="v8.getHeapCodeStatistics()"></a>v8.getHeapCodeStatistics()</h4><p>返回一下属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code_and_metadata_size: 212208,</span><br><span class="line">  bytecode_and_metadata_size: 161368,</span><br><span class="line">  external_script_source_size: 1410794</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v8-setFlagsFromString-flags"><a href="#v8-setFlagsFromString-flags" class="headerlink" title="v8.setFlagsFromString(flags)"></a>v8.setFlagsFromString(flags)</h4><p>该方法可以用于以编程方式设置V8de命令行标志。<br>虚拟机启动后更改设置可能会导致不可预测的行为，包括崩溃和数据丢失，或者它可能根本就什么都不做。</p><p>可以通过运行node –v8-options来检查可用于nodejs版本的V8选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 GC 事件打印到 stdout 一分钟。</span><br><span class="line">const v8 &#x3D; require(&#39;v8&#39;);</span><br><span class="line">v8.setFlagsFromString(&#39;--trace_gc&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; v8.setFlagsFromString(&#39;--notrace_gc&#39;); &#125;, 60e3);</span><br></pre></td></tr></table></figure><h4 id="v8-writeHeapSnapshot-filename"><a href="#v8-writeHeapSnapshot-filename" class="headerlink" title="v8.writeHeapSnapshot([filename])"></a>v8.writeHeapSnapshot([filename])</h4><p>生成当前v8堆的快照并将其写入Json文件。<br>此文件旨在与Chrome DevTools等工具一起使用。<br>Json模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><p>堆快照特定于单个V8隔离。<br>使用工作线程时，从主线程生成的堆快照将不包含有关工作线程的任何信息，反之亦然。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const &#123; writeHeapSnapshot &#125; &#x3D; require(&#39;v8&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker,</span><br><span class="line">  isMainThread,</span><br><span class="line">  parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line"></span><br><span class="line">  worker.once(&#39;message&#39;, (filename) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作线程的堆转储: $&#123;filename&#125;&#96;);</span><br><span class="line">    &#x2F;&#x2F; 获取主线程的堆转储。</span><br><span class="line">    console.log(&#96;主线程的堆转储: $&#123;writeHeapSnapshot()&#125;&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知工作线程创建一个堆转储。</span><br><span class="line">  worker.postMessage(&#39;heapdump&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    if (message &#x3D;&#x3D;&#x3D; &#39;heapdump&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 为工作线程生成一个堆转储，并返回文件名到父线程。</span><br><span class="line">      parentPort.postMessage(writeHeapSnapshot());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化的API"><a href="#序列化的API" class="headerlink" title="序列化的API"></a>序列化的API</h4><h5 id="v8-serialize-value"><a href="#v8-serialize-value" class="headerlink" title="v8.serialize(value)"></a>v8.serialize(value)</h5><h5 id="v8-deserialize-buffer"><a href="#v8-deserialize-buffer" class="headerlink" title="v8.deserialize(buffer)"></a>v8.deserialize(buffer)</h5><h5 id="v8-Serializer类"><a href="#v8-Serializer类" class="headerlink" title="v8.Serializer类"></a>v8.Serializer类</h5><h6 id="new-Serializer"><a href="#new-Serializer" class="headerlink" title="new Serializer()"></a>new Serializer()</h6><h6 id="serializer-writeHeader"><a href="#serializer-writeHeader" class="headerlink" title="serializer.writeHeader()"></a>serializer.writeHeader()</h6><h6 id="serializer-releaseBuffer"><a href="#serializer-releaseBuffer" class="headerlink" title="serializer.releaseBuffer()"></a>serializer.releaseBuffer()</h6><h6 id="serializer-transferArrayBuffer-id-arrayBuffer"><a href="#serializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="serializer.transferArrayBuffer(id, arrayBuffer)"></a>serializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="serializer-writeUint32-value"><a href="#serializer-writeUint32-value" class="headerlink" title="serializer.writeUint32(value)"></a>serializer.writeUint32(value)</h6><h6 id="serializer-writeUint64-hi-Io"><a href="#serializer-writeUint64-hi-Io" class="headerlink" title="serializer.writeUint64(hi, Io)"></a>serializer.writeUint64(hi, Io)</h6><h6 id="serializer-writeDouble-value"><a href="#serializer-writeDouble-value" class="headerlink" title="serializer.writeDouble(value)"></a>serializer.writeDouble(value)</h6><h6 id="serializer-writeRawBytes-buffer"><a href="#serializer-writeRawBytes-buffer" class="headerlink" title="serializer.writeRawBytes(buffer)"></a>serializer.writeRawBytes(buffer)</h6><h6 id="serializer-writeHostObject-object"><a href="#serializer-writeHostObject-object" class="headerlink" title="serializer._writeHostObject(object)"></a>serializer._writeHostObject(object)</h6><h6 id="serializer-getDataCloneError-message"><a href="#serializer-getDataCloneError-message" class="headerlink" title="serializer._getDataCloneError(message)"></a>serializer._getDataCloneError(message)</h6><h6 id="serializer-getSharedArrayBufferId-sharedArrayBuffer"><a href="#serializer-getSharedArrayBufferId-sharedArrayBuffer" class="headerlink" title="serializer._getSharedArrayBufferId(sharedArrayBuffer)"></a>serializer._getSharedArrayBufferId(sharedArrayBuffer)</h6><h6 id="serializer-setTreatArrayBufferViewsAsHostObjects-flag"><a href="#serializer-setTreatArrayBufferViewsAsHostObjects-flag" class="headerlink" title="serializer._setTreatArrayBufferViewsAsHostObjects(flag)"></a>serializer._setTreatArrayBufferViewsAsHostObjects(flag)</h6><h5 id="v8-Deserializer类"><a href="#v8-Deserializer类" class="headerlink" title="v8.Deserializer类"></a>v8.Deserializer类</h5><h6 id="new-Deserializer-buffer"><a href="#new-Deserializer-buffer" class="headerlink" title="new Deserializer(buffer)"></a>new Deserializer(buffer)</h6><h6 id="deserializer-readHeader"><a href="#deserializer-readHeader" class="headerlink" title="deserializer.readHeader()"></a>deserializer.readHeader()</h6><h6 id="deserializer-readValue"><a href="#deserializer-readValue" class="headerlink" title="deserializer.readValue()"></a>deserializer.readValue()</h6><h6 id="deserializer-transferArrayBuffer-id-arrayBuffer"><a href="#deserializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="deserializer.transferArrayBuffer(id, arrayBuffer)"></a>deserializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="deserializer-getWriteFormatVersion"><a href="#deserializer-getWriteFormatVersion" class="headerlink" title="deserializer.getWriteFormatVersion()"></a>deserializer.getWriteFormatVersion()</h6><h6 id="deserializer-readUint32"><a href="#deserializer-readUint32" class="headerlink" title="deserializer.readUint32()"></a>deserializer.readUint32()</h6><h6 id="deserializer-readUint64"><a href="#deserializer-readUint64" class="headerlink" title="deserializer.readUint64()"></a>deserializer.readUint64()</h6><h6 id="deserializer-readDouble"><a href="#deserializer-readDouble" class="headerlink" title="deserializer.readDouble()"></a>deserializer.readDouble()</h6><h6 id="deserializer-readRawBytes-length"><a href="#deserializer-readRawBytes-length" class="headerlink" title="deserializer.readRawBytes(length)"></a>deserializer.readRawBytes(length)</h6><h6 id="deserializer-readHostObject"><a href="#deserializer-readHostObject" class="headerlink" title="deserializer._readHostObject()"></a>deserializer._readHostObject()</h6><h5 id="v8-DefaultSerializer类"><a href="#v8-DefaultSerializer类" class="headerlink" title="v8.DefaultSerializer类"></a>v8.DefaultSerializer类</h5><h5 id="v8-DefaultDeserializer类"><a href="#v8-DefaultDeserializer类" class="headerlink" title="v8.DefaultDeserializer类"></a>v8.DefaultDeserializer类</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;v8&quot;&gt;&lt;a href=&quot;#v8&quot; class=&quot;headerlink&quot; title=&quot;v8&quot;&gt;&lt;/a&gt;v8&lt;/h2&gt;&lt;p&gt;V8引擎。&lt;/p&gt;
&lt;p&gt;v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const v8 &amp;#x3D; require(&amp;#39;v8&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;API和实现随时可能发生变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之util</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-util.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-util.html</id>
    <published>2020-02-07T10:17:25.000Z</published>
    <updated>2020-02-08T09:36:10.498Z</updated>
    
    <content type="html"><![CDATA[<h2 id="util"><a href="#util" class="headerlink" title="util"></a>util</h2><p>实用工具。<br>util模块主要用于支持nodejs内部API的需求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="util-callbackify-original"><a href="#util-callbackify-original" class="headerlink" title="util.callbackify(original)"></a>util.callbackify(original)</h4><p>将async异步函数转换成遵循异常有限的回调风格的函数<br>在回调函数中，第一个参数为拒绝的原因，第二个参数则是解决的值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">async function fn() &#123;</span><br><span class="line">  return &#39;hello world&#39;;</span><br><span class="line">&#125;</span><br><span class="line">const callbackFunction &#x3D; util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction((err, ret) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">  console.log(ret);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; hello world</span><br></pre></td></tr></table></figure><p>回调函数是异步执行的，并且有异常堆栈错误跟踪。如果回调函数抛出一个异常，进程会触发一个‘uncaughtException’异常，如果没有被捕获，进程将会退出。</p><p>null在回调函数中作为一个参数有其特殊意义，如果回调函数的收哥参数为Promise拒绝的原因且带有返回值，且值可以转换成布尔值false，这个值会被封装在Error对象里，可以通过属性reason获取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  return Promise.reject(null);</span><br><span class="line">&#125;</span><br><span class="line">const callbackFunction &#x3D; util.callbackify(fn);</span><br><span class="line"></span><br><span class="line">callbackFunction((err, ret) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 当 Promise 被以 &#96;null&#96; 拒绝时，它被包装为 Error 并且原始值存储在 &#96;reason&#96; 中。</span><br><span class="line">  err &amp;&amp; err.hasOwnProperty(&#39;reason&#39;) &amp;&amp; err.reason &#x3D;&#x3D;&#x3D; null;  &#x2F;&#x2F; true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="util-debuglog-section"><a href="#util-debuglog-section" class="headerlink" title="util.debuglog(section)"></a>util.debuglog(section)</h4><p>用于创建一个函数，基于NODE_DEBUG环境变量的存在与否有条件的写入调试信息到stderr。<br>如果section名称在环境变量的值中，则返回的函数类似于console.error()，否则返回的函数是一个空操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const debuglog &#x3D; util.debuglog(&#39;foo&#39;);</span><br><span class="line"></span><br><span class="line">debuglog(&#39;hello from foo [%d]&#39;, 123);</span><br></pre></td></tr></table></figure><p>如果程序在环境中运行时带上NODE_DEBUG=foo，则输出类似如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO 3245: hello from foo [123]</span><br></pre></td></tr></table></figure><p>3245是进程id，如果运行时没带上环境变量集合，则不会打印任何东西。</p><p>section还支持通配符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const debuglog &#x3D; util.debuglog(&#39;foo-bar&#39;);</span><br><span class="line"></span><br><span class="line">debuglog(&#39;hi there, it\&#39;s foo-bar [%d]&#39;, 2333);</span><br></pre></td></tr></table></figure><p>如果在环境中使用 NODE_DEBUG=foo* 运行，那么它将输出如下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FOO-BAR 3257: hi there, it&#39;s foo-bar [2333]</span><br></pre></td></tr></table></figure><p>NODE_DEBUG 环境变量中可指定多个由逗号分隔的 section 名称。 例如：NODE_DEBUG=fs,net,tls。</p><h4 id="util-deprecate-fn-msg-code"><a href="#util-deprecate-fn-msg-code" class="headerlink" title="util.deprecate(fn, msg[, code])"></a>util.deprecate(fn, msg[, code])</h4><p>以一种标记为已废弃的方式包装fn。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">exports.obsoleteFunction &#x3D; util.deprecate(() &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 一些操作。</span><br><span class="line">&#125;, &#39;obsoleteFunction() 已废弃，使用 newShinyFunction() 代替&#39;);</span><br></pre></td></tr></table></figure><p>当被调用时，会返回一个函数，这个函数会使用‘warning’事件触发一个DeprecationWaring。默认情况下，警告只在首次被调用时才会被触发并打印到stderr。警告被触发时，被包装的函数会被调用。</p><p>如果在对util.deprecate()的多次调用中提供了相同的可选code，该code仅触发一次警告。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">const fn1 &#x3D; util.deprecate(someFunction, someMessage, &#39;DEP0001&#39;);</span><br><span class="line">const fn2 &#x3D; util.deprecate(someOtherFunction, someOtherMessage, &#39;DEP0001&#39;);</span><br><span class="line">fn1(); &#x2F;&#x2F; 使用代码 DEP0001 触发废弃警告。</span><br><span class="line">fn2(); &#x2F;&#x2F; 不会触发废弃警告，因为它具有相同的代码。</span><br></pre></td></tr></table></figure><p>如果使用了 –no-deprecation 或 –no-warnings 命令行标记，或 process.noDeprecation 属性在首次废弃警告之前被设为 true，则 util.deprecate() 方法什么也不做。</p><p>如果设置了 –trace-deprecation 或 –trace-warnings 命令行标记，或 process.traceDeprecation 属性被设为 true，则废弃的函数首次被调用时会把警告与堆栈追踪打印到 stderr。</p><p>如果设置了 –throw-deprecation 命令行标记，或 process.throwDeprecation 属性被设为 true，则当废弃的函数被调用时会抛出一个异常。</p><p>–throw-deprecation 命令行标记和 process.throwDeprecation 属性优先于 –trace-deprecation 和 process.traceDeprecation。</p><h4 id="util-format-format-…args"><a href="#util-format-format-…args" class="headerlink" title="util.format(format[, …args])"></a>util.format(format[, …args])</h4><p>如果占位符没有对应的参数，则占位符不被替换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(&#39;%s:%s&#39;, &#39;foo&#39;)</span><br><span class="line">&#x2F;&#x2F; &#39;foo:%s&#39;</span><br></pre></td></tr></table></figure><p>如果类型不是string，则使用util.inspect()格式化不属于格式字符串的值。</p><p>如果传入util.format()方法的参数比占位符的数量多，则多出的参数会被强制转换为字符串，然后拼接到返回的字符串，参数之间用一个空格分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(&#39;%s:%s&#39;, &#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;foo:bar baz&#39;</span><br></pre></td></tr></table></figure><p>如果第一个参数不是一个字符串，则 util.format() 返回一个所有参数用空格分隔并连在一起的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(1, 2, 3);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;1 2 3&#39;</span><br></pre></td></tr></table></figure><p>如果只有一个参数传给 util.format()，它将按原样返回，不带任何格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">util.format(&#39;%% %s&#39;);</span><br><span class="line">&#x2F;&#x2F; 返回: &#39;%% %s&#39;</span><br></pre></td></tr></table></figure><p>util.format() 是一种用作调试工具的同步方法。 某些输入值可能会产生严重的性能开销，从而阻止事件循环。 请谨慎使用此功能，切勿在热代码路径中使用。</p><h4 id="util-formatWithOptions-inspectOptions-format-…args"><a href="#util-formatWithOptions-inspectOptions-format-…args" class="headerlink" title="util.formatWithOptions(inspectOptions, format[, …args])"></a>util.formatWithOptions(inspectOptions, format[, …args])</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">util.formatWithOptions(&#123; colors: true &#125;, &#39;See object %O&#39;, &#123; foo: 42 &#125;);</span><br><span class="line">&#x2F;&#x2F; Returns &#39;See object &#123; foo: 42 &#125;&#39;, where &#96;42&#96; is colored as a number</span><br><span class="line">&#x2F;&#x2F; when printed to a terminal.</span><br></pre></td></tr></table></figure><h4 id="util-getSystemErrorName-err"><a href="#util-getSystemErrorName-err" class="headerlink" title="util.getSystemErrorName(err)"></a>util.getSystemErrorName(err)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.access(&#39;file&#x2F;that&#x2F;does&#x2F;not&#x2F;exist&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  const name &#x3D; util.getSystemErrorName(err.errno);</span><br><span class="line">  console.error(name);  &#x2F;&#x2F; ENOENT</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="util-inherits-constructor-superConstructor"><a href="#util-inherits-constructor-superConstructor" class="headerlink" title="util.inherits(constructor, superConstructor)"></a>util.inherits(constructor, superConstructor)</h4><p>不建议使用 util.inherits()。 请使用 ES6 的 class 和 extends 关键词获得语言层面的继承支持。 这两种方式是语义上不兼容的。</p><p>从一个构造函数中继承原型方法到另一个。 constructor 的原型会被设置到一个从 superConstructor 创建的新对象上。</p><p>这主要在 Object.setPrototypeOf(constructor.prototype, superConstructor.prototype) 之上添加了一些输入验证。 作为额外的便利，可以通过 constructor.super_属性访问 superConstructor。</p><h4 id="util-inspect-object-options"><a href="#util-inspect-object-options" class="headerlink" title="util.inspect(object[, options])"></a>util.inspect(object[, options])</h4><h4 id="util-inspect-object-showHidden-depth-colors"><a href="#util-inspect-object-showHidden-depth-colors" class="headerlink" title="util.inspect(object[, showHidden[, depth[, colors]]])"></a>util.inspect(object[, showHidden[, depth[, colors]]])</h4><h4 id="自定义util-inspect的颜色"><a href="#自定义util-inspect的颜色" class="headerlink" title="自定义util.inspect的颜色"></a>自定义util.inspect的颜色</h4><p>可以通过util.inspect.styles和util.inspect.colors属性全局的自定义util.inspect的颜色输出。</p><p>util.inspect.styles是一个映射，关联一个样式名到一个util.inspect.colors颜色。</p><h4 id="util-inspect-custom"><a href="#util-inspect-custom" class="headerlink" title="util.inspect.custom"></a>util.inspect.custom</h4><h4 id="util-inspect-defaultOPTIONS"><a href="#util-inspect-defaultOPTIONS" class="headerlink" title="util.inspect.defaultOPTIONS"></a>util.inspect.defaultOPTIONS</h4><p>defaultOptions值允许对被util.inspect使用的默认选项进行自定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const arr &#x3D; Array(101).fill(0);</span><br><span class="line"></span><br><span class="line">console.log(arr); &#x2F;&#x2F; 打印截断的数组</span><br><span class="line">util.inspect.defaultOptions.maxArrayLength &#x3D; null;</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 打印完整的数组</span><br></pre></td></tr></table></figure><h4 id="util-isDeepStrictEqual-val1-val2"><a href="#util-isDeepStrictEqual-val1-val2" class="headerlink" title="util.isDeepStrictEqual(val1, val2)"></a>util.isDeepStrictEqual(val1, val2)</h4><h4 id="util-promisify-original"><a href="#util-promisify-original" class="headerlink" title="util.promisify(original)"></a>util.promisify(original)</h4><p>传入一个遵循常见的错误优先的回调风格的函数，并返回一个promise的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">const stat &#x3D; util.promisify(fs.stat);</span><br><span class="line">stat(&#39;.&#39;).then((stats) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 使用 &#96;stats&#96;。</span><br><span class="line">&#125;).catch((error) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误。</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>或等效的使用async fnuction</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">const stat &#x3D; util.promisify(fs.stat);</span><br><span class="line"></span><br><span class="line">async function callStat() &#123;</span><br><span class="line">  const stats &#x3D; await stat(&#39;.&#39;);</span><br><span class="line">  console.log(&#96;该目录归 $&#123;stats.uid&#125; 拥有&#96;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在 original[util.promisify.custom] 属性，则 promisify 将会返回其值，参阅自定义的 promise 化函数。</p><p>promisify() 在所有情况下都会假定 original 是一个以回调作为其最后参数的函数。 如果 original 不是一个函数，则 promisify() 将会抛出错误。 如果 original 是一个函数但其最后一个参数不是一个错误优先的回调，则它将仍会传入一个错误优先的回调作为其最后一个参数。</p><p>除非特殊处理，否则在类方法或使用 this 的其他方法上使用 promisify() 可能无法正常工作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">class Foo &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.a &#x3D; 42;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bar(callback) &#123;</span><br><span class="line">    callback(null, this.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const foo &#x3D; new Foo();</span><br><span class="line"></span><br><span class="line">const naiveBar &#x3D; util.promisify(foo.bar);</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot read property &#39;a&#39; of undefined</span><br><span class="line">&#x2F;&#x2F; naiveBar().then(a &#x3D;&gt; console.log(a));</span><br><span class="line"></span><br><span class="line">naiveBar.call(foo).then((a) &#x3D;&gt; console.log(a)); &#x2F;&#x2F; &#39;42&#39;</span><br><span class="line"></span><br><span class="line">const bindBar &#x3D; naiveBar.bind(foo);</span><br><span class="line">bindBar().then((a) &#x3D;&gt; console.log(a)); &#x2F;&#x2F; &#39;42&#39;</span><br></pre></td></tr></table></figure><h4 id="自定义的Promise化函数"><a href="#自定义的Promise化函数" class="headerlink" title="自定义的Promise化函数"></a>自定义的Promise化函数</h4><p>使用util.promisify.custorm符号可以重写util.promisify()的返回值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">function doSomething(foo, callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething[util.promisify.custom] &#x3D; (foo) &#x3D;&gt; &#123;</span><br><span class="line">  return getPromiseSomehow();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const promisified &#x3D; util.promisify(doSomething);</span><br><span class="line">console.log(promisified &#x3D;&#x3D;&#x3D; doSomething[util.promisify.custom]);</span><br><span class="line">&#x2F;&#x2F; 打印 &#39;true&#39;</span><br></pre></td></tr></table></figure><h4 id="util-promisify-custom"><a href="#util-promisify-custom" class="headerlink" title="util.promisify.custom"></a>util.promisify.custom</h4><h4 id="util-TextDecoder类"><a href="#util-TextDecoder类" class="headerlink" title="util.TextDecoder类"></a>util.TextDecoder类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const decoder &#x3D; new TextDecoder(&#39;shift_jis&#39;);</span><br><span class="line">let string &#x3D; &#39;&#39;;</span><br><span class="line">let buffer;</span><br><span class="line">while (buffer &#x3D; getNextChunkSomehow()) &#123;</span><br><span class="line">  string +&#x3D; decoder.decode(buffer, &#123; stream: true &#125;);</span><br><span class="line">&#125;</span><br><span class="line">string +&#x3D; decoder.decode(); &#x2F;&#x2F; 流的末尾。</span><br></pre></td></tr></table></figure><h5 id="new-TextDecoder-encoding-options"><a href="#new-TextDecoder-encoding-options" class="headerlink" title="new TextDecoder([encoding[, options]])"></a>new TextDecoder([encoding[, options]])</h5><h5 id="textDecoder-decode-input-options"><a href="#textDecoder-decode-input-options" class="headerlink" title="textDecoder.decode([input[, options]])"></a>textDecoder.decode([input[, options]])</h5><h5 id="textDecoder-encoding"><a href="#textDecoder-encoding" class="headerlink" title="textDecoder.encoding"></a>textDecoder.encoding</h5><h5 id="textDecoder-fatal"><a href="#textDecoder-fatal" class="headerlink" title="textDecoder.fatal"></a>textDecoder.fatal</h5><h5 id="textDecoder-ignoreBOM"><a href="#textDecoder-ignoreBOM" class="headerlink" title="textDecoder.ignoreBOM"></a>textDecoder.ignoreBOM</h5><h4 id="util-TextEncoder类"><a href="#util-TextEncoder类" class="headerlink" title="util.TextEncoder类"></a>util.TextEncoder类</h4><p>TextEncoder的所有实例仅支持UTF-8编码。<br>TextEncoder类在全局对象上可用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const encoder &#x3D; new TextEncoder();</span><br><span class="line">const uint8array &#x3D; encoder.encode(&#39;这是一些数据&#39;);</span><br></pre></td></tr></table></figure><h5 id="textEncoder-encode-input"><a href="#textEncoder-encode-input" class="headerlink" title="textEncoder.encode([input])"></a>textEncoder.encode([input])</h5><h5 id="textEncoder-encodeInto-src-dest"><a href="#textEncoder-encodeInto-src-dest" class="headerlink" title="textEncoder.encodeInto(src, dest)"></a>textEncoder.encodeInto(src, dest)</h5><h5 id="textEncoder-encoding"><a href="#textEncoder-encoding" class="headerlink" title="textEncoder.encoding"></a>textEncoder.encoding</h5><h4 id="util-types"><a href="#util-types" class="headerlink" title="util.types"></a>util.types</h4><h5 id="util-types-isAnyArrayBuffer-value"><a href="#util-types-isAnyArrayBuffer-value" class="headerlink" title="util.types.isAnyArrayBuffer(value)"></a>util.types.isAnyArrayBuffer(value)</h5><h5 id="util-types-isArgumentsObject-value"><a href="#util-types-isArgumentsObject-value" class="headerlink" title="util.types.isArgumentsObject(value)"></a>util.types.isArgumentsObject(value)</h5><h5 id="util-types-isArrayBuffer-value"><a href="#util-types-isArrayBuffer-value" class="headerlink" title="util.types.isArrayBuffer(value)"></a>util.types.isArrayBuffer(value)</h5><h5 id="util-types-isAsyncFunction-value"><a href="#util-types-isAsyncFunction-value" class="headerlink" title="util.types.isAsyncFunction(value)"></a>util.types.isAsyncFunction(value)</h5><h5 id="util-types-isBigInt64Array-value"><a href="#util-types-isBigInt64Array-value" class="headerlink" title="util.types.isBigInt64Array(value)"></a>util.types.isBigInt64Array(value)</h5><h5 id="util-types-isBigUint64Array-value"><a href="#util-types-isBigUint64Array-value" class="headerlink" title="util.types.isBigUint64Array(value)"></a>util.types.isBigUint64Array(value)</h5><h5 id="util-types-isBooleanObject-value"><a href="#util-types-isBooleanObject-value" class="headerlink" title="util.types.isBooleanObject(value)"></a>util.types.isBooleanObject(value)</h5><h5 id="util-types-isDataView-value"><a href="#util-types-isDataView-value" class="headerlink" title="util.types.isDataView(value)"></a>util.types.isDataView(value)</h5><h5 id="util-types-isData-value"><a href="#util-types-isData-value" class="headerlink" title="util.types.isData(value)"></a>util.types.isData(value)</h5><h5 id="util-types-isExternal-value"><a href="#util-types-isExternal-value" class="headerlink" title="util.types.isExternal(value)"></a>util.types.isExternal(value)</h5><h5 id="util-types-isFloat32Array-value"><a href="#util-types-isFloat32Array-value" class="headerlink" title="util.types.isFloat32Array(value)"></a>util.types.isFloat32Array(value)</h5><h5 id="util-types-isFloat64Array-value"><a href="#util-types-isFloat64Array-value" class="headerlink" title="util.types.isFloat64Array(value)"></a>util.types.isFloat64Array(value)</h5><h5 id="util-types-isGeneratorFunction-value"><a href="#util-types-isGeneratorFunction-value" class="headerlink" title="util.types.isGeneratorFunction(value)"></a>util.types.isGeneratorFunction(value)</h5><h5 id="util-types-isGeneratorObject-value"><a href="#util-types-isGeneratorObject-value" class="headerlink" title="util.types.isGeneratorObject(value)"></a>util.types.isGeneratorObject(value)</h5><h5 id="util-types-isInt8Array-value"><a href="#util-types-isInt8Array-value" class="headerlink" title="util.types.isInt8Array(value)"></a>util.types.isInt8Array(value)</h5><h5 id="util-types-isInt16Array-value"><a href="#util-types-isInt16Array-value" class="headerlink" title="util.types.isInt16Array(value)"></a>util.types.isInt16Array(value)</h5><h5 id="util-types-isInt32Array-value"><a href="#util-types-isInt32Array-value" class="headerlink" title="util.types.isInt32Array(value)"></a>util.types.isInt32Array(value)</h5><h5 id="util-types-isMap-value"><a href="#util-types-isMap-value" class="headerlink" title="util.types.isMap(value)"></a>util.types.isMap(value)</h5><h5 id="util-types-isMapIterator-value"><a href="#util-types-isMapIterator-value" class="headerlink" title="util.types.isMapIterator(value)"></a>util.types.isMapIterator(value)</h5><h5 id="util-types-isModuleNamespaceObject-value"><a href="#util-types-isModuleNamespaceObject-value" class="headerlink" title="util.types.isModuleNamespaceObject(value)"></a>util.types.isModuleNamespaceObject(value)</h5><h5 id="util-types-isNativeError-value"><a href="#util-types-isNativeError-value" class="headerlink" title="util.types.isNativeError(value)"></a>util.types.isNativeError(value)</h5><h5 id="util-types-isNumberObjext-value"><a href="#util-types-isNumberObjext-value" class="headerlink" title="util.types.isNumberObjext(value)"></a>util.types.isNumberObjext(value)</h5><h5 id="util-types-isPromise-value"><a href="#util-types-isPromise-value" class="headerlink" title="util.types.isPromise(value)"></a>util.types.isPromise(value)</h5><h5 id="util-types-isProxy-value"><a href="#util-types-isProxy-value" class="headerlink" title="util.types.isProxy(value)"></a>util.types.isProxy(value)</h5><h5 id="util-types-isRegExp-value"><a href="#util-types-isRegExp-value" class="headerlink" title="util.types.isRegExp(value)"></a>util.types.isRegExp(value)</h5><h5 id="util-types-isSet-value"><a href="#util-types-isSet-value" class="headerlink" title="util.types.isSet(value)"></a>util.types.isSet(value)</h5><h5 id="util-types-isSetIterator-value"><a href="#util-types-isSetIterator-value" class="headerlink" title="util.types.isSetIterator(value)"></a>util.types.isSetIterator(value)</h5><h5 id="util-types-isSharedArrayBuffer-value"><a href="#util-types-isSharedArrayBuffer-value" class="headerlink" title="util.types.isSharedArrayBuffer(value)"></a>util.types.isSharedArrayBuffer(value)</h5><h5 id="util-types-isStringObject-value"><a href="#util-types-isStringObject-value" class="headerlink" title="util.types.isStringObject(value)"></a>util.types.isStringObject(value)</h5><h5 id="util-types-isSymbolObject-value"><a href="#util-types-isSymbolObject-value" class="headerlink" title="util.types.isSymbolObject(value)"></a>util.types.isSymbolObject(value)</h5><h5 id="util-types-isTypedArray-value"><a href="#util-types-isTypedArray-value" class="headerlink" title="util.types.isTypedArray(value)"></a>util.types.isTypedArray(value)</h5><h5 id="util-types-isUint8Array-value"><a href="#util-types-isUint8Array-value" class="headerlink" title="util.types.isUint8Array(value)"></a>util.types.isUint8Array(value)</h5><h5 id="util-types-isUint8ClampedArray-value"><a href="#util-types-isUint8ClampedArray-value" class="headerlink" title="util.types.isUint8ClampedArray(value)"></a>util.types.isUint8ClampedArray(value)</h5><h5 id="util-types-isUint16Array-value"><a href="#util-types-isUint16Array-value" class="headerlink" title="util.types.isUint16Array(value)"></a>util.types.isUint16Array(value)</h5><h5 id="util-types-isUint32Array-value"><a href="#util-types-isUint32Array-value" class="headerlink" title="util.types.isUint32Array(value)"></a>util.types.isUint32Array(value)</h5><h5 id="util-types-isWeakMap-value"><a href="#util-types-isWeakMap-value" class="headerlink" title="util.types.isWeakMap(value)"></a>util.types.isWeakMap(value)</h5><h5 id="util-types-isWeakSet-value"><a href="#util-types-isWeakSet-value" class="headerlink" title="util.types.isWeakSet(value)"></a>util.types.isWeakSet(value)</h5><h5 id="util-types-isWebAssemblyCompiledModule-value"><a href="#util-types-isWebAssemblyCompiledModule-value" class="headerlink" title="util.types.isWebAssemblyCompiledModule(value)"></a>util.types.isWebAssemblyCompiledModule(value)</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;util&quot;&gt;&lt;a href=&quot;#util&quot; class=&quot;headerlink&quot; title=&quot;util&quot;&gt;&lt;/a&gt;util&lt;/h2&gt;&lt;p&gt;实用工具。&lt;br&gt;util模块主要用于支持nodejs内部API的需求。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const util &amp;#x3D; require(&amp;#39;util&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之url</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-url.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-url.html</id>
    <published>2020-02-07T10:16:26.000Z</published>
    <updated>2020-02-08T07:15:00.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2><p>url模块用于处理与解析URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const url &#x3D; require(&#39;url&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="URL字符串与URL对象"><a href="#URL字符串与URL对象" class="headerlink" title="URL字符串与URL对象"></a>URL字符串与URL对象</h4><p>URL字符串是结构化的字符串，包含多个含义不同的组成部分。<br>解析字符串后返回的URL对象，每个属性对应字符串各个组成部分。</p><p>url模块提供了两套API来处理URL：一个是旧版本遗留的API，一个是实现了WHATWG标准的新API。</p><p>下图中上方是遗留的url.parse()，下方是WHATWG的url对象的属性.</p><p>WHATWG的origin属性包括protocol和host，但不包括userName或password。<br><img src="./../images/url.jpg" alt="Image text"></p><p>使用WHATWG的API解析URL字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D;</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;user:pass@sub.host.com:8080&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string#hash&#39;);</span><br></pre></td></tr></table></figure><p>使用遗留的API解析URL字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const url &#x3D; require(&#39;url&#39;);</span><br><span class="line">const myURL &#x3D;</span><br><span class="line">  url.parse(&#39;https:&#x2F;&#x2F;user:pass@sub.host.com:8080&#x2F;p&#x2F;a&#x2F;t&#x2F;h?query&#x3D;string#hash&#39;);</span><br></pre></td></tr></table></figure><h4 id="WHATWG的URL接口"><a href="#WHATWG的URL接口" class="headerlink" title="WHATWG的URL接口"></a>WHATWG的URL接口</h4><h5 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h5><p>浏览器兼容的URL类，根据WHATWG URL标准实现。</p><h5 id="new-URL-input-base"><a href="#new-URL-input-base" class="headerlink" title="new URL(input[, base])"></a>new URL(input[, base])</h5><p>通过将input相对于base进行解析，创建一个新的URL对象。如果base是一个字符串，则解析方法与new URL(base)相同。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;&#x2F;foo&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;foo</span><br></pre></td></tr></table></figure><p>如果input和base是无效的URL，则将抛出TypeError。<br>注意，给定值将会被强制转换为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#123; toString: () &#x3D;&gt; &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;</span><br></pre></td></tr></table></figure><p>存在于input主机名中的Unicode字符将被使用Punycode算法转换为ASCII。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;測試&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;xn--g6w251d&#x2F;</span><br></pre></td></tr></table></figure><p>只有在启用ICU的情况下编译node可执行文件时，此功能才可用。如果没有，则域名将保持不变。<br>如果input是绝对的URL并提供了base，则实现不知道它，建议验证URL对象的origin是否是预期的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let myURL &#x3D; new URL(&#39;http:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;foo:&#x2F;&#x2F;Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; foo:&#x2F;&#x2F;Example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;http:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;https:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; https:&#x2F;&#x2F;example.org&#x2F;Example.com&#x2F;</span><br><span class="line"></span><br><span class="line">myURL &#x3D; new URL(&#39;foo:Example.com&#x2F;&#39;, &#39;https:&#x2F;&#x2F;example.org&#x2F;&#39;);</span><br><span class="line">&#x2F;&#x2F; foo:Example.com&#x2F;</span><br></pre></td></tr></table></figure><h5 id="url-hash"><a href="#url-hash" class="headerlink" title="url.hash"></a>url.hash</h5><p>获取及设置Url的片段部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo#bar&#39;);</span><br><span class="line">console.log(myURL.hash);</span><br><span class="line">  &#x2F;&#x2F; 打印 #bar</span><br><span class="line"></span><br><span class="line">myURL.hash &#x3D; &#39;baz&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;foo#baz</span><br></pre></td></tr></table></figure><p>分配给hash属性的值中包含的无效URL字符是百分比编码的。<br>选择哪些字符进行百分比编码可能与 url.parse() 和 url.format() 方法产生的内容有所不同。</p><h5 id="url-host"><a href="#url-host" class="headerlink" title="url.host"></a>url.host</h5><p>获取及设置URL的主机部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org:81&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.host);</span><br><span class="line">  &#x2F;&#x2F; 打印 example.org:81</span><br><span class="line"></span><br><span class="line">myURL.host &#x3D; &#39;example.com:82&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com:82&#x2F;foo</span><br></pre></td></tr></table></figure><p>分配给host属性的无效主机值将会被忽略。</p><h5 id="url-hostname"><a href="#url-hostname" class="headerlink" title="url.hostname"></a>url.hostname</h5><p>获取及设置URL的主机名部分。<br>url.host和url.hostname之间的区别是url.hostname不包含端口。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org:81&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.hostname);</span><br><span class="line">  &#x2F;&#x2F; 打印 example.org</span><br><span class="line"></span><br><span class="line">myURL.hostname &#x3D; &#39;example.com:82&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com:81&#x2F;foo</span><br></pre></td></tr></table></figure><h5 id="url-href"><a href="#url-href" class="headerlink" title="url.href"></a>url.href</h5><p>获取及设置序列化的URL.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;foo</span><br><span class="line"></span><br><span class="line">myURL.href &#x3D; &#39;https:&#x2F;&#x2F;example.com&#x2F;bar&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.com&#x2F;bar</span><br></pre></td></tr></table></figure><p>获取href属性的值等同于调用url.toString()</p><p>将此属性的值设置为新值等同于使用new URL(value) 创建新的URL对象。 URL对象的每个属性都将被修改。</p><p>如果给href属性设置的值是无效的URL，则将会抛出TypeError。</p><h5 id="url-origin"><a href="#url-origin" class="headerlink" title="url.origin"></a>url.origin</h5><p>获取只读的序列化的URL的origin。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onst myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;foo&#x2F;bar?baz&#39;);</span><br><span class="line">console.log(myURL.origin);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const idnURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;測試&#39;);</span><br><span class="line">console.log(idnURL.origin);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;xn--g6w251d</span><br><span class="line"></span><br><span class="line">console.log(idnURL.hostname);</span><br><span class="line">&#x2F;&#x2F; 打印 xn--g6w251d</span><br></pre></td></tr></table></figure><h5 id="url-password"><a href="#url-password" class="headerlink" title="url.password"></a>url.password</h5><p>获取及设置的URL的密码部分。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;abc:xyz@example.com&#39;);</span><br><span class="line">console.log(myURL.password);</span><br><span class="line">  &#x2F;&#x2F; 打印 xyz</span><br><span class="line"></span><br><span class="line">myURL.password &#x3D; &#39;123&#39;;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">  &#x2F;&#x2F; 打印 https:&#x2F;&#x2F;abc:123@example.com</span><br></pre></td></tr></table></figure><h5 id="url-pathname"><a href="#url-pathname" class="headerlink" title="url.pathname"></a>url.pathname</h5><p>获取及设置URL的路径部分。</p><h5 id="url-port"><a href="#url-port" class="headerlink" title="url.port"></a>url.port</h5><p>获取及设置URL的端口部分。<br>端口值可以是数字或包含0到65535范围内的数字字符串。<br>端口值可以是空字符串，这种情况下，端口取决于协议/规范：<br>| 协议 | 端口 |<br>| ftp |  21  |<br>| file |     |<br>| gopher | 70 |<br>| http | 80 |<br>| https | 443 |<br>| ws | 80  |<br>| wss | 443 |</p><p>在为端口分配值后，将首先使用.toString()将值转换为字符串。</p><p>如果该字符串无效但以数字开头，则将前导代码分配给port。如果数字位于上述范围之外，则忽略它。</p><h5 id="url-protocol"><a href="#url-protocol" class="headerlink" title="url.protocol"></a>url.protocol</h5><p>获取及设置URL的协议部分。</p><h5 id="特殊协议"><a href="#特殊协议" class="headerlink" title="特殊协议"></a>特殊协议</h5><h5 id="url-search"><a href="#url-search" class="headerlink" title="url.search"></a>url.search</h5><p>获取及设置URL的序列化查询部分</p><h5 id="url-searchParams"><a href="#url-searchParams" class="headerlink" title="url.searchParams"></a>url.searchParams</h5><p>获取表示URL查询参数的URLSearchParams对象。该属性是只读的。</p><h5 id="url-username"><a href="#url-username" class="headerlink" title="url.username"></a>url.username</h5><p>获取及设置URL的用户名部分。</p><h5 id="url-toString"><a href="#url-toString" class="headerlink" title="url.toString()"></a>url.toString()</h5><p>在Url对象上调用toString()方法返回序列化的URL。<br>返回值与url.href和url.toJSON()的相同。</p><h5 id="url-toJSON"><a href="#url-toJSON" class="headerlink" title="url.toJSON()"></a>url.toJSON()</h5><p>在URL对象上调用toJSON()方法返回序列化的URL。<br>返回值与url.href和url.toString()的相同。</p><p>当URL对象使用JSON.stringify()序列化时将自动调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const myURLs &#x3D; [</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;www.example.com&#39;),</span><br><span class="line">  new URL(&#39;https:&#x2F;&#x2F;test.example.org&#39;)</span><br><span class="line">];</span><br><span class="line">console.log(JSON.stringify(myURLs));</span><br><span class="line">&#x2F;&#x2F; 打印 [&quot;https:&#x2F;&#x2F;www.example.com&#x2F;&quot;,&quot;https:&#x2F;&#x2F;test.example.org&#x2F;&quot;]</span><br></pre></td></tr></table></figure><h4 id="URLSearchParams类"><a href="#URLSearchParams类" class="headerlink" title="URLSearchParams类"></a>URLSearchParams类</h4><p>URLSearchParams API提供对URL查询部分的读写权限。<br>URLSearchParams 类也能够与以下四个构造函数中的任意一个单独使用。<br>URLSearchParams 类也可在全局对象上使用。</p><p>WHATWG URLSearchParams 接口和 querystring 模块有相似的目的，<br>但是 querystring 模块的目的更加通用，因为它可以定制分隔符（＆ 和 =）。<br>但另一方面，这个 API 是专门为 URL 查询字符串而设计的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const myURL &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.org&#x2F;?abc&#x3D;123&#39;);</span><br><span class="line">console.log(myURL.searchParams.get(&#39;abc&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印 123</span><br><span class="line"></span><br><span class="line">myURL.searchParams.append(&#39;abc&#39;, &#39;xyz&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?abc&#x3D;123&amp;abc&#x3D;xyz</span><br><span class="line"></span><br><span class="line">myURL.searchParams.delete(&#39;abc&#39;);</span><br><span class="line">myURL.searchParams.set(&#39;a&#39;, &#39;b&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b</span><br><span class="line"></span><br><span class="line">const newSearchParams &#x3D; new URLSearchParams(myURL.searchParams);</span><br><span class="line">&#x2F;&#x2F; 上面的代码等同于：</span><br><span class="line">&#x2F;&#x2F; const newSearchParams &#x3D; new URLSearchParams(myURL.search);</span><br><span class="line"></span><br><span class="line">newSearchParams.append(&#39;a&#39;, &#39;c&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b</span><br><span class="line">console.log(newSearchParams.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 a&#x3D;b&amp;a&#x3D;c</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; newSearchParams.toString() 会被隐式调用。</span><br><span class="line">myURL.search &#x3D; newSearchParams;</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b&amp;a&#x3D;c</span><br><span class="line">newSearchParams.delete(&#39;a&#39;);</span><br><span class="line">console.log(myURL.href);</span><br><span class="line">&#x2F;&#x2F; 打印 https:&#x2F;&#x2F;example.org&#x2F;?a&#x3D;b&amp;a&#x3D;c</span><br></pre></td></tr></table></figure><h5 id="new-URLSearchParams"><a href="#new-URLSearchParams" class="headerlink" title="new URLSearchParams()"></a>new URLSearchParams()</h5><p>实例化一个新的空的URLSearchParams对象。</p><h5 id="new-URLSearchParams-string"><a href="#new-URLSearchParams-string" class="headerlink" title="new URLSearchParams(string)"></a>new URLSearchParams(string)</h5><p>将string解析成一个查询字符串，并用它来实例化一个新的URLSearchParams对象。<br>如果以“？”开头，则忽略。</p><h5 id="new-URLSearchParams-obj"><a href="#new-URLSearchParams-obj" class="headerlink" title="new URLSearchParams(obj)"></a>new URLSearchParams(obj)</h5><p>obj:表示键值对集合的对象。</p><p>通过使用查询哈希映射实例化一个新的URLSearchParams对象。<br>obj的每一个属性的键值都将强制转换为字符串。</p><p>和 querystring 模块不同的是，在数组的形式中，重复的键是不允许的。<br>数组使用 array.toString() 进行字符串化时，只需用逗号连接所有的数组元素即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const params &#x3D; new URLSearchParams(&#123;</span><br><span class="line">  user: &#39;abc&#39;,</span><br><span class="line">  query: [&#39;first&#39;, &#39;second&#39;]</span><br><span class="line">&#125;);</span><br><span class="line">console.log(params.getAll(&#39;query&#39;));</span><br><span class="line">&#x2F;&#x2F; 打印 [ &#39;first,second&#39; ]</span><br><span class="line">console.log(params.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 &#39;user&#x3D;abc&amp;query&#x3D;first%2Csecond&#39;</span><br></pre></td></tr></table></figure><h5 id="urlSearchParams-append-name-value"><a href="#urlSearchParams-append-name-value" class="headerlink" title="urlSearchParams.append(name, value)"></a>urlSearchParams.append(name, value)</h5><p>在查询字符串中附加一个新的键值对。</p><h5 id="urlSearchParams-delete-name"><a href="#urlSearchParams-delete-name" class="headerlink" title="urlSearchParams.delete(name)"></a>urlSearchParams.delete(name)</h5><p>删除所有键为name的键值对。</p><h5 id="urlSearchParams-entries"><a href="#urlSearchParams-entries" class="headerlink" title="urlSearchParams.entries()"></a>urlSearchParams.entries()</h5><p>在查询中的每个键值对上返回一个ES6 Iterator。<br>迭代器的每一项都是一个JavaScript Array。<br>Array的第一个项是键name，第二个项是值value。</p><h5 id="urlSearchParams-forEach-fn-thisArg"><a href="#urlSearchParams-forEach-fn-thisArg" class="headerlink" title="urlSearchParams.forEach(fn[, thisArg])"></a>urlSearchParams.forEach(fn[, thisArg])</h5><p>在查询字符串中迭代每个键值对，并调用给定的函数。</p><h5 id="urlSearchParams-get-name"><a href="#urlSearchParams-get-name" class="headerlink" title="urlSearchParams.get(name)"></a>urlSearchParams.get(name)</h5><p>返回键是name的第一个键值对的值。如果没有对应的键值对，则返回null。</p><h5 id="urlSearchParams-getAll-name"><a href="#urlSearchParams-getAll-name" class="headerlink" title="urlSearchParams.getAll(name)"></a>urlSearchParams.getAll(name)</h5><p>返回键是name的所有键值对的值，如果没有满足条件的键值对，则返回一个空数组。</p><h5 id="urlSearchParams-has-name"><a href="#urlSearchParams-has-name" class="headerlink" title="urlSearchParams.has(name)"></a>urlSearchParams.has(name)</h5><p>如果存在至少一对键是name的键值对则返回true。</p><h5 id="urlSearchParams-keys"><a href="#urlSearchParams-keys" class="headerlink" title="urlSearchParams.keys()"></a>urlSearchParams.keys()</h5><p>在每一个键值对上返回一个键的ES6 Iterator。</p><h5 id="urlSearchParams-set-name-value"><a href="#urlSearchParams-set-name-value" class="headerlink" title="urlSearchParams.set(name, value)"></a>urlSearchParams.set(name, value)</h5><p>将URLSearchParams对象中与name对象的值设置为value。<br>如果已经存在键为name的键值对，则将第一对的值设为value并删除其他队。<br>如果不存在，则将此键值对附加在查询字符串后。</p><h5 id="urlSearchParams-sort"><a href="#urlSearchParams-sort" class="headerlink" title="urlSearchParams.sort()"></a>urlSearchParams.sort()</h5><p>按现有名称就地排列所有的名称-值对。<br>使用稳定排序算法完成排序，因此保留具有相同名称的名称-值对之间的相对顺序。</p><p>该方法可以用来增加缓存命中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const params &#x3D; new URLSearchParams(&#39;query[]&#x3D;abc&amp;type&#x3D;search&amp;query[]&#x3D;123&#39;);</span><br><span class="line">params.sort();</span><br><span class="line">console.log(params.toString());</span><br><span class="line">&#x2F;&#x2F; 打印 query%5B%5D&#x3D;abc&amp;query%5B%5D&#x3D;123&amp;type&#x3D;search</span><br></pre></td></tr></table></figure><h5 id="urlSearchParams-toString"><a href="#urlSearchParams-toString" class="headerlink" title="urlSearchParams.toString()"></a>urlSearchParams.toString()</h5><p>返回查询参数序列化后的字符串，必要时存在百分号编码字符。</p><h5 id="urlSearchParams-values"><a href="#urlSearchParams-values" class="headerlink" title="urlSearchParams.values()"></a>urlSearchParams.values()</h5><p>在每一个键值对上返回一个值的ES6 Iterator。</p><h5 id="urlSearchParams-Symbol-iterator"><a href="#urlSearchParams-Symbol-iterator" class="headerlink" title="urlSearchParams[Symbol.iterator]"></a>urlSearchParams[Symbol.iterator]</h5><p>根据查询字符串，返回一个键值对形式的ES6 Iterator。<br>每个迭代器的项是一个JavaScript Array。<br>其中，Array的第一项是name，第二个是value。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;url&quot;&gt;&lt;a href=&quot;#url&quot; class=&quot;headerlink&quot; title=&quot;url&quot;&gt;&lt;/a&gt;url&lt;/h2&gt;&lt;p&gt;url模块用于处理与解析URL&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const url &amp;#x3D; require(&amp;#39;url&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之tty</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-tty.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-tty.html</id>
    <published>2020-02-07T09:45:24.000Z</published>
    <updated>2020-02-07T10:15:48.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h2><p>终端。</p><p>tty模块提供tty.ReadStream和tty.WriteStream类。<br>大多数情况下，没有必要或可能直接使用此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const tty &#x3D; require(&#39;tty&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>当Nodejs检测到它附加了文本终端TTY时，默认，process.stdin将被初始化为tty.ReadStream的一个示例，process.stdout和process.stderr将被初始化为tty.WriteStream的实例。<br>判断Nodejs是否在TTY上下文中运行的首选方法是检查process.stdout.isTTY属性的值是否为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;</span><br><span class="line">true</span><br><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="tty-ReadStream类"><a href="#tty-ReadStream类" class="headerlink" title="tty.ReadStream类"></a>tty.ReadStream类</h4><p>代表TTY的可读端。<br>正常情况中，processs.stdin将会使Nodejs进程中唯一的tty.ReadStream实例，并且没有理由创建其他的实例。</p><h5 id="readStream-isRaw"><a href="#readStream-isRaw" class="headerlink" title="readStream.isRaw"></a>readStream.isRaw</h5><p>布尔值，如果TTY当前配置为作为原始设备运行，则为true，默认false</p><h5 id="readStream-isTTY"><a href="#readStream-isTTY" class="headerlink" title="readStream.isTTY"></a>readStream.isTTY</h5><p>布尔值，对于tty.readStream实例始终为true。</p><h5 id="readStream-setRawMode-mode"><a href="#readStream-setRawMode-mode" class="headerlink" title="readStream.setRawMode(mode)"></a>readStream.setRawMode(mode)</h5><p>允许配置tty.ReadStream，使其作为原始设备运行。</p><h4 id="tty-WriteStream类"><a href="#tty-WriteStream类" class="headerlink" title="tty.WriteStream类"></a>tty.WriteStream类</h4><p>代表TTY的可写端。<br>在正常情况中，process.stdout和process.stdder将会是为nodejs进程创建的唯一的tty.WriteStream实例，并且没有理由创建其他的实例。</p><h5 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h5><p>只要writeStream.colums或writeStream.rows属性发生更改，就会触发resize事件。<br>调用时，没有参数传递给监听器回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.on(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;屏幕大小已经改变&#39;);</span><br><span class="line">  console.log(&#96;$&#123;process.stdout.columns&#125;x$&#123;process.stdout.rows&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="writeStream-clearLine-dir-callback"><a href="#writeStream-clearLine-dir-callback" class="headerlink" title="writeStream.clearLine(dir[,callback])"></a>writeStream.clearLine(dir[,callback])</h5><p>在dir标识的方向上清除此WriteStream的当前行。</p><h5 id="writeStream-clearScreenDown-callback"><a href="#writeStream-clearScreenDown-callback" class="headerlink" title="writeStream.clearScreenDown([callback])"></a>writeStream.clearScreenDown([callback])</h5><p>从当前光标向下清除此WriteStream。</p><h5 id="writeStream-columns"><a href="#writeStream-columns" class="headerlink" title="writeStream.columns"></a>writeStream.columns</h5><p>一个数字，指定TTY当前具有的列数。每当触发resize事件时，此属性都会更新。</p><h5 id="writeStream-cursorTo-x-y-callback"><a href="#writeStream-cursorTo-x-y-callback" class="headerlink" title="writeStream.cursorTo(x[,y][,callback])"></a>writeStream.cursorTo(x[,y][,callback])</h5><p>将writeStream的光标移动到指定的位置。</p><h5 id="writeStream-getColorDepth-env"><a href="#writeStream-getColorDepth-env" class="headerlink" title="writeStream.getColorDepth([env])"></a>writeStream.getColorDepth([env])</h5><p>使用此函数可检测终端支持的颜色。</p><h5 id="writeStream-getWindowSize"><a href="#writeStream-getWindowSize" class="headerlink" title="writeStream.getWindowSize()"></a>writeStream.getWindowSize()</h5><p>返回此writeStream对应的TTY的大小。</p><h5 id="writeStream-hasColors-count-env"><a href="#writeStream-hasColors-count-env" class="headerlink" title="writeStream.hasColors([count][,env])"></a>writeStream.hasColors([count][,env])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.hasColors();</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 16 种颜色。</span><br><span class="line">process.stdout.hasColors(256);</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 256 种颜色。</span><br><span class="line">process.stdout.hasColors(&#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 true。</span><br><span class="line">process.stdout.hasColors(2 ** 24, &#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 false (环境设置假设支持 2 ** 8 种颜色)。</span><br></pre></td></tr></table></figure><h5 id="writeStream-isTTY"><a href="#writeStream-isTTY" class="headerlink" title="writeStream.isTTY"></a>writeStream.isTTY</h5><p>布尔值，始终未true。</p><h5 id="writeStream-moveCursor-dx-dy-callback"><a href="#writeStream-moveCursor-dx-dy-callback" class="headerlink" title="writeStream.moveCursor(dx, dy[, callback])"></a>writeStream.moveCursor(dx, dy[, callback])</h5><p>将writeStream的光标相当于其当前位置移动。</p><h5 id="writeStream-rows"><a href="#writeStream-rows" class="headerlink" title="writeStream.rows"></a>writeStream.rows</h5><p>一个数字，指定TTY当前具有的行数。<br>每当触发resize事件时，此属性都会更新。</p><h4 id="tty-isatty-fd"><a href="#tty-isatty-fd" class="headerlink" title="tty.isatty(fd)"></a>tty.isatty(fd)</h4><p>如果给定的fd与TTY相关联，则tty.isatty(fd)返回true，否则返回false，包括fd不是非负整数时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tty&quot;&gt;&lt;a href=&quot;#tty&quot; class=&quot;headerlink&quot; title=&quot;tty&quot;&gt;&lt;/a&gt;tty&lt;/h2&gt;&lt;p&gt;终端。&lt;/p&gt;
&lt;p&gt;tty模块提供tty.ReadStream和tty.WriteStream类。&lt;br&gt;大多数情况下，没有必要或可能直接使用此模块。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const tty &amp;#x3D; require(&amp;#39;tty&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之trace_events</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-trace-events.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-trace-events.html</id>
    <published>2020-02-07T07:01:46.000Z</published>
    <updated>2020-02-07T09:44:36.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="trace-events"><a href="#trace-events" class="headerlink" title="trace_events"></a>trace_events</h2><p>跟踪事件。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const trace_events &#x3D; require(&#39;trace_events&#39;);</span><br><span class="line">const t1 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node&#39;, &#39;v8&#39;] &#125;);</span><br><span class="line">const t2 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node.perf&#39;, &#39;node&#39;] &#125;);</span><br><span class="line">t1.enable();</span><br><span class="line">t2.enable();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,node.perf,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br><span class="line"></span><br><span class="line">t2.disable(); &#x2F;&#x2F; Will only disable emission of the &#39;node.perf&#39; category</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;trace-events&quot;&gt;&lt;a href=&quot;#trace-events&quot; class=&quot;headerlink&quot; title=&quot;trace_events&quot;&gt;&lt;/a&gt;trace_events&lt;/h2&gt;&lt;p&gt;跟踪事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之tls</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-tls.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-tls.html</id>
    <published>2020-02-07T07:01:19.000Z</published>
    <updated>2020-02-08T08:14:59.018Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tls"><a href="#tls" class="headerlink" title="tls"></a>tls</h2><p>安全传输层。<br>tls模块是对安全传输层(TLS)及安全套接层(SSL)协议的实现，建立在OpenSSL的基础上。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const tls &#x3D; require(&#39;tls&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="TLS-SSL概念"><a href="#TLS-SSL概念" class="headerlink" title="TLS/SSL概念"></a>TLS/SSL概念</h4><p>TLS/SSL是公共/私人的密钥基础设施(PKI)。<br>大部分情况下，每个服务器和客户端都应该有一个私钥。</p><p>私钥有多种生成方式。<br>通过TLS/SSL，所有的服务器必须要一个证书。证书是相似于私钥的公钥，它由CA或者私钥签名，特别地，私钥拥有者所签名的被称为自签名。获取证书的第一步是生成一个证书申请文件(CSR)。</p><p>用OpenSSL能生成一个私钥的CSR文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -sha256 -key ryans-key.pem -out ryans-csr.pem</span><br></pre></td></tr></table></figure><p>CSR文件被生成以后，它既能被CA签名也能被用户自签名。用OpenSSL生成一个自签名证书的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -in ryans-csr.pem -signkey ryans-key.pem -out ryans-cert.pem</span><br></pre></td></tr></table></figure><p>证书被生成以后，它又能用来生成一个.pfx或.p12文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -in ryans-cert.pem -inkey ryans-key.pem \</span><br><span class="line">      -certfile ca-cert.pem -out ryans.pfx</span><br></pre></td></tr></table></figure><p>命令行参数：</p><ul><li>in：被签名的证书</li><li>inkey：有关的私钥</li><li>certifile：签入文件的证书串。</li></ul><h4 id="完全前向保密"><a href="#完全前向保密" class="headerlink" title="完全前向保密"></a>完全前向保密</h4><p>术语“前向保密”或“完全前向保密”是一中密钥协商方法。<br>通过这种方法，客户端与服务端在当前会话中，协商一个临时生成的密钥进行对称加密的密钥交换，<br>这意味着即使服务器端私钥发生泄漏，窃密者与攻击者也无法解密通信内容，除非他们能得到当前会话的临时密钥。</p><p>TLS/SSL握手时，使用完全前向即每次会话都会随机生成一个临时密钥对用于对称加密密钥协商(区别于每次会话都是用相同的密钥)。<br>实现这个技术的密钥交换算法称为“ephemeral”。</p><p>当前最常用的两种实现完全前向保密的算法：</p><ul><li>DHE - 使用临时密钥的Diffie Hellman密钥交换算法</li><li>ECDHE - 使用临时密钥的椭圆曲线Diffie Hellman密钥交换算法<br>使用临时密钥可能带来性能损失，因为密钥生成的过程十分消耗CPU计算性能。</li></ul><p>如需使用完全前向加密，例如使用tls模块的DHC算法，使用之前需要生成一个Diffie-Hellman参数并将其用dhparam声明在tls.createSecureContext()中。<br>如下展示如何用OpenSSL命令生成参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl dhparam -outform PEM -out dhparam.pem 2048</span><br></pre></td></tr></table></figure><p>如需使用ECDHE算法，则不需要生成Diffie-Hellman参数，因为可以使用默认的ECDHE曲线。</p><p>完全向前保密在TLSv1.2之前是可选的，但不是TLSv1.3的可选项，因为所有的TLSv1.3密码套件都使用ECDHE。</p><h4 id="ALPN和SNI"><a href="#ALPN和SNI" class="headerlink" title="ALPN和SNI"></a>ALPN和SNI</h4><h4 id="客户端发起的重协商攻击缓解"><a href="#客户端发起的重协商攻击缓解" class="headerlink" title="客户端发起的重协商攻击缓解"></a>客户端发起的重协商攻击缓解</h4><p>TLS协议允许客户端在TLS会话中进行协商，用于安全因素的考量。<br>不幸的是，会话重协商需要消耗大量的服务器端资源，这将导致服务器存在潜在的被DDoS攻击的可能。</p><p>为了减轻这个风险，限制每十分钟只能使用三次重协商，超过这个限制将会在tls.TLSSocket实例中产生一个error事件。这个限制是可配置的：</p><ul><li>tls.CLIENT_RENEG_LIMIT<number>指定重协商请求的次数限制，默认3</li><li>tls.CLIENT_RENEG_WINDOW<number>指定限制次数的生效时间段，默认600s<br>不应在末未充分理解其含义与影响的情况下修改上述参数。</li></ul><p>TLSv1.3不支持重协商。</p><h4 id="会话恢复"><a href="#会话恢复" class="headerlink" title="会话恢复"></a>会话恢复</h4><h4 id="修改默认的TLS加密组件"><a href="#修改默认的TLS加密组件" class="headerlink" title="修改默认的TLS加密组件"></a>修改默认的TLS加密组件</h4><p>NodeJs构造时包含了默认的TLS开启和关闭的加密组件。</p><h4 id="tls-Server类"><a href="#tls-Server类" class="headerlink" title="tls.Server类"></a>tls.Server类</h4><p>接受使用TLS或SSL的加密连接。</p><h5 id="keylog事件"><a href="#keylog事件" class="headerlink" title="keylog事件"></a>keylog事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const logFile &#x3D; fs.createWriteStream(&#39;&#x2F;tmp&#x2F;ssl-keys.log&#39;, &#123; flags: &#39;a&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">server.on(&#39;keylog&#39;, (line, tlsSocket) &#x3D;&gt; &#123;</span><br><span class="line">  if (tlsSocket.remoteAddress !&#x3D;&#x3D; &#39;...&#39;)</span><br><span class="line">    return; &#x2F;&#x2F; Only log keys for a particular IP</span><br><span class="line">  logFile.write(line);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="newSession事件"><a href="#newSession事件" class="headerlink" title="newSession事件"></a>newSession事件</h5><p>添加监听器后，监听器只在连接建立后生效。</p><h5 id="OCSPRequest事件"><a href="#OCSPRequest事件" class="headerlink" title="OCSPRequest事件"></a>OCSPRequest事件</h5><h5 id="resumeSession事件"><a href="#resumeSession事件" class="headerlink" title="resumeSession事件"></a>resumeSession事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const tlsSessionStore &#x3D; &#123;&#125;;</span><br><span class="line">server.on(&#39;newSession&#39;, (id, data, cb) &#x3D;&gt; &#123;</span><br><span class="line">  tlsSessionStore[id.toString(&#39;hex&#39;)] &#x3D; data;</span><br><span class="line">  cb();</span><br><span class="line">&#125;);</span><br><span class="line">server.on(&#39;resumeSession&#39;, (id, cb) &#x3D;&gt; &#123;</span><br><span class="line">  cb(null, tlsSessionStore[id.toString(&#39;hex&#39;)] || null);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="secureConnection事件"><a href="#secureConnection事件" class="headerlink" title="secureConnection事件"></a>secureConnection事件</h5><h5 id="tlsClientError事件"><a href="#tlsClientError事件" class="headerlink" title="tlsClientError事件"></a>tlsClientError事件</h5><h5 id="server-addContext-hostname-context"><a href="#server-addContext-hostname-context" class="headerlink" title="server.addContext(hostname, context)"></a>server.addContext(hostname, context)</h5><h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><h4 id="tls-TLSSocket类"><a href="#tls-TLSSocket类" class="headerlink" title="tls.TLSSocket类"></a>tls.TLSSocket类</h4><h5 id="new-tls-TLSSocket-socket-options"><a href="#new-tls-TLSSocket-socket-options" class="headerlink" title="new tls.TLSSocket(socket[, options])"></a>new tls.TLSSocket(socket[, options])</h5><h5 id="keylog事件-1"><a href="#keylog事件-1" class="headerlink" title="keylog事件"></a>keylog事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const logFile &#x3D; fs.createWriteStream(&#39;&#x2F;tmp&#x2F;ssl-keys.log&#39;, &#123; flags: &#39;a&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">tlsSocket.on(&#39;keylog&#39;, (line) &#x3D;&gt; logFile.write(line));</span><br></pre></td></tr></table></figure><h5 id="OCSPResponse事件"><a href="#OCSPResponse事件" class="headerlink" title="OCSPResponse事件"></a>OCSPResponse事件</h5><h5 id="secureConnect事件"><a href="#secureConnect事件" class="headerlink" title="secureConnect事件"></a>secureConnect事件</h5><h5 id="session事件"><a href="#session事件" class="headerlink" title="session事件"></a>session事件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tlsSocket.once(&#39;session&#39;, (session) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; The session can be used immediately or later.</span><br><span class="line">  tls.connect(&#123;</span><br><span class="line">    session: session,</span><br><span class="line">    &#x2F;&#x2F; Other connect options...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="tlsSocket-address"><a href="#tlsSocket-address" class="headerlink" title="tlsSocket.address()"></a>tlsSocket.address()</h5><h5 id="tlsSocket-authorizationError"><a href="#tlsSocket-authorizationError" class="headerlink" title="tlsSocket.authorizationError"></a>tlsSocket.authorizationError</h5><h5 id="tlsSocket-authorized"><a href="#tlsSocket-authorized" class="headerlink" title="tlsSocket.authorized"></a>tlsSocket.authorized</h5><h5 id="tlsSocket-disableRenegotiation"><a href="#tlsSocket-disableRenegotiation" class="headerlink" title="tlsSocket.disableRenegotiation()"></a>tlsSocket.disableRenegotiation()</h5><h5 id="tlsSocket-enableTrace"><a href="#tlsSocket-enableTrace" class="headerlink" title="tlsSocket.enableTrace()"></a>tlsSocket.enableTrace()</h5><h5 id="tlsSocket-encrypted"><a href="#tlsSocket-encrypted" class="headerlink" title="tlsSocket.encrypted"></a>tlsSocket.encrypted</h5><h5 id="tlsSocket-getCertificate"><a href="#tlsSocket-getCertificate" class="headerlink" title="tlsSocket.getCertificate()"></a>tlsSocket.getCertificate()</h5><h5 id="tlsSocket-getCipher"><a href="#tlsSocket-getCipher" class="headerlink" title="tlsSocket.getCipher()"></a>tlsSocket.getCipher()</h5><h5 id="tlsSocket-getephemeralKeyInfo"><a href="#tlsSocket-getephemeralKeyInfo" class="headerlink" title="tlsSocket.getephemeralKeyInfo()"></a>tlsSocket.getephemeralKeyInfo()</h5><h5 id="tlsSocket-getFinished"><a href="#tlsSocket-getFinished" class="headerlink" title="tlsSocket.getFinished()"></a>tlsSocket.getFinished()</h5><h5 id="tlsSocket-getPeerCertificate-detailed"><a href="#tlsSocket-getPeerCertificate-detailed" class="headerlink" title="tlsSocket.getPeerCertificate([detailed])"></a>tlsSocket.getPeerCertificate([detailed])</h5><h5 id="tlsSocket-getPeerFinished"><a href="#tlsSocket-getPeerFinished" class="headerlink" title="tlsSocket.getPeerFinished()"></a>tlsSocket.getPeerFinished()</h5><h5 id="tlsSocket-getProtocol"><a href="#tlsSocket-getProtocol" class="headerlink" title="tlsSocket.getProtocol()"></a>tlsSocket.getProtocol()</h5><h5 id="tlsSocket-getSession"><a href="#tlsSocket-getSession" class="headerlink" title="tlsSocket.getSession()"></a>tlsSocket.getSession()</h5><h5 id="tlsSocket-getSharedSigalgs"><a href="#tlsSocket-getSharedSigalgs" class="headerlink" title="tlsSocket.getSharedSigalgs()"></a>tlsSocket.getSharedSigalgs()</h5><h5 id="tlsSocket-getTLSTicket"><a href="#tlsSocket-getTLSTicket" class="headerlink" title="tlsSocket.getTLSTicket()"></a>tlsSocket.getTLSTicket()</h5><h5 id="tlsSocket-isSessionReused"><a href="#tlsSocket-isSessionReused" class="headerlink" title="tlsSocket.isSessionReused()"></a>tlsSocket.isSessionReused()</h5><h5 id="tlsSocket-localAddress"><a href="#tlsSocket-localAddress" class="headerlink" title="tlsSocket.localAddress"></a>tlsSocket.localAddress</h5><h5 id="tlsSocket-localPort"><a href="#tlsSocket-localPort" class="headerlink" title="tlsSocket.localPort"></a>tlsSocket.localPort</h5><h5 id="tlsSocket-remoteAddress"><a href="#tlsSocket-remoteAddress" class="headerlink" title="tlsSocket.remoteAddress"></a>tlsSocket.remoteAddress</h5><h5 id="tlsSocket-remotefamily"><a href="#tlsSocket-remotefamily" class="headerlink" title="tlsSocket.remotefamily"></a>tlsSocket.remotefamily</h5><h5 id="tlsSocket-remotePort"><a href="#tlsSocket-remotePort" class="headerlink" title="tlsSocket.remotePort"></a>tlsSocket.remotePort</h5><h5 id="tlsSocket-renegotiate-options-callback"><a href="#tlsSocket-renegotiate-options-callback" class="headerlink" title="tlsSocket.renegotiate(options, callback)"></a>tlsSocket.renegotiate(options, callback)</h5><h5 id="tlsSocket-setMaxSendFragment-size"><a href="#tlsSocket-setMaxSendFragment-size" class="headerlink" title="tlsSocket.setMaxSendFragment(size)"></a>tlsSocket.setMaxSendFragment(size)</h5><h5 id="tls-checkServerdentity-hostname-cert"><a href="#tls-checkServerdentity-hostname-cert" class="headerlink" title="tls.checkServerdentity(hostname, cert)"></a>tls.checkServerdentity(hostname, cert)</h5><h5 id="tls-connect-options-callback"><a href="#tls-connect-options-callback" class="headerlink" title="tls.connect(options[, callback])"></a>tls.connect(options[, callback])</h5><h5 id="tls-connect-path-options-callback"><a href="#tls-connect-path-options-callback" class="headerlink" title="tls.connect(path[, options][, callback])"></a>tls.connect(path[, options][, callback])</h5><h5 id="tls-connect-port-host-options-callback"><a href="#tls-connect-port-host-options-callback" class="headerlink" title="tls.connect(port[, host][, options][, callback])"></a>tls.connect(port[, host][, options][, callback])</h5><h5 id="tls-createSecureContext-options"><a href="#tls-createSecureContext-options" class="headerlink" title="tls.createSecureContext([options])"></a>tls.createSecureContext([options])</h5><h5 id="tls-createServer-options-secureConnectionListener"><a href="#tls-createServer-options-secureConnectionListener" class="headerlink" title="tls.createServer([options][, secureConnectionListener])"></a>tls.createServer([options][, secureConnectionListener])</h5><h5 id="tls-getCophers"><a href="#tls-getCophers" class="headerlink" title="tls.getCophers()"></a>tls.getCophers()</h5><h5 id="tls-rootCertificates"><a href="#tls-rootCertificates" class="headerlink" title="tls.rootCertificates"></a>tls.rootCertificates</h5><h5 id="tls-DEFAULT-ECDH-CURVE"><a href="#tls-DEFAULT-ECDH-CURVE" class="headerlink" title="tls.DEFAULT_ECDH_CURVE"></a>tls.DEFAULT_ECDH_CURVE</h5><h5 id="tls-DEFAULT-MAX-VERSION"><a href="#tls-DEFAULT-MAX-VERSION" class="headerlink" title="tls.DEFAULT_MAX_VERSION"></a>tls.DEFAULT_MAX_VERSION</h5><h5 id="tls-DEFAULT-MIN-VERSION"><a href="#tls-DEFAULT-MIN-VERSION" class="headerlink" title="tls.DEFAULT_MIN_VERSION"></a>tls.DEFAULT_MIN_VERSION</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tls&quot;&gt;&lt;a href=&quot;#tls&quot; class=&quot;headerlink&quot; title=&quot;tls&quot;&gt;&lt;/a&gt;tls&lt;/h2&gt;&lt;p&gt;安全传输层。&lt;br&gt;tls模块是对安全传输层(TLS)及安全套接层(SSL)协议的实现，建立在OpenSSL的基础上。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const tls &amp;#x3D; require(&amp;#39;tls&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之timer</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-timer.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-timer.html</id>
    <published>2020-02-06T14:11:32.000Z</published>
    <updated>2020-02-07T07:00:52.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>定时器。</p><p>timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。<br>因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。</p><p>Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。</p><a id="more"></a><h4 id="Immediate类"><a href="#Immediate类" class="headerlink" title="Immediate类"></a>Immediate类</h4><p>此对象在内部创建，并从setImmediate()返回。可以传给clearImmediate()以取消计划的操作。</p><p>默认，当预定immediate时，只要immediate激活，Nodejs事件循环将继续运行。<br>setImmediate()返回的Immediate对象导出immediate.ref()和immediate.unref()函数，这些函数可用于控制此默认行为。</p><h5 id="immediate-hasRef"><a href="#immediate-hasRef" class="headerlink" title="immediate.hasRef()"></a>immediate.hasRef()</h5><p>如果未true，则Immediate对象将会使Nodejs事件循环保持活动状态。</p><h5 id="immediate-ref"><a href="#immediate-ref" class="headerlink" title="immediate.ref()"></a>immediate.ref()</h5><p>调用时，只要immediate处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用immediate.ref()将无效。</p><p>默认，所有Immediate对象都是ref的，通常不需要调用Immediate.ref()，除非之前调用了Immediate.unref()</p><h5 id="immediate-unref"><a href="#immediate-unref" class="headerlink" title="immediate.unref()"></a>immediate.unref()</h5><p>调用时，活动的Immediate对象不需要Nodejs事件循环保持活动状态。如果没有其他活动保持事件循环运行，<br>则进程可以在调用Immediate对象的回调之前推出。多次调用Immediate.unref()将无效。</p><h4 id="Timeout类"><a href="#Timeout类" class="headerlink" title="Timeout类"></a>Timeout类</h4><p>此对象在内部创建，并从setTimeout()和setInterval()返回。<br>它可以传给clearTimeout()或clearInterval()以取消计划的操作。</p><p>默认情况，当使用setTimeout()或setInterval()预定定时器时，只要定时器处于活动状态，<br>Nodejs事件循环将继续运行。这些函数返回的每个Timeout对象都会导出timeout.ref()和timeout.unref()函数，<br>这些函数可用于控制此默认行为。</p><h5 id="timeout-hasRef"><a href="#timeout-hasRef" class="headerlink" title="timeout.hasRef()"></a>timeout.hasRef()</h5><p>如果为true，则timeout对象将会使Nodejs事件循环保持活动状态。</p><h5 id="timeout-ref"><a href="#timeout-ref" class="headerlink" title="timeout.ref()"></a>timeout.ref()</h5><p>调用时，只要timeout处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用timeout.ref()将无效。</p><p>默认，所有Timeout对象都是ref的，通常不需要调用timeout.ref()，除非之前调用了timeout.unref()</p><h5 id="timeout-refresh"><a href="#timeout-refresh" class="headerlink" title="timeout.refresh()"></a>timeout.refresh()</h5><p>将定时器的开始时间设置为当前时间，并重新安排定时器以在之前指定的持续时间内调用其回调，<br>并将其调整为当前时间，这对于在不分配新JavaScript对象的情况下刷新定时器非常有用。</p><h5 id="timeout-unref"><a href="#timeout-unref" class="headerlink" title="timeout.unref()"></a>timeout.unref()</h5><p>调用时，活动的Timeout对象不需要Nodejs事件循环保持活动状态。<br>如果没有其他活动保持事件循环运行，则进程可以在调用Timeout对象的回调之前退出。<br>多次调用timeout.unref()将无效。</p><p>调用timeout.unref()会创建一个内部定时器，它将唤醒Nodejs事件循环。<br>创建太多这些定时器可能会对Nodejs应用程序的性能产生负面影响。</p><h4 id="预定定时器"><a href="#预定定时器" class="headerlink" title="预定定时器"></a>预定定时器</h4><h5 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h5><p>预定在I/O事件的回调之后立即执行的callback。</p><p>当多次调用setImmediate()时，callback函数将按照创建它们的顺序排队等待执行。<br>每次事件循环迭代都会处理整个回调队列。<br>如果立即定时器是从正在执行的回调排入队列，则直到下一次事件循环迭代才会触发。</p><p>如果callback不是函数，则抛出TypeError</p><h5 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h5><p>预定每隔delay毫秒重复执行callback。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h5 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h5><p>预定在delay毫秒之后执行一次性的callback。</p><p>可能不会精确的在delay毫秒时调用callback。<br>Nodejs不保证回调被触发的确切时间，也不保证他们的顺序。<br>回调会在尽可能接近指定的时间调用。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h4 id="取消定时器"><a href="#取消定时器" class="headerlink" title="取消定时器"></a>取消定时器</h4><p>setImmediate()/setInterval()/setTimeout()方法各自返回表示预定的定时器的对象。<br>它们可用于取消定时器并防止其触发。</p><p>无法取消使用setImmediate()/setTimeout()的Promise化的变体创建的定时器。</p><h5 id="clearImmediate-immediate"><a href="#clearImmediate-immediate" class="headerlink" title="clearImmediate(immediate)"></a>clearImmediate(immediate)</h5><p>取消由setImmediate()创建的Immediate对象。</p><h5 id="clearInterval-timeout"><a href="#clearInterval-timeout" class="headerlink" title="clearInterval(timeout)"></a>clearInterval(timeout)</h5><p>取消由setInterval()创建的Timeout对象。</p><h5 id="clearTimeout-timeout"><a href="#clearTimeout-timeout" class="headerlink" title="clearTimeout(timeout)"></a>clearTimeout(timeout)</h5><p>取消由setTimeout()创建的Timeout对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timer&quot;&gt;&lt;a href=&quot;#timer&quot; class=&quot;headerlink&quot; title=&quot;timer&quot;&gt;&lt;/a&gt;timer&lt;/h2&gt;&lt;p&gt;定时器。&lt;/p&gt;
&lt;p&gt;timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。&lt;br&gt;因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。&lt;/p&gt;
&lt;p&gt;Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之string_decoder</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-string-decoder.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-string-decoder.html</id>
    <published>2020-02-06T14:04:27.000Z</published>
    <updated>2020-02-06T14:11:06.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string-decoder"><a href="#string-decoder" class="headerlink" title="string_decoder"></a>string_decoder</h2><p>字符串解码器。</p><p>提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);</span><br><span class="line">const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);</span><br><span class="line"></span><br><span class="line">const cent &#x3D; Buffer.from([0xC2, 0xA2]);</span><br><span class="line">console.log(decoder.write(cent));</span><br><span class="line"></span><br><span class="line">const euro &#x3D; Buffer.from([0xE2, 0x82, 0xAC]);</span><br><span class="line">console.log(decoder.write(euro));</span><br></pre></td></tr></table></figure><p>将Buffer实例写入StringDecoder实例时，将使用内部缓冲区来确保已解码的字符串不包含任何不完整的多字节字符。它们保存在缓冲区中，直到下一次调用stringDecoder.write()或调用stringDecoder.end()为止。</p><h4 id="StringDecoder类"><a href="#StringDecoder类" class="headerlink" title="StringDecoder类"></a>StringDecoder类</h4><h5 id="new-StringDecoder-encoding"><a href="#new-StringDecoder-encoding" class="headerlink" title="new StringDecoder([encoding])"></a>new StringDecoder([encoding])</h5><p>创建一个新的StringDecoder实例。</p><h5 id="stringDecoder-end-buffer"><a href="#stringDecoder-end-buffer" class="headerlink" title="stringDecoder.end([buffer])"></a>stringDecoder.end([buffer])</h5><p>以字符串形式返回存储在内部缓冲区中的任何剩余输入。 表示不完整的 UTF-8 和 UTF-16 字符的字节将替换为适合字符编码的替换字符。</p><p>如果提供了 buffer 参数，则在返回剩余的输入之前再最后一次调用 stringDecoder.write()</p><h5 id="stringDecoder-write-buffer"><a href="#stringDecoder-write-buffer" class="headerlink" title="stringDecoder.write(buffer)"></a>stringDecoder.write(buffer)</h5><p>返回一个已解码的字符串，确保在返回的字符串不包含 Buffer、 TypedArray 或 DataView 末尾的任何不完整的多字节字符，并将其存储在内部缓冲区中，以便下次调用 stringDecoder.write() 或 stringDecoder.end()。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string-decoder&quot;&gt;&lt;a href=&quot;#string-decoder&quot; class=&quot;headerlink&quot; title=&quot;string_decoder&quot;&gt;&lt;/a&gt;string_decoder&lt;/h2&gt;&lt;p&gt;字符串解码器。&lt;/p&gt;
&lt;p&gt;提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const &amp;#123; StringDecoder &amp;#125; &amp;#x3D; require(&amp;#39;string_decoder&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
</feed>
