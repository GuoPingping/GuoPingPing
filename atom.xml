<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to my-blog</title>
  <icon>https://www.gravatar.com/avatar/e3033211f497dbeb0d82dedb049dddbd</icon>
  <subtitle>关于学习 关于成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://gpp-note.top/"/>
  <updated>2020-02-07T10:19:46.773Z</updated>
  <id>http://gpp-note.top/</id>
  
  <author>
    <name>Guopp</name>
    <email>2474986040@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NodeJs之zlib</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-zlib.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-zlib.html</id>
    <published>2020-02-07T10:19:32.000Z</published>
    <updated>2020-02-07T10:19:46.773Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之worker_threads</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-worker-threads.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-worker-threads.html</id>
    <published>2020-02-07T10:18:58.000Z</published>
    <updated>2020-02-07T15:03:01.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="worker-threads"><a href="#worker-threads" class="headerlink" title="worker_threads"></a>worker_threads</h2><p>工作线程。<br>worker_threads模块允许使用并行的执行JavaScript的线程</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const worker &#x3D; require(&#39;worker_threads&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;worker-threads&quot;&gt;&lt;a href=&quot;#worker-threads&quot; class=&quot;headerlink&quot; title=&quot;worker_threads&quot;&gt;&lt;/a&gt;worker_threads&lt;/h2&gt;&lt;p&gt;工作线程。&lt;br&gt;worker_threads模块允许使用并行的执行JavaScript的线程&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const worker &amp;#x3D; require(&amp;#39;worker_threads&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之vm</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-vm.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-vm.html</id>
    <published>2020-02-07T10:18:21.000Z</published>
    <updated>2020-02-07T15:01:39.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vm"><a href="#vm" class="headerlink" title="vm"></a>vm</h2><p>虚拟机。</p><p>vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。<br>vm模块不是一个安全的虚拟机。<br>不要用它来运行不受信任的代码。</p><p>JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。</p><p>一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。</p><p>可以通过上下文隔离化一个沙箱对象来提供上下文。<br>沙盒代码将沙盒中的任何属性视为全局对象。<br>由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; x: 2 &#125;;</span><br><span class="line">vm.createContext(sandbox); &#x2F;&#x2F; 上下文隔离化一个沙盒。</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#39;x +&#x3D; 40; var y &#x3D; 17;&#39;;</span><br><span class="line">&#x2F;&#x2F; &#96;x&#96; and &#96;y&#96; 是沙盒环境中的全局变量。</span><br><span class="line">&#x2F;&#x2F; 最初，x 的值为 2，因为这是 sandbox.x 的值。</span><br><span class="line">vm.runInContext(code, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(sandbox.x); &#x2F;&#x2F; 42</span><br><span class="line">console.log(sandbox.y); &#x2F;&#x2F; 17</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; 1; y 没有定义。</span><br></pre></td></tr></table></figure><h4 id="vm-Script类"><a href="#vm-Script类" class="headerlink" title="vm.Script类"></a>vm.Script类</h4><p>vm.Script类型的实例包含若干预编译的脚本，这些脚本能够在特定的沙箱（或上下文）中被运行。</p><h5 id="new-vm-Script-code-options"><a href="#new-vm-Script-code-options" class="headerlink" title="new vm.Script(code[, options])"></a>new vm.Script(code[, options])</h5><p>如果options是字符串，则它指定文件名。</p><p>创建一个新的vm.Script对象只编译code但不会执行它。<br>编译过的vm.Script此后可以被多次执行。<br>code是不绑定于任何全局对象的，相反，它仅仅绑定于每次执行它的对象。</p><h5 id="script-createCachedData"><a href="#script-createCachedData" class="headerlink" title="script.createCachedData()"></a>script.createCachedData()</h5><p>创建一个可以被Script构造函数中cachedData选项使用的代码缓存，返回Buffer。<br>可以在任何时候不限次数的调用该方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const script &#x3D; new vm.Script(&#96;</span><br><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const x &#x3D; add(1, 2);</span><br><span class="line">&#96;);</span><br><span class="line"></span><br><span class="line">const cacheWithoutX &#x3D; script.createCachedData();</span><br><span class="line"></span><br><span class="line">script.runInThisContext();</span><br><span class="line"></span><br><span class="line">const cacheWithX &#x3D; script.createCachedData();</span><br></pre></td></tr></table></figure><h5 id="script-runInContext-contextifiedSandbox-options"><a href="#script-runInContext-contextifiedSandbox-options" class="headerlink" title="script.runInContext(contextifiedSandbox[, options])"></a>script.runInContext(contextifiedSandbox[, options])</h5><p>在指定的contextifiedSandbox中执行vm.Script对象中被编译后的代码并返回结果。<br>被执行的代码无法获取本地作用域。</p><h5 id="script-runInNewContext-sandbox-options"><a href="#script-runInNewContext-sandbox-options" class="headerlink" title="script.runInNewContext([sandbox[, options]])"></a>script.runInNewContext([sandbox[, options]])</h5><p>首先给指定的sandbox提供一个隔离的上下文，再在此上下文执行vm.Script中被编译的代码，最后返回结果。运行中的代码无法获取本地作用域。</p><h5 id="script-runInThisContext-options"><a href="#script-runInThisContext-options" class="headerlink" title="script.runInThisContext([options])"></a>script.runInThisContext([options])</h5><p>在指定的global对象的上下文中执行vm.Script对象里被编译的代码并返回结果。被执行的代码无法获取本地作用域，但能获取global对象。</p><h4 id="vm-SourceTextModule类"><a href="#vm-SourceTextModule类" class="headerlink" title="vm.SourceTextModule类"></a>vm.SourceTextModule类</h4><h5 id="new-vm-SourceTextModule-code-options"><a href="#new-vm-SourceTextModule-code-options" class="headerlink" title="new vm.SourceTextModule(code[, options])"></a>new vm.SourceTextModule(code[, options])</h5><h5 id="module-dependencySpecifiers"><a href="#module-dependencySpecifiers" class="headerlink" title="module.dependencySpecifiers"></a>module.dependencySpecifiers</h5><h5 id="module-error"><a href="#module-error" class="headerlink" title="module.error"></a>module.error</h5><h5 id="module-evaluate-options"><a href="#module-evaluate-options" class="headerlink" title="module.evaluate([options])"></a>module.evaluate([options])</h5><h5 id="module-link-linker"><a href="#module-link-linker" class="headerlink" title="module.link(linker)"></a>module.link(linker)</h5><h5 id="module-namespace"><a href="#module-namespace" class="headerlink" title="module.namespace"></a>module.namespace</h5><h5 id="module-status"><a href="#module-status" class="headerlink" title="module.status"></a>module.status</h5><h5 id="module-identifier"><a href="#module-identifier" class="headerlink" title="module.identifier"></a>module.identifier</h5><h4 id="vm-compileFunction-code-params-options"><a href="#vm-compileFunction-code-params-options" class="headerlink" title="vm.compileFunction(code[, params[, options]])"></a>vm.compileFunction(code[, params[, options]])</h4><p>将给定的代码编译到提供的上下文/沙箱中（如果没有提供上下文，则使用当前上下文），并返回包装了给定params的函数。</p><h4 id="vm-createContext-sandbox-options"><a href="#vm-createContext-sandbox-options" class="headerlink" title="vm.createContext([sandbox[, options]])"></a>vm.createContext([sandbox[, options]])</h4><p>给定一个sandbox对象，vm.createContext()会设置此沙盒，从而让它具备在vm.runInContext()或者script.runInContext()中被使用的能力。对于此二方法中所调用的脚本，他们的全局对象不仅拥有我们提供的sandbox对象的所有属性，同时还有任何全局对象所拥有的属性。对于这些脚本之外的所有代码，他们的全局变量将保持不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">global.globalVar &#x3D; 3;</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(sandbox)); &#x2F;&#x2F; &#123; globalVar: 2 &#125;</span><br><span class="line"></span><br><span class="line">console.log(util.inspect(globalVar)); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure><p>如果未提供sanbox或传入undefined，那么会返回一个全新的空的上下文隔离化后的sandbox对象。</p><p>vm.createContext()主要是用于创建一个能运行的多个脚本的沙盒。</p><h4 id="vm-isContext-sandbox"><a href="#vm-isContext-sandbox" class="headerlink" title="vm.isContext(sandbox)"></a>vm.isContext(sandbox)</h4><p>当给定的sanbox对象已经被vm.createContext()上下文隔离化，则返回true。</p><h4 id="vm-runInContext-code-contextifiedSandbox-options"><a href="#vm-runInContext-code-contextifiedSandbox-options" class="headerlink" title="vm.runInContext(code, contextifiedSandbox[, options])"></a>vm.runInContext(code, contextifiedSandbox[, options])</h4><p>vm.runInContext()方法会编译code，然后在指定的contextifiedSandbox的上下文里执行它并返回其结果。被执行的代码无法获取本地作用域。contextifiedSandbox必须是事先被vm.createContext()方法上下文隔离化过得对象。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123; globalVar: 1 &#125;;</span><br><span class="line">vm.createContext(sandbox);</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; ++i) &#123;</span><br><span class="line">  vm.runInContext(&#39;globalVar *&#x3D; 2;&#39;, sandbox);</span><br><span class="line">&#125;</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; globalVar: 1024 &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInNewContext-code-sanbox-options"><a href="#vm-runInNewContext-code-sanbox-options" class="headerlink" title="vm.runInNewContext(code[, sanbox[, options]])"></a>vm.runInNewContext(code[, sanbox[, options]])</h4><p>vm.runInNewContext()首先给指定的sanbox（若为undefined，则会新建一个sandbox）提供一个隔离的上下文，再在此上下文中执行编译的code，最后返回结果。<br>运行中的代码无法获取本地作用域。</p><p>如果options是字符串，则它指定文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const util &#x3D; require(&#39;util&#39;);</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const sandbox &#x3D; &#123;</span><br><span class="line">  animal: &#39;cat&#39;,</span><br><span class="line">  count: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vm.runInNewContext(&#39;count +&#x3D; 1; name &#x3D; &quot;kitty&quot;&#39;, sandbox);</span><br><span class="line">console.log(util.inspect(sandbox));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; &#123; animal: &#39;cat&#39;, count: 3, name: &#39;kitty&#39; &#125;</span><br></pre></td></tr></table></figure><h4 id="vm-runInThisContext-code-options"><a href="#vm-runInThisContext-code-options" class="headerlink" title="vm.runInThisContext(code[, options])"></a>vm.runInThisContext(code[, options])</h4><p>vm.runInThisContext()在当前的global对象的上下文中编译并执行code，最后返回结果。<br>运行中的代码无法获取本地作用域，但可以获取当前的global对象。</p><p>如果options是字符串，则它指定文件名。</p><h4 id="示例：在VM中运行HTTP-Server"><a href="#示例：在VM中运行HTTP-Server" class="headerlink" title="示例：在VM中运行HTTP Server"></a>示例：在VM中运行HTTP Server</h4><p>在私用script.runInThisContext()或者vm.runInThisContext()时，目标代码是在当前的V8quanju对象的上下文中执行的。被传入此虚拟机上下文的目标代码会有自己独立的作用域。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">const vm &#x3D; require(&#39;vm&#39;);</span><br><span class="line"></span><br><span class="line">const code &#x3D; &#96;</span><br><span class="line">((require) &#x3D;&gt; &#123;</span><br><span class="line">  const http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">  http.createServer((request, response) &#x3D;&gt; &#123;</span><br><span class="line">    response.writeHead(200, &#123; &#39;Content-Type&#39;: &#39;text&#x2F;plain&#39; &#125;);</span><br><span class="line">    response.end(&#39;你好世界\\n&#39;);</span><br><span class="line">  &#125;).listen(8124);</span><br><span class="line"></span><br><span class="line">  console.log(&#39;服务器运行在 http:&#x2F;&#x2F;127.0.0.1:8124&#x2F;&#39;);</span><br><span class="line">&#125;)&#96;;</span><br><span class="line"></span><br><span class="line">vm.runInThisContext(code)(require);</span><br></pre></td></tr></table></figure><h4 id="上下文隔离化一个对象意味着什么？"><a href="#上下文隔离化一个对象意味着什么？" class="headerlink" title="上下文隔离化一个对象意味着什么？"></a>上下文隔离化一个对象意味着什么？</h4><p>所有用Nodejs所运行的JavaScript代码都是在一个上下文的作用域中被执行的。根据V8嵌入式指南：</p><blockquote><p>在V8中，一个上下文是一个执行环境，它允许分离的，无关的JavaScript应用在一个V8的单例中被运行。<br>必须明确的指定用于运行所有JavaScript代码的上下文。</p></blockquote><p>当调用vm.createContext()时，传入的sanbox对象在底层会和一个新的V8上下文实例联系上。<br>这个V8上下文在一个隔离的全局环境中，使用vm模块的方法运行code。<br>创建V8上下文和使之联系上sanbox的过程在此文档中被称作为“上下文隔离化”sandbox。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vm&quot;&gt;&lt;a href=&quot;#vm&quot; class=&quot;headerlink&quot; title=&quot;vm&quot;&gt;&lt;/a&gt;vm&lt;/h2&gt;&lt;p&gt;虚拟机。&lt;/p&gt;
&lt;p&gt;vm模块提供了在V8虚拟机上下文中编译和运行代码的一系列API。&lt;br&gt;vm模块不是一个安全的虚拟机。&lt;br&gt;不要用它来运行不受信任的代码。&lt;/p&gt;
&lt;p&gt;JavaScript代码可以被编译并立即运行，也可以编译、保存，以后再运行。&lt;/p&gt;
&lt;p&gt;一个常见的场景是在沙盒中运行代码。沙盒中的代码使用不同的V8上下文，这以为着它具有与其余代码不同的全局对象。&lt;/p&gt;
&lt;p&gt;可以通过上下文隔离化一个沙箱对象来提供上下文。&lt;br&gt;沙盒代码将沙盒中的任何属性视为全局对象。&lt;br&gt;由沙盒代码引起的任何全局变量的更改都将反应到沙盒对象中。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之V8</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-V8.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-V8.html</id>
    <published>2020-02-07T10:17:54.000Z</published>
    <updated>2020-02-07T14:15:54.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="v8"><a href="#v8" class="headerlink" title="v8"></a>v8</h2><p>V8引擎。</p><p>v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const v8 &#x3D; require(&#39;v8&#39;)</span><br></pre></td></tr></table></figure><p>API和实现随时可能发生变化。</p><a id="more"></a><h4 id="v8-cachedDataVersionTag"><a href="#v8-cachedDataVersionTag" class="headerlink" title="v8.cachedDataVersionTag()"></a>v8.cachedDataVersionTag()</h4><p>返回一个整数，表示从V8版本、命令行标志、以及检测到的CPU特性派生的版本标记。<br>这对于判断vm.Script的cachedData buffer是否与此V8实例兼容非常有用。</p><h4 id="v8-getHeapSpaceStatistics"><a href="#v8-getHeapSpaceStatistics" class="headerlink" title="v8.getHeapSpaceStatistics()"></a>v8.getHeapSpaceStatistics()</h4><p>返回有关的V8堆空间的统计信息，即组成V8堆的片段。<br>由于统计信息是通过V8的GetHeapSpaceStatistics函数提供的，因此可以保证堆空间的排序以及堆控件的可用性，并且可以从一个V8版本更改为下一个版本。</p><h4 id="v8-getHeapSnapshot"><a href="#v8-getHeapSnapshot" class="headerlink" title="v8.getHeapSnapshot()"></a>v8.getHeapSnapshot()</h4><p>生成当前V8堆的快照，并返回可读流，该可读流用于读取JSON序列化表示。<br>此JSON流格式旨在与Chrome DevTools等工具一起使用。<br>JSON模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const stream &#x3D; v8.getHeapSnapshot();</span><br><span class="line">stream.pipe(process.stdout);</span><br></pre></td></tr></table></figure><h4 id="v8-getHeapStatistics"><a href="#v8-getHeapStatistics" class="headerlink" title="v8.getHeapStatistics()"></a>v8.getHeapStatistics()</h4><h4 id="v8-getHeapCodeStatistics"><a href="#v8-getHeapCodeStatistics" class="headerlink" title="v8.getHeapCodeStatistics()"></a>v8.getHeapCodeStatistics()</h4><p>返回一下属性的对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  code_and_metadata_size: 212208,</span><br><span class="line">  bytecode_and_metadata_size: 161368,</span><br><span class="line">  external_script_source_size: 1410794</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="v8-setFlagsFromString-flags"><a href="#v8-setFlagsFromString-flags" class="headerlink" title="v8.setFlagsFromString(flags)"></a>v8.setFlagsFromString(flags)</h4><p>该方法可以用于以编程方式设置V8de命令行标志。<br>虚拟机启动后更改设置可能会导致不可预测的行为，包括崩溃和数据丢失，或者它可能根本就什么都不做。</p><p>可以通过运行node –v8-options来检查可用于nodejs版本的V8选项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 将 GC 事件打印到 stdout 一分钟。</span><br><span class="line">const v8 &#x3D; require(&#39;v8&#39;);</span><br><span class="line">v8.setFlagsFromString(&#39;--trace_gc&#39;);</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; v8.setFlagsFromString(&#39;--notrace_gc&#39;); &#125;, 60e3);</span><br></pre></td></tr></table></figure><h4 id="v8-writeHeapSnapshot-filename"><a href="#v8-writeHeapSnapshot-filename" class="headerlink" title="v8.writeHeapSnapshot([filename])"></a>v8.writeHeapSnapshot([filename])</h4><p>生成当前v8堆的快照并将其写入Json文件。<br>此文件旨在与Chrome DevTools等工具一起使用。<br>Json模式未记录且特定于V8引擎，并且可能从V8的一个版本更改为下一个版本。</p><p>堆快照特定于单个V8隔离。<br>使用工作线程时，从主线程生成的堆快照将不包含有关工作线程的任何信息，反之亦然。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const &#123; writeHeapSnapshot &#125; &#x3D; require(&#39;v8&#39;);</span><br><span class="line">const &#123;</span><br><span class="line">  Worker,</span><br><span class="line">  isMainThread,</span><br><span class="line">  parentPort</span><br><span class="line">&#125; &#x3D; require(&#39;worker_threads&#39;);</span><br><span class="line"></span><br><span class="line">if (isMainThread) &#123;</span><br><span class="line">  const worker &#x3D; new Worker(__filename);</span><br><span class="line"></span><br><span class="line">  worker.once(&#39;message&#39;, (filename) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#96;工作线程的堆转储: $&#123;filename&#125;&#96;);</span><br><span class="line">    &#x2F;&#x2F; 获取主线程的堆转储。</span><br><span class="line">    console.log(&#96;主线程的堆转储: $&#123;writeHeapSnapshot()&#125;&#96;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 通知工作线程创建一个堆转储。</span><br><span class="line">  worker.postMessage(&#39;heapdump&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  parentPort.once(&#39;message&#39;, (message) &#x3D;&gt; &#123;</span><br><span class="line">    if (message &#x3D;&#x3D;&#x3D; &#39;heapdump&#39;) &#123;</span><br><span class="line">      &#x2F;&#x2F; 为工作线程生成一个堆转储，并返回文件名到父线程。</span><br><span class="line">      parentPort.postMessage(writeHeapSnapshot());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="序列化的API"><a href="#序列化的API" class="headerlink" title="序列化的API"></a>序列化的API</h4><h5 id="v8-serialize-value"><a href="#v8-serialize-value" class="headerlink" title="v8.serialize(value)"></a>v8.serialize(value)</h5><h5 id="v8-deserialize-buffer"><a href="#v8-deserialize-buffer" class="headerlink" title="v8.deserialize(buffer)"></a>v8.deserialize(buffer)</h5><h5 id="v8-Serializer类"><a href="#v8-Serializer类" class="headerlink" title="v8.Serializer类"></a>v8.Serializer类</h5><h6 id="new-Serializer"><a href="#new-Serializer" class="headerlink" title="new Serializer()"></a>new Serializer()</h6><h6 id="serializer-writeHeader"><a href="#serializer-writeHeader" class="headerlink" title="serializer.writeHeader()"></a>serializer.writeHeader()</h6><h6 id="serializer-releaseBuffer"><a href="#serializer-releaseBuffer" class="headerlink" title="serializer.releaseBuffer()"></a>serializer.releaseBuffer()</h6><h6 id="serializer-transferArrayBuffer-id-arrayBuffer"><a href="#serializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="serializer.transferArrayBuffer(id, arrayBuffer)"></a>serializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="serializer-writeUint32-value"><a href="#serializer-writeUint32-value" class="headerlink" title="serializer.writeUint32(value)"></a>serializer.writeUint32(value)</h6><h6 id="serializer-writeUint64-hi-Io"><a href="#serializer-writeUint64-hi-Io" class="headerlink" title="serializer.writeUint64(hi, Io)"></a>serializer.writeUint64(hi, Io)</h6><h6 id="serializer-writeDouble-value"><a href="#serializer-writeDouble-value" class="headerlink" title="serializer.writeDouble(value)"></a>serializer.writeDouble(value)</h6><h6 id="serializer-writeRawBytes-buffer"><a href="#serializer-writeRawBytes-buffer" class="headerlink" title="serializer.writeRawBytes(buffer)"></a>serializer.writeRawBytes(buffer)</h6><h6 id="serializer-writeHostObject-object"><a href="#serializer-writeHostObject-object" class="headerlink" title="serializer._writeHostObject(object)"></a>serializer._writeHostObject(object)</h6><h6 id="serializer-getDataCloneError-message"><a href="#serializer-getDataCloneError-message" class="headerlink" title="serializer._getDataCloneError(message)"></a>serializer._getDataCloneError(message)</h6><h6 id="serializer-getSharedArrayBufferId-sharedArrayBuffer"><a href="#serializer-getSharedArrayBufferId-sharedArrayBuffer" class="headerlink" title="serializer._getSharedArrayBufferId(sharedArrayBuffer)"></a>serializer._getSharedArrayBufferId(sharedArrayBuffer)</h6><h6 id="serializer-setTreatArrayBufferViewsAsHostObjects-flag"><a href="#serializer-setTreatArrayBufferViewsAsHostObjects-flag" class="headerlink" title="serializer._setTreatArrayBufferViewsAsHostObjects(flag)"></a>serializer._setTreatArrayBufferViewsAsHostObjects(flag)</h6><h5 id="v8-Deserializer类"><a href="#v8-Deserializer类" class="headerlink" title="v8.Deserializer类"></a>v8.Deserializer类</h5><h6 id="new-Deserializer-buffer"><a href="#new-Deserializer-buffer" class="headerlink" title="new Deserializer(buffer)"></a>new Deserializer(buffer)</h6><h6 id="deserializer-readHeader"><a href="#deserializer-readHeader" class="headerlink" title="deserializer.readHeader()"></a>deserializer.readHeader()</h6><h6 id="deserializer-readValue"><a href="#deserializer-readValue" class="headerlink" title="deserializer.readValue()"></a>deserializer.readValue()</h6><h6 id="deserializer-transferArrayBuffer-id-arrayBuffer"><a href="#deserializer-transferArrayBuffer-id-arrayBuffer" class="headerlink" title="deserializer.transferArrayBuffer(id, arrayBuffer)"></a>deserializer.transferArrayBuffer(id, arrayBuffer)</h6><h6 id="deserializer-getWriteFormatVersion"><a href="#deserializer-getWriteFormatVersion" class="headerlink" title="deserializer.getWriteFormatVersion()"></a>deserializer.getWriteFormatVersion()</h6><h6 id="deserializer-readUint32"><a href="#deserializer-readUint32" class="headerlink" title="deserializer.readUint32()"></a>deserializer.readUint32()</h6><h6 id="deserializer-readUint64"><a href="#deserializer-readUint64" class="headerlink" title="deserializer.readUint64()"></a>deserializer.readUint64()</h6><h6 id="deserializer-readDouble"><a href="#deserializer-readDouble" class="headerlink" title="deserializer.readDouble()"></a>deserializer.readDouble()</h6><h6 id="deserializer-readRawBytes-length"><a href="#deserializer-readRawBytes-length" class="headerlink" title="deserializer.readRawBytes(length)"></a>deserializer.readRawBytes(length)</h6><h6 id="deserializer-readHostObject"><a href="#deserializer-readHostObject" class="headerlink" title="deserializer._readHostObject()"></a>deserializer._readHostObject()</h6><h5 id="v8-DefaultSerializer类"><a href="#v8-DefaultSerializer类" class="headerlink" title="v8.DefaultSerializer类"></a>v8.DefaultSerializer类</h5><h5 id="v8-DefaultDeserializer类"><a href="#v8-DefaultDeserializer类" class="headerlink" title="v8.DefaultDeserializer类"></a>v8.DefaultDeserializer类</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;v8&quot;&gt;&lt;a href=&quot;#v8&quot; class=&quot;headerlink&quot; title=&quot;v8&quot;&gt;&lt;/a&gt;v8&lt;/h2&gt;&lt;p&gt;V8引擎。&lt;/p&gt;
&lt;p&gt;v8模块暴露了特定于内置到Nodejs二进制文件中的V8版本的API。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const v8 &amp;#x3D; require(&amp;#39;v8&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;API和实现随时可能发生变化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之util</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-util.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-util.html</id>
    <published>2020-02-07T10:17:25.000Z</published>
    <updated>2020-02-07T10:17:46.618Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之url</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-url.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-url.html</id>
    <published>2020-02-07T10:16:26.000Z</published>
    <updated>2020-02-07T10:16:55.819Z</updated>
    
    <content type="html"><![CDATA[<h2 id="url"><a href="#url" class="headerlink" title="url"></a>url</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;url&quot;&gt;&lt;a href=&quot;#url&quot; class=&quot;headerlink&quot; title=&quot;url&quot;&gt;&lt;/a&gt;url&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之tty</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-tty.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-tty.html</id>
    <published>2020-02-07T09:45:24.000Z</published>
    <updated>2020-02-07T10:15:48.970Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tty"><a href="#tty" class="headerlink" title="tty"></a>tty</h2><p>终端。</p><p>tty模块提供tty.ReadStream和tty.WriteStream类。<br>大多数情况下，没有必要或可能直接使用此模块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const tty &#x3D; require(&#39;tty&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>当Nodejs检测到它附加了文本终端TTY时，默认，process.stdin将被初始化为tty.ReadStream的一个示例，process.stdout和process.stderr将被初始化为tty.WriteStream的实例。<br>判断Nodejs是否在TTY上下文中运行的首选方法是检查process.stdout.isTTY属性的值是否为true。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot;</span><br><span class="line">true</span><br><span class="line">$ node -p -e &quot;Boolean(process.stdout.isTTY)&quot; | cat</span><br><span class="line">false</span><br></pre></td></tr></table></figure><h4 id="tty-ReadStream类"><a href="#tty-ReadStream类" class="headerlink" title="tty.ReadStream类"></a>tty.ReadStream类</h4><p>代表TTY的可读端。<br>正常情况中，processs.stdin将会使Nodejs进程中唯一的tty.ReadStream实例，并且没有理由创建其他的实例。</p><h5 id="readStream-isRaw"><a href="#readStream-isRaw" class="headerlink" title="readStream.isRaw"></a>readStream.isRaw</h5><p>布尔值，如果TTY当前配置为作为原始设备运行，则为true，默认false</p><h5 id="readStream-isTTY"><a href="#readStream-isTTY" class="headerlink" title="readStream.isTTY"></a>readStream.isTTY</h5><p>布尔值，对于tty.readStream实例始终为true。</p><h5 id="readStream-setRawMode-mode"><a href="#readStream-setRawMode-mode" class="headerlink" title="readStream.setRawMode(mode)"></a>readStream.setRawMode(mode)</h5><p>允许配置tty.ReadStream，使其作为原始设备运行。</p><h4 id="tty-WriteStream类"><a href="#tty-WriteStream类" class="headerlink" title="tty.WriteStream类"></a>tty.WriteStream类</h4><p>代表TTY的可写端。<br>在正常情况中，process.stdout和process.stdder将会是为nodejs进程创建的唯一的tty.WriteStream实例，并且没有理由创建其他的实例。</p><h5 id="resize事件"><a href="#resize事件" class="headerlink" title="resize事件"></a>resize事件</h5><p>只要writeStream.colums或writeStream.rows属性发生更改，就会触发resize事件。<br>调用时，没有参数传递给监听器回调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.on(&#39;resize&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;屏幕大小已经改变&#39;);</span><br><span class="line">  console.log(&#96;$&#123;process.stdout.columns&#125;x$&#123;process.stdout.rows&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="writeStream-clearLine-dir-callback"><a href="#writeStream-clearLine-dir-callback" class="headerlink" title="writeStream.clearLine(dir[,callback])"></a>writeStream.clearLine(dir[,callback])</h5><p>在dir标识的方向上清除此WriteStream的当前行。</p><h5 id="writeStream-clearScreenDown-callback"><a href="#writeStream-clearScreenDown-callback" class="headerlink" title="writeStream.clearScreenDown([callback])"></a>writeStream.clearScreenDown([callback])</h5><p>从当前光标向下清除此WriteStream。</p><h5 id="writeStream-columns"><a href="#writeStream-columns" class="headerlink" title="writeStream.columns"></a>writeStream.columns</h5><p>一个数字，指定TTY当前具有的列数。每当触发resize事件时，此属性都会更新。</p><h5 id="writeStream-cursorTo-x-y-callback"><a href="#writeStream-cursorTo-x-y-callback" class="headerlink" title="writeStream.cursorTo(x[,y][,callback])"></a>writeStream.cursorTo(x[,y][,callback])</h5><p>将writeStream的光标移动到指定的位置。</p><h5 id="writeStream-getColorDepth-env"><a href="#writeStream-getColorDepth-env" class="headerlink" title="writeStream.getColorDepth([env])"></a>writeStream.getColorDepth([env])</h5><p>使用此函数可检测终端支持的颜色。</p><h5 id="writeStream-getWindowSize"><a href="#writeStream-getWindowSize" class="headerlink" title="writeStream.getWindowSize()"></a>writeStream.getWindowSize()</h5><p>返回此writeStream对应的TTY的大小。</p><h5 id="writeStream-hasColors-count-env"><a href="#writeStream-hasColors-count-env" class="headerlink" title="writeStream.hasColors([count][,env])"></a>writeStream.hasColors([count][,env])</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.hasColors();</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 16 种颜色。</span><br><span class="line">process.stdout.hasColors(256);</span><br><span class="line">&#x2F;&#x2F; 返回 true 或 false，取决于 &#96;stdout&#96; 是否支持至少 256 种颜色。</span><br><span class="line">process.stdout.hasColors(&#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 true。</span><br><span class="line">process.stdout.hasColors(2 ** 24, &#123; TMUX: &#39;1&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; 返回 false (环境设置假设支持 2 ** 8 种颜色)。</span><br></pre></td></tr></table></figure><h5 id="writeStream-isTTY"><a href="#writeStream-isTTY" class="headerlink" title="writeStream.isTTY"></a>writeStream.isTTY</h5><p>布尔值，始终未true。</p><h5 id="writeStream-moveCursor-dx-dy-callback"><a href="#writeStream-moveCursor-dx-dy-callback" class="headerlink" title="writeStream.moveCursor(dx, dy[, callback])"></a>writeStream.moveCursor(dx, dy[, callback])</h5><p>将writeStream的光标相当于其当前位置移动。</p><h5 id="writeStream-rows"><a href="#writeStream-rows" class="headerlink" title="writeStream.rows"></a>writeStream.rows</h5><p>一个数字，指定TTY当前具有的行数。<br>每当触发resize事件时，此属性都会更新。</p><h4 id="tty-isatty-fd"><a href="#tty-isatty-fd" class="headerlink" title="tty.isatty(fd)"></a>tty.isatty(fd)</h4><p>如果给定的fd与TTY相关联，则tty.isatty(fd)返回true，否则返回false，包括fd不是非负整数时。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;tty&quot;&gt;&lt;a href=&quot;#tty&quot; class=&quot;headerlink&quot; title=&quot;tty&quot;&gt;&lt;/a&gt;tty&lt;/h2&gt;&lt;p&gt;终端。&lt;/p&gt;
&lt;p&gt;tty模块提供tty.ReadStream和tty.WriteStream类。&lt;br&gt;大多数情况下，没有必要或可能直接使用此模块。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const tty &amp;#x3D; require(&amp;#39;tty&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之trace_events</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-trace-events.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-trace-events.html</id>
    <published>2020-02-07T07:01:46.000Z</published>
    <updated>2020-02-07T09:44:36.816Z</updated>
    
    <content type="html"><![CDATA[<h2 id="trace-events"><a href="#trace-events" class="headerlink" title="trace_events"></a>trace_events</h2><p>跟踪事件。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const trace_events &#x3D; require(&#39;trace_events&#39;);</span><br><span class="line">const t1 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node&#39;, &#39;v8&#39;] &#125;);</span><br><span class="line">const t2 &#x3D; trace_events.createTracing(&#123; categories: [&#39;node.perf&#39;, &#39;node&#39;] &#125;);</span><br><span class="line">t1.enable();</span><br><span class="line">t2.enable();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,node.perf,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br><span class="line"></span><br><span class="line">t2.disable(); &#x2F;&#x2F; Will only disable emission of the &#39;node.perf&#39; category</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Prints &#39;node,v8&#39;</span><br><span class="line">console.log(trace_events.getEnabledCategories());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;trace-events&quot;&gt;&lt;a href=&quot;#trace-events&quot; class=&quot;headerlink&quot; title=&quot;trace_events&quot;&gt;&lt;/a&gt;trace_events&lt;/h2&gt;&lt;p&gt;跟踪事件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>node-tls</title>
    <link href="http://gpp-note.top/articles/2020-02-07-node-tls.html"/>
    <id>http://gpp-note.top/articles/2020-02-07-node-tls.html</id>
    <published>2020-02-07T07:01:19.000Z</published>
    <updated>2020-02-07T07:01:19.496Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>NodeJs之timer</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-timer.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-timer.html</id>
    <published>2020-02-06T14:11:32.000Z</published>
    <updated>2020-02-07T07:00:52.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>定时器。</p><p>timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。<br>因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。</p><p>Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。</p><a id="more"></a><h4 id="Immediate类"><a href="#Immediate类" class="headerlink" title="Immediate类"></a>Immediate类</h4><p>此对象在内部创建，并从setImmediate()返回。可以传给clearImmediate()以取消计划的操作。</p><p>默认，当预定immediate时，只要immediate激活，Nodejs事件循环将继续运行。<br>setImmediate()返回的Immediate对象导出immediate.ref()和immediate.unref()函数，这些函数可用于控制此默认行为。</p><h5 id="immediate-hasRef"><a href="#immediate-hasRef" class="headerlink" title="immediate.hasRef()"></a>immediate.hasRef()</h5><p>如果未true，则Immediate对象将会使Nodejs事件循环保持活动状态。</p><h5 id="immediate-ref"><a href="#immediate-ref" class="headerlink" title="immediate.ref()"></a>immediate.ref()</h5><p>调用时，只要immediate处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用immediate.ref()将无效。</p><p>默认，所有Immediate对象都是ref的，通常不需要调用Immediate.ref()，除非之前调用了Immediate.unref()</p><h5 id="immediate-unref"><a href="#immediate-unref" class="headerlink" title="immediate.unref()"></a>immediate.unref()</h5><p>调用时，活动的Immediate对象不需要Nodejs事件循环保持活动状态。如果没有其他活动保持事件循环运行，<br>则进程可以在调用Immediate对象的回调之前推出。多次调用Immediate.unref()将无效。</p><h4 id="Timeout类"><a href="#Timeout类" class="headerlink" title="Timeout类"></a>Timeout类</h4><p>此对象在内部创建，并从setTimeout()和setInterval()返回。<br>它可以传给clearTimeout()或clearInterval()以取消计划的操作。</p><p>默认情况，当使用setTimeout()或setInterval()预定定时器时，只要定时器处于活动状态，<br>Nodejs事件循环将继续运行。这些函数返回的每个Timeout对象都会导出timeout.ref()和timeout.unref()函数，<br>这些函数可用于控制此默认行为。</p><h5 id="timeout-hasRef"><a href="#timeout-hasRef" class="headerlink" title="timeout.hasRef()"></a>timeout.hasRef()</h5><p>如果为true，则timeout对象将会使Nodejs事件循环保持活动状态。</p><h5 id="timeout-ref"><a href="#timeout-ref" class="headerlink" title="timeout.ref()"></a>timeout.ref()</h5><p>调用时，只要timeout处于活动状态，就会请求Nodejs事件循环不会退出。<br>多次调用timeout.ref()将无效。</p><p>默认，所有Timeout对象都是ref的，通常不需要调用timeout.ref()，除非之前调用了timeout.unref()</p><h5 id="timeout-refresh"><a href="#timeout-refresh" class="headerlink" title="timeout.refresh()"></a>timeout.refresh()</h5><p>将定时器的开始时间设置为当前时间，并重新安排定时器以在之前指定的持续时间内调用其回调，<br>并将其调整为当前时间，这对于在不分配新JavaScript对象的情况下刷新定时器非常有用。</p><h5 id="timeout-unref"><a href="#timeout-unref" class="headerlink" title="timeout.unref()"></a>timeout.unref()</h5><p>调用时，活动的Timeout对象不需要Nodejs事件循环保持活动状态。<br>如果没有其他活动保持事件循环运行，则进程可以在调用Timeout对象的回调之前退出。<br>多次调用timeout.unref()将无效。</p><p>调用timeout.unref()会创建一个内部定时器，它将唤醒Nodejs事件循环。<br>创建太多这些定时器可能会对Nodejs应用程序的性能产生负面影响。</p><h4 id="预定定时器"><a href="#预定定时器" class="headerlink" title="预定定时器"></a>预定定时器</h4><h5 id="setImmediate-callback-…args"><a href="#setImmediate-callback-…args" class="headerlink" title="setImmediate(callback[,…args])"></a>setImmediate(callback[,…args])</h5><p>预定在I/O事件的回调之后立即执行的callback。</p><p>当多次调用setImmediate()时，callback函数将按照创建它们的顺序排队等待执行。<br>每次事件循环迭代都会处理整个回调队列。<br>如果立即定时器是从正在执行的回调排入队列，则直到下一次事件循环迭代才会触发。</p><p>如果callback不是函数，则抛出TypeError</p><h5 id="setInterval-callback-delay-…args"><a href="#setInterval-callback-delay-…args" class="headerlink" title="setInterval(callback, delay[, …args])"></a>setInterval(callback, delay[, …args])</h5><p>预定每隔delay毫秒重复执行callback。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h5 id="setTimeout-callback-delay-…args"><a href="#setTimeout-callback-delay-…args" class="headerlink" title="setTimeout(callback, delay[, …args])"></a>setTimeout(callback, delay[, …args])</h5><p>预定在delay毫秒之后执行一次性的callback。</p><p>可能不会精确的在delay毫秒时调用callback。<br>Nodejs不保证回调被触发的确切时间，也不保证他们的顺序。<br>回调会在尽可能接近指定的时间调用。</p><p>当delay大于2147483647或小于1时，delay将设置为1。<br>非整数的延迟会被截断为整数。</p><p>如果callback不是函数，则抛出TypeError。</p><h4 id="取消定时器"><a href="#取消定时器" class="headerlink" title="取消定时器"></a>取消定时器</h4><p>setImmediate()/setInterval()/setTimeout()方法各自返回表示预定的定时器的对象。<br>它们可用于取消定时器并防止其触发。</p><p>无法取消使用setImmediate()/setTimeout()的Promise化的变体创建的定时器。</p><h5 id="clearImmediate-immediate"><a href="#clearImmediate-immediate" class="headerlink" title="clearImmediate(immediate)"></a>clearImmediate(immediate)</h5><p>取消由setImmediate()创建的Immediate对象。</p><h5 id="clearInterval-timeout"><a href="#clearInterval-timeout" class="headerlink" title="clearInterval(timeout)"></a>clearInterval(timeout)</h5><p>取消由setInterval()创建的Timeout对象。</p><h5 id="clearTimeout-timeout"><a href="#clearTimeout-timeout" class="headerlink" title="clearTimeout(timeout)"></a>clearTimeout(timeout)</h5><p>取消由setTimeout()创建的Timeout对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;timer&quot;&gt;&lt;a href=&quot;#timer&quot; class=&quot;headerlink&quot; title=&quot;timer&quot;&gt;&lt;/a&gt;timer&lt;/h2&gt;&lt;p&gt;定时器。&lt;/p&gt;
&lt;p&gt;timer模块暴露了一个全局的API，用于预定在将来某个时间段调用的函数。&lt;br&gt;因为定时器函数是全局变量，所以不需要调用require(‘timers’)来使用API。&lt;/p&gt;
&lt;p&gt;Nodejs中的定时器函数实现了与Web浏览器提供的定时器API类似的API，但是使用了不同的内部实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之string_decoder</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-string-decoder.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-string-decoder.html</id>
    <published>2020-02-06T14:04:27.000Z</published>
    <updated>2020-02-06T14:11:06.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="string-decoder"><a href="#string-decoder" class="headerlink" title="string_decoder"></a>string_decoder</h2><p>字符串解码器。</p><p>提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const &#123; StringDecoder &#125; &#x3D; require(&#39;string_decoder&#39;);</span><br><span class="line">const decoder &#x3D; new StringDecoder(&#39;utf8&#39;);</span><br><span class="line"></span><br><span class="line">const cent &#x3D; Buffer.from([0xC2, 0xA2]);</span><br><span class="line">console.log(decoder.write(cent));</span><br><span class="line"></span><br><span class="line">const euro &#x3D; Buffer.from([0xE2, 0x82, 0xAC]);</span><br><span class="line">console.log(decoder.write(euro));</span><br></pre></td></tr></table></figure><p>将Buffer实例写入StringDecoder实例时，将使用内部缓冲区来确保已解码的字符串不包含任何不完整的多字节字符。它们保存在缓冲区中，直到下一次调用stringDecoder.write()或调用stringDecoder.end()为止。</p><h4 id="StringDecoder类"><a href="#StringDecoder类" class="headerlink" title="StringDecoder类"></a>StringDecoder类</h4><h5 id="new-StringDecoder-encoding"><a href="#new-StringDecoder-encoding" class="headerlink" title="new StringDecoder([encoding])"></a>new StringDecoder([encoding])</h5><p>创建一个新的StringDecoder实例。</p><h5 id="stringDecoder-end-buffer"><a href="#stringDecoder-end-buffer" class="headerlink" title="stringDecoder.end([buffer])"></a>stringDecoder.end([buffer])</h5><p>以字符串形式返回存储在内部缓冲区中的任何剩余输入。 表示不完整的 UTF-8 和 UTF-16 字符的字节将替换为适合字符编码的替换字符。</p><p>如果提供了 buffer 参数，则在返回剩余的输入之前再最后一次调用 stringDecoder.write()</p><h5 id="stringDecoder-write-buffer"><a href="#stringDecoder-write-buffer" class="headerlink" title="stringDecoder.write(buffer)"></a>stringDecoder.write(buffer)</h5><p>返回一个已解码的字符串，确保在返回的字符串不包含 Buffer、 TypedArray 或 DataView 末尾的任何不完整的多字节字符，并将其存储在内部缓冲区中，以便下次调用 stringDecoder.write() 或 stringDecoder.end()。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;string-decoder&quot;&gt;&lt;a href=&quot;#string-decoder&quot; class=&quot;headerlink&quot; title=&quot;string_decoder&quot;&gt;&lt;/a&gt;string_decoder&lt;/h2&gt;&lt;p&gt;字符串解码器。&lt;/p&gt;
&lt;p&gt;提供了一个API，用于以保留编码的多字节UTF-8和UTF-16字符的方式将Buffer对象解码为字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const &amp;#123; StringDecoder &amp;#125; &amp;#x3D; require(&amp;#39;string_decoder&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之stream</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-stream.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-stream.html</id>
    <published>2020-02-06T14:04:10.000Z</published>
    <updated>2020-02-06T14:05:32.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;stream&quot;&gt;&lt;a href=&quot;#stream&quot; class=&quot;headerlink&quot; title=&quot;stream&quot;&gt;&lt;/a&gt;stream&lt;/h2&gt;
      
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之repl</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-repl.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-repl.html</id>
    <published>2020-02-06T13:41:23.000Z</published>
    <updated>2020-02-06T14:03:43.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="repl"><a href="#repl" class="headerlink" title="repl"></a>repl</h2><p>交互式解释器</p><p>repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="设计与特性"><a href="#设计与特性" class="headerlink" title="设计与特性"></a>设计与特性</h4><p>repl模块导出了repl.REPLServer类。当repl.REPLServer实例运行时，它接收用户输入的每一行，根据用户定义的解释函数解释这些输入，然后输出结果。<br>repl.REPLServer实例支持输入的自动补全、精简Emacs风格的行编辑、多行输入、ANSI风格的输出、当前REPL会话状态的保存于恢复、错误校正、以及可定制的解释函数。</p><h4 id="命令与特殊键"><a href="#命令与特殊键" class="headerlink" title="命令与特殊键"></a>命令与特殊键</h4><ul><li>.break - 在输入一个多行表达式的过程中，输入 .break 命令（或按下 <ctrl>-C 组合键）将终止表达式的继续输入。</li><li>.clear - 重置 REPL 的 context 为一个空对象，并清除当前正输入的所有多行表达式。</li><li>.exit - 关闭输入输出流，退出 REPL。</li><li>.help - 显示特定命令的帮助列表。</li><li>.save - 保存当前 REPL 会话到一个文件： &gt; .save ./file/to/save.js</li><li>.load - 读取一个文件到当前 REPL 会话。 &gt; .load ./file/to/load.js</li><li>.editor 进入编辑模式（<ctrl>-D 完成， <ctrl>-C 取消）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; .editor</span><br><span class="line">&#x2F;&#x2F; 进入编辑模式（^D 完成，^C 取消）</span><br><span class="line">function welcome(name) &#123;</span><br><span class="line">  return &#96;你好 $&#123;name&#125;！&#96;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">welcome(&#39;Node.js 用户&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ^D</span><br><span class="line">&#39;你好 Node.js 用户！&#39;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="默认的解释器"><a href="#默认的解释器" class="headerlink" title="默认的解释器"></a>默认的解释器</h4><p>默认情况下，所有repl.REPLServer实例使用了一个解释函数，它可以解释JavaScript表达式、提供对Nodejs内置模块的访问。当repl.REPLServer实例被创建时可以传入一个替换的解释函数，覆盖其默认的功能。</p><h5 id="JavaScript表达式"><a href="#JavaScript表达式" class="headerlink" title="JavaScript表达式"></a>JavaScript表达式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1 + 1</span><br><span class="line">2</span><br><span class="line">&gt; const m &#x3D; 2</span><br><span class="line">undefined</span><br><span class="line">&gt; m + 1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h5 id="全局作用域与局部作用域"><a href="#全局作用域与局部作用域" class="headerlink" title="全局作用域与局部作用域"></a>全局作用域与局部作用域</h5><p>默认的解释器提供了获取存在于全局作用域中的任何变量的途径。 可以通过给每个 REPLServer 绑定的 context 对象指定变量，来显式地把变量暴露给 REPL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">repl.start(&#39;&gt; &#39;).context.m &#x3D; msg;</span><br></pre></td></tr></table></figure><p>context 对象的属性表现为 REPL 中的局部变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node repl_test.js</span><br><span class="line">&gt; m</span><br><span class="line">&#39;message&#39;</span><br></pre></td></tr></table></figure><p>默认情况下 context 的属性不是只读的。 要指定只读的全局变量， context 的属性必须使用 Object.defineProperty() 来定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const repl &#x3D; require(&#39;repl&#39;);</span><br><span class="line">const msg &#x3D; &#39;message&#39;;</span><br><span class="line"></span><br><span class="line">const r &#x3D; repl.start(&#39;&gt; &#39;);</span><br><span class="line">Object.defineProperty(r.context, &#39;m&#39;, &#123;</span><br><span class="line">  configurable: false,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  value: msg</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="访问Nodejs核心模块"><a href="#访问Nodejs核心模块" class="headerlink" title="访问Nodejs核心模块"></a>访问Nodejs核心模块</h5><p>默认的解释器会自动加载被调用的 Node.js 核心模块到 REPL 环境中。 例如，除非被声明为一个全局变量或一个有限范围的变量，否则输入 fs 会被解释为 global.fs = require(‘fs’)。</p><figure class="highlight plain"><figcaption><span>fs.createReadStream('./some/file');```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 全局的未捕获异常</span><br><span class="line">REPL 使用 domain 模块来捕获该 REPL 会话的所有未捕获的异常。</span><br><span class="line"></span><br><span class="line">在 REPL 中对 domain 模块的这种使用具有以下的副作用：</span><br><span class="line"></span><br><span class="line">* 未捕获的异常仅在独立的 REPL 中触发 &#39;uncaughtException&#39; 事件。 在另一个 Node.js 程序的 REPL 中添加此事件的监听器会抛出 ERR_INVALID_REPL_INPUT。</span><br><span class="line"></span><br><span class="line">* 尝试使用 process.setUncaughtExceptionCaptureCallback() 会抛出 ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE 错误。</span><br><span class="line"></span><br><span class="line">作为独立程序：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));</p><p>throw new Error(‘foobar’);<br>// 未捕获的异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当在另一个应用程序中使用时：</span><br></pre></td></tr></table></figure><p>process.on(‘uncaughtException’, () =&gt; console.log(‘未捕获的异常’));<br>// TypeError [ERR_INVALID_REPL_INPUT]: Listeners for <code>uncaughtException</code><br>// cannot be used in the REPL</p><p>throw new Error(‘foobar’);<br>// 抛出:<br>// Error: foobar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### _ 变量的赋值</span><br><span class="line"></span><br><span class="line">默认的解释器会把最近一次解释的表达式的结果赋值给变量 _ （下划线）。 显式地设置 _ 为某个值能禁用该特性。</span><br></pre></td></tr></table></figure><blockquote><p>[ ‘a’, ‘b’, ‘c’ ]<br>[ ‘a’, ‘b’, ‘c’ ]<br>_.length<br>3<br>_ += 1<br>Expression assignment to _ now disabled.<br>4<br>1 + 1<br>2<br>_<br>4</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">同样， _error 将指向最后一次看到的错误（如果有的话）。 将 _error 显式设置为值将禁用此行为</span><br></pre></td></tr></table></figure><blockquote><p>throw new Error(‘foo’);<br>Error: foo<br>_error.message<br>‘foo’</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### await关键词</span><br><span class="line">使用 --experimental-repl-await 命令行选项，将启用对 await 关键字的实验性支持。</span><br></pre></td></tr></table></figure><blockquote><p>await Promise.resolve(123)<br>123<br>await Promise.reject(new Error(‘REPL await’))<br>Error: REPL await<br>    at repl:1:45<br>const timeout = util.promisify(setTimeout);<br>undefined<br>const old = Date.now(); await timeout(1000); console.log(Date.now() - old);<br>1002<br>undefined</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义的解释函数</span><br><span class="line">当创建一个新的 repl.REPLServer 时，可以提供一个自定义的解释函数。 这可以用于实现完全定制化的 REPL 应用。</span><br><span class="line"></span><br><span class="line">以下是 REPL 的一个假设的示例，执行从一种语言到另一种语言的文本转换：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);<br>const { Translator } = require(‘translator’);</p><p>const myTranslator = new Translator(‘en’, ‘fr’);</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, myTranslator.translate(cmd));<br>}</p><p>repl.start({ prompt: ‘&gt; ‘, eval: myEval });</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 可恢复的错误</span><br><span class="line">当用户正在 REPL 中输入时，按下 &lt;enter&gt; 键会把当前行的输入发送到 eval 函数。 为了支持多行输入， eval 函数可以返回一个 repl.Recoverable 实例给提供的回调函数：</span><br></pre></td></tr></table></figure><p>function myEval(cmd, context, filename, callback) {<br>  let result;<br>  try {<br>    result = vm.runInThisContext(cmd);<br>  } catch (e) {<br>    if (isRecoverableError(e)) {<br>      return callback(new repl.Recoverable(e));<br>    }<br>  }<br>  callback(null, result);<br>}</p><p>function isRecoverableError(error) {<br>  if (error.name === ‘SyntaxError’) {<br>    return /^(Unexpected end of input|Unexpected token)/.test(error.message);<br>  }<br>  return false;<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 自定义REPL输出</span><br><span class="line">默认情况下，在把输出写入到提供的可写流（默认为 process.stdout）之前，repl.REPLServer 实例会使用 util.inspect() 方法对输出进行格式化。 showProxy 检查选项会默认设置为 true， colors 选项会设置为 true，具体取决于 REPL 的 useColors 选项。</span><br><span class="line"></span><br><span class="line">可以在构造时指定 useColors 布尔值选项，以指示默认的编写器使用 ANSI 样式代码来着色来自 util.inspect() 方法的输出。</span><br><span class="line"></span><br><span class="line">如果 REPL 作为独立程序运行，则还可以使用 inspect.replDefaults 属性从 REPL 内部更改 REPL 的检查默认值util.inspect()，该属性是 util.inspect() 中的 defaultOptions 的镜像。</span><br></pre></td></tr></table></figure><blockquote><p>util.inspect.replDefaults.compact = false;<br>false<br>[1]<br>[<br>  1<br>]</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在构造时，通过在 writer 选项传入一个新的函数，可以完全地自定义一个 repl.REPLServer 实例的输出。 例子，把输入的任何文本转换为大写：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>const r = repl.start({ prompt: ‘&gt; ‘, eval: myEval, writer: myWriter });</p><p>function myEval(cmd, context, filename, callback) {<br>  callback(null, cmd);<br>}</p><p>function myWriter(output) {<br>  return output.toUpperCase();<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### REPLServer类</span><br><span class="line">repl.REPLServer 的实例是使用 repl.start() 方法创建的，不能直接地使用 JavaScript 的 new 关键字创建。</span><br><span class="line"></span><br><span class="line">##### exit事件</span><br><span class="line">当接收到 .exit 命令、或按下两次 &lt;ctrl&gt;-C 发出 SIGINT 信号、或按下 &lt;ctrl&gt;-D 发出 &#39;end&#39; 信号而使 REPL 被退出时，触发 &#39;exit&#39; 事件。 监听器的回调函数被调用时不带任何参数。</span><br></pre></td></tr></table></figure><p>replServer.on(‘exit’, () =&gt; {<br>  console.log(‘从 REPL 接收到 “exit” 事件！’);<br>  process.exit();<br>});</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### reset事件</span><br><span class="line">当 REPL 的上下文被重置时，触发 &#39;reset&#39; 事件。 每当接收到 .clear 命令时会触发该事件，除非 REPL 正在使用默认的解释器并且 repl.REPLServer 实例被创建时 useGlobal 选项被设为 true。 监听器的回调函数被调用时会带上 context 对象作为惟一的参数。</span><br><span class="line"></span><br><span class="line">这主要被用于重新初始化 REPL 上下文，使之达到某些预定义的状态，如下面的例子：</span><br></pre></td></tr></table></figure><p>const repl = require(‘repl’);</p><p>function initializeContext(context) {<br>  context.m = ‘test’;<br>}</p><p>const r = repl.start({ prompt: ‘&gt; ‘ });<br>initializeContext(r.context);</p><p>r.on(‘reset’, initializeContext);</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当代码被执行时，全局的 &#39;m&#39; 变量可以被修改，但随后的 .clear 命令会把它重置回初始值：</span><br></pre></td></tr></table></figure><p>$ ./node example.js</p><blockquote><p>m<br>‘test’<br>m = 1<br>1<br>m<br>1<br>.clear<br>Clearing context…<br>m<br>‘test’</p></blockquote><p>```</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;repl&quot;&gt;&lt;a href=&quot;#repl&quot; class=&quot;headerlink&quot; title=&quot;repl&quot;&gt;&lt;/a&gt;repl&lt;/h2&gt;&lt;p&gt;交互式解释器&lt;/p&gt;
&lt;p&gt;repl模块提供了一种“读取-求值-输出”循环（REPL）的实现，它可作为一个独立的程序或其它应用中。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const repl &amp;#x3D; require(&amp;#39;repl&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之readline</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-readline.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-readline.html</id>
    <published>2020-02-06T13:02:01.000Z</published>
    <updated>2020-02-06T13:41:00.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="readline"><a href="#readline" class="headerlink" title="readline"></a>readline</h2><p>逐行读取。<br>提供了一个接口，用于一次一行的读取可读流中的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const readline &#x3D; require(&#39;readline&#39;);</span><br><span class="line"></span><br><span class="line">const rl &#x3D; readline.createInterface(&#123;</span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">rl.question(&#39;你如何看待 Node.js 中文网？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; TODO：将答案记录在数据库中。</span><br><span class="line">  console.log(&#96;感谢您的宝贵意见：$&#123;answer&#125;&#96;);</span><br><span class="line"></span><br><span class="line">  rl.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦调用此代码，Nodejs应用程序将不会终止，直到readline.Interface关闭，<br>因为接口在Input流上等待接收数据。</p><h4 id="Interface类"><a href="#Interface类" class="headerlink" title="Interface类"></a>Interface类</h4><p>readline.Interface类的实例是使用readline.createInterface()方法构造的。<br>每个实例都关联一个input可读流和一个output可写流。<br>output流用于为到达的用户输入打印提示，并从input流读取。</p><h4 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h4><p>当发生以下任一情况时会触发close事件：</p><ul><li>调用rl.close()方法，且readline.Interface实例放弃对input流和output流的控制；</li><li>input流接收到其end事件；</li><li>input流接收到<ctrl>-D以发信号传输结束；</li><li>input流接收到<ctrl>-C以发信号SIGINT，并且readline.Interface实例上没有注册SIGINT事件监听器。<br>调用监听器函数不传入任何参数。</li></ul><p>一旦触发close事件，则readline.Interface实例就完成了。</p><h5 id="line事件"><a href="#line事件" class="headerlink" title="line事件"></a>line事件</h5><p>每当input流接收到行尾输入（\n, \r, \r\n）时会触发line事件。</p><h5 id="pause事件"><a href="#pause事件" class="headerlink" title="pause事件"></a>pause事件</h5><p>当发生以下任一情况时会触发pause事件：</p><ul><li>input流被暂停</li><li>input流未暂停，且接收到SIGCONT事件</li></ul><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;pause&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 暂停&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="resume事件"><a href="#resume事件" class="headerlink" title="resume事件"></a>resume事件</h5><p>每当input流恢复时，就会触发resume事件。<br>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;resume&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Readline 恢复&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGCONT事件"><a href="#SIGCONT事件" class="headerlink" title="SIGCONT事件"></a>SIGCONT事件</h5><p>当先前使用<ctrl>-Z移入后台的Nodejs进程使用fg返回到前台时，就会触发SIGCONT事件。<br>如果input流在SIGTSTP请求之前被暂停，则不会触发此事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGCONT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; &#96;prompt&#96; 将自动恢复流。</span><br><span class="line">  rl.prompt();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGCONT事件。</p><h5 id="SIGINT事件"><a href="#SIGINT事件" class="headerlink" title="SIGINT事件"></a>SIGINT事件</h5><p>每当input流接收到<ctrl>-C输入时，就会触发SIGINT事件。<br>如果当input流接收到SIGINT时没有注册SIGINT事件监听器，则会触发pause事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  rl.question(&#39;确定要退出吗？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">    if (answer.match(&#x2F;^y(es)?$&#x2F;i)) rl.pause();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="SIGTSTP事件"><a href="#SIGTSTP事件" class="headerlink" title="SIGTSTP事件"></a>SIGTSTP事件</h5><p>每当input流接收到<ctrl>-Z输入时，就会触发SIGTSTP事件。<br>如果当input流接收SIGTSTP时没有注册SIGTSTP事件监听器，则Nodejs进程将被发送到后台。</p><p>当使用fg(1p)恢复程序时，将触发pause和SIGCONT事件，这可用于恢复input流。</p><p>如果在将进程发送到后台之前暂停input，则不会触发pause和SIGCONT事件。</p><p>调用监听器函数时不传入任何参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rl.on(&#39;SIGTSTP&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 这将覆盖 SIGTSTP 并阻止程序进入后台。</span><br><span class="line">  console.log(&#39;捕获 SIGTSTP&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Windows上不支持SIGTSTP事件。</p><h5 id="rl-close"><a href="#rl-close" class="headerlink" title="rl.close()"></a>rl.close()</h5><p>会关闭readline.Interface实例，并放弃对input和output流的控制。<br>当调用时，将触发close事件。</p><p>调用rl.close()不会立即停止readline.Interface实例触发的其他事件。</p><h5 id="rl-pause"><a href="#rl-pause" class="headerlink" title="rl.pause()"></a>rl.pause()</h5><p>会暂停input流，允许稍后在必要时恢复它。<br>调用rl.pause()不会立刻暂停readline.Interfac实例触发的其他事件。</p><h5 id="rl-prompt-preserveCursor"><a href="#rl-prompt-preserveCursor" class="headerlink" title="rl.prompt([preserveCursor])"></a>rl.prompt([preserveCursor])</h5><p>将readline.Interface实例配置的提示写入putput中的新一行，以便为用户提供一个可供输入位置。</p><p>当调用时，如果input流已暂停，则rl.prompt()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入提示。</p><h5 id="rl-question-query-callback"><a href="#rl-question-query-callback" class="headerlink" title="rl.question(query, callback)"></a>rl.question(query, callback)</h5><p>通过将query写入output来显示它，并等待用户在input上提供输入，然后调用callback函数将提供的输入作为第一个参数传入。</p><p>当调用时，如果input流已暂停，则rl.question()将恢复input流。</p><p>如果readline.Interface创建时output将被设置为null或undefined，则不会写入query。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.question(&#39;你最喜欢的食物是什么？&#39;, (answer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;你最喜欢的食物是 $&#123;answer&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="rl-resume"><a href="#rl-resume" class="headerlink" title="rl.resume()"></a>rl.resume()</h5><p>如果input流已暂停，则rl.resume方法将恢复它。</p><h5 id="rl-setPrompt-prompt"><a href="#rl-setPrompt-prompt" class="headerlink" title="rl.setPrompt(prompt)"></a>rl.setPrompt(prompt)</h5><p>设置每当调用rl.prompt()时将写入output的提示。</p><h5 id="rl-write-data-key"><a href="#rl-write-data-key" class="headerlink" title="rl.write(data[, key])"></a>rl.write(data[, key])</h5><p>将data或key标识的按键序列写入output。<br>仅当output是TTY文本终端时才支持key参数。<br>如果指定了key，则忽略data。<br>当调用时，如果input流已暂停，则rl.write()将恢复它。</p><p>如果readline.Interface创建时output被设置为null或undefined，则不会写入data和key。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rl.write(&#39;删除这个！&#39;);</span><br><span class="line">&#x2F;&#x2F; 模拟 Ctrl+u 删除先前写入的行。</span><br><span class="line">rl.write(null, &#123; ctrl: true, name: &#39;u&#39; &#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;readline&quot;&gt;&lt;a href=&quot;#readline&quot; class=&quot;headerlink&quot; title=&quot;readline&quot;&gt;&lt;/a&gt;readline&lt;/h2&gt;&lt;p&gt;逐行读取。&lt;br&gt;提供了一个接口，用于一次一行的读取可读流中的数据。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const readline &amp;#x3D; require(&amp;#39;readline&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之querystring</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-querystring.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-querystring.html</id>
    <published>2020-02-06T12:53:13.000Z</published>
    <updated>2020-02-06T13:01:26.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="querystring"><a href="#querystring" class="headerlink" title="querystring"></a>querystring</h2><p>查询字符串。<br>querystring模块提供用于解析和格式化URL查询字符串的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const querystring &#x3D; require(&#39;querystring&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="querystring-decode"><a href="#querystring-decode" class="headerlink" title="querystring.decode()"></a>querystring.decode()</h4><p>是querystring.parse()的别名。</p><h4 id="querystring-encode"><a href="#querystring-encode" class="headerlink" title="querystring.encode()"></a>querystring.encode()</h4><p>是querystring.stringify()的别名。</p><h4 id="querystring-escape-str"><a href="#querystring-escape-str" class="headerlink" title="querystring.escape(str)"></a>querystring.escape(str)</h4><p>以对URL查询字符串的特定要求进行了优化的方式对给定的str执行URL百分比编码。</p><h4 id="querystring-parse-str-sep-eq-options"><a href="#querystring-parse-str-sep-eq-options" class="headerlink" title="querystring.parse(str[,sep[,eq[, options]]])"></a>querystring.parse(str[,sep[,eq[, options]]])</h4><p>将URL查询字符串str解析为键值对的集合。</p><h4 id="querystring-stringify-obj-sep-eq-options"><a href="#querystring-stringify-obj-sep-eq-options" class="headerlink" title="querystring.stringify(obj[,sep[,eq[, options]]])"></a>querystring.stringify(obj[,sep[,eq[, options]]])</h4><p>通过迭代对象的自身属性从给定的obj生成URL查询字符串。</p><h4 id="querystring-unescape-str"><a href="#querystring-unescape-str" class="headerlink" title="querystring.unescape(str)"></a>querystring.unescape(str)</h4><p>在给定的str上执行URL百分比编码字符的解码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;querystring&quot;&gt;&lt;a href=&quot;#querystring&quot; class=&quot;headerlink&quot; title=&quot;querystring&quot;&gt;&lt;/a&gt;querystring&lt;/h2&gt;&lt;p&gt;查询字符串。&lt;br&gt;querystring模块提供用于解析和格式化URL查询字符串的实用工具。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const querystring &amp;#x3D; require(&amp;#39;querystring&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之process</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-process.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-process.html</id>
    <published>2020-02-06T11:42:00.000Z</published>
    <updated>2020-02-06T12:52:49.265Z</updated>
    
    <content type="html"><![CDATA[<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>进程。<br>process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。<br>作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const process &#x3D; require(&#39;process&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h4><p>process对象是EventEmitter的实例。</p><h5 id="beforeExit事件"><a href="#beforeExit事件" class="headerlink" title="beforeExit事件"></a>beforeExit事件</h5><p>当Nodejs清空其事件循环并且没有其他工作要安排时，会触发beforeExit事件。<br>通常，Nodejs进程将在没有调度工作时退出，但在beforeExit事件上注册的监听器可以进行异步调用，从而导致Nodejs进程继续。</p><p>调用监听器回调函数时会将process.exitCode的值作为唯一参数传入。</p><p>对于导致显示终止的条件，不会触发beforeExit事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;beforeExit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 beforeExit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;进程 exit 事件的代码: &#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&#39;此消息最新显示&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 打印:</span><br><span class="line">&#x2F;&#x2F; 此消息最新显示</span><br><span class="line">&#x2F;&#x2F; 进程 beforeExit 事件的代码: 0</span><br><span class="line">&#x2F;&#x2F; 进程 exit 事件的代码: 0</span><br></pre></td></tr></table></figure><h5 id="disconnect事件"><a href="#disconnect事件" class="headerlink" title="disconnect事件"></a>disconnect事件</h5><p>如果使用IPC通道衍生Nodejs进程，则在IPC通道关闭时将触发disconnect事件。</p><h5 id="exit事件"><a href="#exit事件" class="headerlink" title="exit事件"></a>exit事件</h5><p>当Nodejs进程因以下原因之一即将退出时，则会触发exit事件：</p><ul><li>显示调用process.exit()方法</li><li>Nodejs事件循环不再需要执行任何其他工作<br>此时无法阻止退出事件循环，并且一旦所有exit事件的监听器都已完成运行时，nodejs进程将终止。</li></ul><p>用process.exitCode属性指定的退出码或传给process.exit()方法的exitCode参数调用监听器回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;exit&#39;, (code) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#96;退出码: $&#123;code&#125;&#96;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>监听器函数必须只执行同步操作。<br>在调用exit事件监听器之后，Nodejs进程将立即退出，从而导致在事件循环中仍排队的任何其他工作被放弃。</p><h5 id="message事件"><a href="#message事件" class="headerlink" title="message事件"></a>message事件</h5><p>如果使用IPC通道衍生Nodejs进程，则只要子进程收到父进程使用childprocess.send()发送的消息，就会触发message事件。</p><p>消息会进行序列化和解析。生成的消息可能与最初发送的消息不同。</p><h5 id="multipleResolves事件"><a href="#multipleResolves事件" class="headerlink" title="multipleResolves事件"></a>multipleResolves事件</h5><p>只要Promise有以下情况，将会触发multipleResolves事件：</p><ul><li>解决不止一次</li><li>拒绝不止一次</li><li>解决后拒绝</li><li>拒绝后解决</li></ul><h5 id="rejectionHandled事件"><a href="#rejectionHandled事件" class="headerlink" title="rejectionHandled事件"></a>rejectionHandled事件</h5><p>每当Promise被拒绝且错误处理函数附加到它晚于一个Nodejs事件循环时，就会触发rejectHandled事件。</p><p>Promise对象之前已经在unhandledRejection事件中触发，但在处理过程中获得了拒绝处理函数。</p><p>Promise链中没有顶层的概念，总是可以处理拒绝。本质上自身是异步的，可以在未来的某个时间点处理Promise拒绝，可能比触发unhandledRejection事件所需的事件循环更晚。</p><p>在同步代码中，当未处理的异常列表增长时，会触发uncaughtexption事件。<br>在异步代码中，当未处理的异常列表增长时，会触发unhandledRejection事件，并且当未处理的拒绝列表缩小时会触发rejectionHandled事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const unhandledRejections &#x3D; new Map();</span><br><span class="line">process.on(&#39;unhandledRejection&#39;, (reason, promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.set(promise, reason);</span><br><span class="line">&#125;);</span><br><span class="line">process.on(&#39;rejectionHandled&#39;, (promise) &#x3D;&gt; &#123;</span><br><span class="line">  unhandledRejections.delete(promise);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="uncaughtException事件"><a href="#uncaughtException事件" class="headerlink" title="uncaughtException事件"></a>uncaughtException事件</h5><p>当未捕获的JavaScript异常一直冒泡回到事件循环时，会触发uncaughtExpection事件。</p><h5 id="unhandledRejection事件"><a href="#unhandledRejection事件" class="headerlink" title="unhandledRejection事件"></a>unhandledRejection事件</h5><p>如果在事件循环的一次轮询中，一个Promise被拒绝，并且此Promise没有绑定错误处理器，unhandledRejection事件会被触发。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;process&quot;&gt;&lt;a href=&quot;#process&quot; class=&quot;headerlink&quot; title=&quot;process&quot;&gt;&lt;/a&gt;process&lt;/h2&gt;&lt;p&gt;进程。&lt;br&gt;process对象是一个全局变量，它提供有关当前NodeJs进程的信息并对其进行控制。&lt;br&gt;作为一个全局变量，它始终可供Nodejs应用程序使用，无需使用require()，它也可以使用require()显示访问。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const process &amp;#x3D; require(&amp;#39;process&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之perf_hooks</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-perf-hooks.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-perf-hooks.html</id>
    <published>2020-02-06T11:08:11.000Z</published>
    <updated>2020-02-06T11:41:24.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="perf-hooks"><a href="#perf-hooks" class="headerlink" title="perf_hooks"></a>perf_hooks</h2><p>性能钩子。</p><p>性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const &#123; PerformanceObserver, performance &#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((items) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(items.getEntries()[0].duration);</span><br><span class="line">  performance.clearMarks();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;measure&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;A&#39;);</span><br><span class="line">doSomeLongRunningProcess(() &#x3D;&gt; &#123;</span><br><span class="line">  performance.mark(&#39;B&#39;);</span><br><span class="line">  performance.measure(&#39;A to B&#39;, &#39;A&#39;, &#39;B&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Performance类"><a href="#Performance类" class="headerlink" title="Performance类"></a>Performance类</h4><h5 id="performance-clearMarks-name"><a href="#performance-clearMarks-name" class="headerlink" title="performance.clearMarks([name])"></a>performance.clearMarks([name])</h5><h5 id="performance-mark-name"><a href="#performance-mark-name" class="headerlink" title="performance.mark([name])"></a>performance.mark([name])</h5><p>创建一个新的PerformanceMark实体。</p><h5 id="performance-measure-name-startMark-endMark"><a href="#performance-measure-name-startMark-endMark" class="headerlink" title="performance.measure(name, startMark, endMark)"></a>performance.measure(name, startMark, endMark)</h5><h5 id="performance-nodeTiming"><a href="#performance-nodeTiming" class="headerlink" title="performance.nodeTiming"></a>performance.nodeTiming</h5><h5 id="performance-now"><a href="#performance-now" class="headerlink" title="performance.now()"></a>performance.now()</h5><h5 id="performance-timeOrigin"><a href="#performance-timeOrigin" class="headerlink" title="performance.timeOrigin"></a>performance.timeOrigin</h5><h5 id="performance-timerify-fn"><a href="#performance-timerify-fn" class="headerlink" title="performance.timerify(fn)"></a>performance.timerify(fn)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">function someFunction() &#123;</span><br><span class="line">  console.log(&#39;hello world&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const wrapped &#x3D; performance.timerify(someFunction);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries()[0].duration);</span><br><span class="line">  obs.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;function&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; A performance timeline entry will be created</span><br><span class="line">wrapped();</span><br></pre></td></tr></table></figure><h4 id="PerformanceEntry类"><a href="#PerformanceEntry类" class="headerlink" title="PerformanceEntry类"></a>PerformanceEntry类</h4><h5 id="performanceEntry-duration"><a href="#performanceEntry-duration" class="headerlink" title="performanceEntry.duration"></a>performanceEntry.duration</h5><h5 id="performanceEntry-name"><a href="#performanceEntry-name" class="headerlink" title="performanceEntry.name"></a>performanceEntry.name</h5><h5 id="performanceEntry-startTime"><a href="#performanceEntry-startTime" class="headerlink" title="performanceEntry.startTime"></a>performanceEntry.startTime</h5><h5 id="performanceEntry-entryType"><a href="#performanceEntry-entryType" class="headerlink" title="performanceEntry.entryType"></a>performanceEntry.entryType</h5><h5 id="performanceEntry-kind"><a href="#performanceEntry-kind" class="headerlink" title="performanceEntry.kind"></a>performanceEntry.kind</h5><h4 id="PerformanceObserver类"><a href="#PerformanceObserver类" class="headerlink" title="PerformanceObserver类"></a>PerformanceObserver类</h4><h5 id="new-PerformanceObserver-callback"><a href="#new-PerformanceObserver-callback" class="headerlink" title="new PerformanceObserver(callback)"></a>new PerformanceObserver(callback)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(list.getEntries());</span><br><span class="line">  observer.disconnect();</span><br><span class="line">&#125;);</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">performance.mark(&#39;test&#39;);</span><br></pre></td></tr></table></figure><h5 id="performanceObserver-disconnect"><a href="#performanceObserver-disconnect" class="headerlink" title="performanceObserver.disconnect()"></a>performanceObserver.disconnect()</h5><h5 id="performanceObserver-observe-options"><a href="#performanceObserver-observe-options" class="headerlink" title="performanceObserver.observe(options)"></a>performanceObserver.observe(options)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called three times synchronously. &#96;list&#96; contains one item.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;buffered是false的时候，callback会在每次PerformanceEntry的时候回调。</span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;] &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">const &#123;</span><br><span class="line">  performance,</span><br><span class="line">  PerformanceObserver</span><br><span class="line">&#125; &#x3D; require(&#39;perf_hooks&#39;);</span><br><span class="line"></span><br><span class="line">const obs &#x3D; new PerformanceObserver((list, observer) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; Called once. &#96;list&#96; contains three items.</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obs.observe(&#123; entryTypes: [&#39;mark&#39;], buffered: true &#125;);</span><br><span class="line"></span><br><span class="line">for (let n &#x3D; 0; n &lt; 3; n++)</span><br><span class="line">  performance.mark(&#96;test$&#123;n&#125;&#96;);</span><br></pre></td></tr></table></figure><h5 id="PerformanceObserverEntryList类"><a href="#PerformanceObserverEntryList类" class="headerlink" title="PerformanceObserverEntryList类"></a>PerformanceObserverEntryList类</h5><h5 id="performanceObserverEntryList-getEntries"><a href="#performanceObserverEntryList-getEntries" class="headerlink" title="performanceObserverEntryList.getEntries()"></a>performanceObserverEntryList.getEntries()</h5><h5 id="performanceObserverEntryList-getEntriesByName-name-type"><a href="#performanceObserverEntryList-getEntriesByName-name-type" class="headerlink" title="performanceObserverEntryList.getEntriesByName(name[,type])"></a>performanceObserverEntryList.getEntriesByName(name[,type])</h5><h4 id="Histogram类"><a href="#Histogram类" class="headerlink" title="Histogram类"></a>Histogram类</h4><h5 id="histogram-disable"><a href="#histogram-disable" class="headerlink" title="histogram.disable()"></a>histogram.disable()</h5><h5 id="histogram-enable"><a href="#histogram-enable" class="headerlink" title="histogram.enable()"></a>histogram.enable()</h5><h5 id="histogram-exceeds"><a href="#histogram-exceeds" class="headerlink" title="histogram.exceeds"></a>histogram.exceeds</h5><h5 id="histogram-max"><a href="#histogram-max" class="headerlink" title="histogram.max"></a>histogram.max</h5><h5 id="histogram-mean"><a href="#histogram-mean" class="headerlink" title="histogram.mean"></a>histogram.mean</h5><h5 id="histogram-min"><a href="#histogram-min" class="headerlink" title="histogram.min"></a>histogram.min</h5><h5 id="histogram-reset"><a href="#histogram-reset" class="headerlink" title="histogram.reset()"></a>histogram.reset()</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;perf-hooks&quot;&gt;&lt;a href=&quot;#perf-hooks&quot; class=&quot;headerlink&quot; title=&quot;perf_hooks&quot;&gt;&lt;/a&gt;perf_hooks&lt;/h2&gt;&lt;p&gt;性能钩子。&lt;/p&gt;
&lt;p&gt;性能计时API提供了W3C性能的实现，该API目的是支持高精度性能指标的收集，保存和获取性能相关的度量数据。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之path</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-path.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-path.html</id>
    <published>2020-02-06T08:57:18.000Z</published>
    <updated>2020-02-06T11:07:20.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><p>路径。<br>path模块提供用于处理文件路径和目录路径的实用工具。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const path &#x3D; require(&#39;path&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="path-dirname-path"><a href="#path-dirname-path" class="headerlink" title="path.dirname(path)"></a>path.dirname(path)</h4><p>返回path的目录名。</p><h4 id="path-extname-path"><a href="#path-extname-path" class="headerlink" title="path.extname(path)"></a>path.extname(path)</h4><p>返回path的扩展名。</p><h4 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h4><p>从对象返回路径字符串。</p><h4 id="path-isAbsolute-path"><a href="#path-isAbsolute-path" class="headerlink" title="path.isAbsolute(path)"></a>path.isAbsolute(path)</h4><p>检测path是否为绝对路径。</p><h4 id="path-join-…paths"><a href="#path-join-…paths" class="headerlink" title="path.join([…paths])"></a>path.join([…paths])</h4><p>使用平台特定的分隔符作为定界符将所有给定的path片段连接在一起，然后规范化生成的路径。</p><h4 id="path-normalize-path"><a href="#path-normalize-path" class="headerlink" title="path.normalize(path)"></a>path.normalize(path)</h4><p>规范化给定的path，解析’..’和’.’片段。</p><h4 id="path-parse-path"><a href="#path-parse-path" class="headerlink" title="path.parse(path)"></a>path.parse(path)</h4><p>返回一个对象，其属性表示path的重要元素。尾部的目录分隔符将被忽略。</p><h4 id="path-relative-from-to"><a href="#path-relative-from-to" class="headerlink" title="path.relative(from, to)"></a>path.relative(from, to)</h4><p>根据当前工作目录返回from到to的相对路径。<br>如果from和to各自解析到相同的路径，则返回零长度的字符串。</p><h4 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h4><p>将路径或路径片段的序列解析为绝对路径。</p><h4 id="path-sep"><a href="#path-sep" class="headerlink" title="path.sep"></a>path.sep</h4><p>提供pingt特定的路径片段分隔符。</p><h4 id="path-win32"><a href="#path-win32" class="headerlink" title="path.win32"></a>path.win32</h4><p>提供对特定于Windows的path方法的实现的访问。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;path&quot;&gt;&lt;a href=&quot;#path&quot; class=&quot;headerlink&quot; title=&quot;path&quot;&gt;&lt;/a&gt;path&lt;/h2&gt;&lt;p&gt;路径。&lt;br&gt;path模块提供用于处理文件路径和目录路径的实用工具。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const path &amp;#x3D; require(&amp;#39;path&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之os</title>
    <link href="http://gpp-note.top/articles/2020-02-06-node-os.html"/>
    <id>http://gpp-note.top/articles/2020-02-06-node-os.html</id>
    <published>2020-02-06T08:41:50.000Z</published>
    <updated>2020-02-06T08:56:58.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="os"><a href="#os" class="headerlink" title="os"></a>os</h2><p>操作系统。</p><p>os模块提供了与操作系统相关的实用方法和属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const os &#x3D; require(&#39;os&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="os-EOL"><a href="#os-EOL" class="headerlink" title="os.EOL"></a>os.EOL</h4><p>操作系统特定的行末标志。</p><ul><li>在POSIX上是\n</li><li>在Windows上是\r\n</li></ul><h4 id="os-constants"><a href="#os-constants" class="headerlink" title="os.constants"></a>os.constants</h4><p>包含错误码、进程信号等常用的操作系统特定的常量。<br>定义的特定常量在os常量中定义。</p><h4 id="os-cpus"><a href="#os-cpus" class="headerlink" title="os.cpus()"></a>os.cpus()</h4><p>返回一个对象数组，其中包含有关每个逻辑CPU内核的信息。</p><h4 id="os-endianness"><a href="#os-endianness" class="headerlink" title="os.endianness()"></a>os.endianness()</h4><p>返回一个字符串，该字符串标识为其编译Nodejs二进制文件的CPU的字节序。<br>可能的值有，BE用于大端字节序，LE用于小端字节序。</p><h4 id="os-freemem"><a href="#os-freemem" class="headerlink" title="os.freemem()"></a>os.freemem()</h4><p>以整数的形式返回空闲的系统内存量。</p><h4 id="os-getPriority-pid"><a href="#os-getPriority-pid" class="headerlink" title="os.getPriority([pid])"></a>os.getPriority([pid])</h4><p>返回由pid指定的进程的调度优先级。如果未提供pid或为0，则返回当前进程的优先级。</p><h4 id="os-homedir"><a href="#os-homedir" class="headerlink" title="os.homedir()"></a>os.homedir()</h4><p>返回当前用户的主目录的字符串路径。</p><h4 id="os-hostname"><a href="#os-hostname" class="headerlink" title="os.hostname()"></a>os.hostname()</h4><p>以字符串的形式返回操作系统的主机名。</p><h4 id="os-platform"><a href="#os-platform" class="headerlink" title="os.platform()"></a>os.platform()</h4><p>返回标识操作系统平台的字符串。</p><h4 id="os-release"><a href="#os-release" class="headerlink" title="os.release()"></a>os.release()</h4><p>以字符串的形式返回操作系统。</p><h4 id="os-tmpdir"><a href="#os-tmpdir" class="headerlink" title="os.tmpdir()"></a>os.tmpdir()</h4><p>以字符串的形式返回操作系统的默认临时文件目录。</p><h4 id="os-totalmem"><a href="#os-totalmem" class="headerlink" title="os.totalmem()"></a>os.totalmem()</h4><p>以整数的形式返回系统的内存总量。</p><h4 id="os-type"><a href="#os-type" class="headerlink" title="os.type()"></a>os.type()</h4><p>返回与uname(3)返回一样的操作系统名字。</p><h4 id="os-uptime"><a href="#os-uptime" class="headerlink" title="os.uptime()"></a>os.uptime()</h4><p>返回系统的正常运行时间</p><h4 id="os-userInfo-options"><a href="#os-userInfo-options" class="headerlink" title="os.userInfo([options])"></a>os.userInfo([options])</h4><p>返回关于当前有效的用户信息。</p><h4 id="os常量"><a href="#os常量" class="headerlink" title="os常量"></a>os常量</h4><p>并不是所有的常量在每一个操作系统上都是可用的。<br>下面的常量被os.constants所输出。</p><h5 id="信号常量"><a href="#信号常量" class="headerlink" title="信号常量"></a>信号常量</h5><p>os.constants.signals</p><h5 id="错误常量"><a href="#错误常量" class="headerlink" title="错误常量"></a>错误常量</h5><p>os.constants.errno</p><h5 id="POSIX错误常量"><a href="#POSIX错误常量" class="headerlink" title="POSIX错误常量"></a>POSIX错误常量</h5><h5 id="Windows系统特有的错误常量"><a href="#Windows系统特有的错误常量" class="headerlink" title="Windows系统特有的错误常量"></a>Windows系统特有的错误常量</h5><h5 id="dlopen常量"><a href="#dlopen常量" class="headerlink" title="dlopen常量"></a>dlopen常量</h5><h5 id="优先级常量"><a href="#优先级常量" class="headerlink" title="优先级常量"></a>优先级常量</h5><h5 id="libuv常量"><a href="#libuv常量" class="headerlink" title="libuv常量"></a>libuv常量</h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;os&quot;&gt;&lt;a href=&quot;#os&quot; class=&quot;headerlink&quot; title=&quot;os&quot;&gt;&lt;/a&gt;os&lt;/h2&gt;&lt;p&gt;操作系统。&lt;/p&gt;
&lt;p&gt;os模块提供了与操作系统相关的实用方法和属性。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const os &amp;#x3D; require(&amp;#39;os&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs之net</title>
    <link href="http://gpp-note.top/articles/2020-02-05-node-net.html"/>
    <id>http://gpp-note.top/articles/2020-02-05-node-net.html</id>
    <published>2020-02-05T13:59:35.000Z</published>
    <updated>2020-02-06T08:41:26.810Z</updated>
    
    <content type="html"><![CDATA[<h2 id="net"><a href="#net" class="headerlink" title="net"></a>net</h2><p>网络。</p><p>net模块用于创建基于流的TCP或IPC的服务器与客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const net &#x3D; require(&#39;net&#39;)</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="IPC支持"><a href="#IPC支持" class="headerlink" title="IPC支持"></a>IPC支持</h4><p>net模块在windows上支持命名管道IPC，在其他操作系统上支持Unix域套接字。</p><h4 id="net-Server类"><a href="#net-Server类" class="headerlink" title="net.Server类"></a>net.Server类</h4><p>此类用于创建TCP或IPC服务器。</p><h5 id="new-net-Server-options-connectionListener"><a href="#new-net-Server-options-connectionListener" class="headerlink" title="new net.Server([options][,connectionListener])"></a>new net.Server([options][,connectionListener])</h5><p>net.Server是一个EventEmitter，实现了以下事件：</p><ul><li><p>close事件<br>  当Server关闭的时候触发，如果有连接存在，直到所有的连接结束才会触发这个事件。</p></li><li><p>connection事件<br>  当一个新的连接建立的时候触发。socket是一个net.Socket实例。</p></li><li><p>error事件<br>  当错误出现的时候触发。</p></li><li><p>listening事件<br>  当调用server.listen()绑定服务器之后触发。</p></li></ul><h5 id="server-address"><a href="#server-address" class="headerlink" title="server.address()"></a>server.address()</h5><p>如果在IP socket上监听，则返回操作系统报告的绑定的address、地址family名称、以及服务器port（<br>用于查找在获取操作系统分配的地址时分配的端口）：<code>{port:12346, family:&#39;IPv4&#39;, address:&#39;127.0.0.1&#39;}</code></p><p>对于在管道或Unix域套接字上监听的server，该名称返回为字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const server &#x3D; net.createServer((socket) &#x3D;&gt; &#123;</span><br><span class="line">  socket.end(&#39;再见\n&#39;);</span><br><span class="line">&#125;).on(&#39;error&#39;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F; 处理错误</span><br><span class="line">  throw err;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取任意未使用的端口。</span><br><span class="line">server.listen(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;打开服务器&#39;, server.address());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不要在listening事件触发之前调用server.address()</p><h5 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback])"></a>server.close([callback])</h5><p>组织server接受新的连接并保持现有的连接。<br>该函数是异步的，server将在所有连接结束后关闭并触发close事件。<br>可选的callback将在close事件发生时被调用。</p><h5 id="server-getConnections-callback"><a href="#server-getConnections-callback" class="headerlink" title="server.getConnections(callback)"></a>server.getConnections(callback)</h5><p>异步获取服务器的当前并发连接数。当socket被传递给子进程时工作。<br>回调函数的两个参数是err和count。</p><h5 id="server-listen"><a href="#server-listen" class="headerlink" title="server.listen()"></a>server.listen()</h5><p>启动一个服务器来监听连接。</p><h5 id="server-listening"><a href="#server-listening" class="headerlink" title="server.listening"></a>server.listening</h5><p>表明server是否正在监听连接。</p><h5 id="server-maxConnections"><a href="#server-maxConnections" class="headerlink" title="server.maxConnections"></a>server.maxConnections</h5><p>该属性使得server连接数过多时拒绝连接。</p><h5 id="server-ref"><a href="#server-ref" class="headerlink" title="server.ref()"></a>server.ref()</h5><p>与unref()相反，在一个已经调用unref的server中调用ref，如果server是仅存的server，<br>则程序不会退出。对一个已经调用ref的server再次调用ref()将不会再有效果。</p><h5 id="server-unref"><a href="#server-unref" class="headerlink" title="server.unref()"></a>server.unref()</h5><p>如果这个server在事件系统中是唯一有效的，那么对server调用unref()将允许程序退出。<br>如果这个server已经调用过unref那么再次调用unref()将不会再有效果。</p><h4 id="net-Socket类"><a href="#net-Socket类" class="headerlink" title="net.Socket类"></a>net.Socket类</h4><p>net.Socket可以由用户创建并且直接与服务器进行交互。<br>也可以由Nodejs创建，并在收到连接时传给用户。</p><h5 id="new-net-Socket-options"><a href="#new-net-Socket-options" class="headerlink" title="new net.Socket([options])"></a>new net.Socket([options])</h5><p>创建一个socket对象。</p><h5 id="close事件"><a href="#close事件" class="headerlink" title="close事件"></a>close事件</h5><p>一旦socket完全关闭就发出该事件。</p><h5 id="connect事件"><a href="#connect事件" class="headerlink" title="connect事件"></a>connect事件</h5><p>当一个socket连接成功建立的时候触发该事件。</p><h5 id="data事件"><a href="#data事件" class="headerlink" title="data事件"></a>data事件</h5><p>当接收到数据的时候触发该事件。<br>data参数是一个Buffer或String<br>当Socket触发data事件的时候，如果没有监听器则数据将会丢失。</p><h5 id="drain事件"><a href="#drain事件" class="headerlink" title="drain事件"></a>drain事件</h5><p>当写入缓冲区变为空时触发。可以用来做上传节流。</p><h5 id="end事件"><a href="#end事件" class="headerlink" title="end事件"></a>end事件</h5><p>当socket的另一端发送一个FIN包的时候触发，从而结束socket的可读流。</p><h5 id="error事件"><a href="#error事件" class="headerlink" title="error事件"></a>error事件</h5><p>当错误发生时触发。close事件也会紧接着该事件被触发。</p><h5 id="lookup事件"><a href="#lookup事件" class="headerlink" title="lookup事件"></a>lookup事件</h5><p>当找到主机之后创建连接之前触发。</p><h5 id="ready事件"><a href="#ready事件" class="headerlink" title="ready事件"></a>ready事件</h5><p>套接字准备好使用时触发。<br>connect后立即触发。</p><h5 id="timeout事件"><a href="#timeout事件" class="headerlink" title="timeout事件"></a>timeout事件</h5><p>当socket超时的时候触发。</p><h5 id="socket-connect"><a href="#socket-connect" class="headerlink" title="socket.connect()"></a>socket.connect()</h5><h5 id="socket-connecting"><a href="#socket-connecting" class="headerlink" title="socket.connecting()"></a>socket.connecting()</h5><h5 id="socket-destrory-exception"><a href="#socket-destrory-exception" class="headerlink" title="socket.destrory([exception])"></a>socket.destrory([exception])</h5><h5 id="socket-destroyed"><a href="#socket-destroyed" class="headerlink" title="socket.destroyed"></a>socket.destroyed</h5><p>指示连接是否已经被销毁。<br>一旦连接被销毁就不能再使用它传输任何数据。</p><h5 id="socket-end-data-encoding-callback"><a href="#socket-end-data-encoding-callback" class="headerlink" title="socket.end([data[,encoding]][, callback])"></a>socket.end([data[,encoding]][, callback])</h5><p>半关闭socket。</p><h4 id="net-isIP-input"><a href="#net-isIP-input" class="headerlink" title="net.isIP(input)"></a>net.isIP(input)</h4><p>测试输入是否是IP地址。<br>无效的字符串则返回0<br>IPv4地址则返回4<br>IPv6的地址则返回6</p><h4 id="net-isIPv4-input"><a href="#net-isIPv4-input" class="headerlink" title="net.isIPv4(input)"></a>net.isIPv4(input)</h4><p>如果输入是IPv4地址返回true，否则返回false</p><h4 id="net-isIPv6-input"><a href="#net-isIPv6-input" class="headerlink" title="net.isIPv6(input)"></a>net.isIPv6(input)</h4><p>如果输入是IPv6地址返回true，否则返回false</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;net&quot;&gt;&lt;a href=&quot;#net&quot; class=&quot;headerlink&quot; title=&quot;net&quot;&gt;&lt;/a&gt;net&lt;/h2&gt;&lt;p&gt;网络。&lt;/p&gt;
&lt;p&gt;net模块用于创建基于流的TCP或IPC的服务器与客户端。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const net &amp;#x3D; require(&amp;#39;net&amp;#39;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Node" scheme="http://gpp-note.top/categories/Node/"/>
    
    
      <category term="Node" scheme="http://gpp-note.top/tags/Node/"/>
    
  </entry>
  
</feed>
